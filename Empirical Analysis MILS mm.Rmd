---
title: "Mutual Insurance and Land Security in Rural Ghana"
author: "Georgios Manalis  & Karol Mazur"
date: ""
header-includes:
   - \usepackage{amsmath}
   - \usepackage{dcolumn}
   - \usepackage{caption}
   - \captionsetup[table]{position=top}
   - \usepackage{pdflscape}
   - \newcommand{\blandscape}{\begin{landscape}}
   - \newcommand{\elandscape}{\end{landscape}}
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = "C:/Users/gnman/Desktop/Datafiles")
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning=FALSE)
```


```{r}
library(rlang)
library(wesanderson)
library(dplyr)
library(tidyverse)
library(magrittr)
library(ggplot2)
library(gmodels)
library(tidyverse)
library(xlsx)
library(xtable)
library(tidyselect)
library(ggpubr)
library(rgdal)
library(descr, quietly = TRUE)
library(pander)
library(kableExtra)
library(clubSandwich)
library(gmodels)
library(foreign)
library(summarytools)
library(knitr)
library(kableExtra)
library(gridExtra)
library(haven)
library(weights)
library(latex2exp)
library(magick)
library(webshot)
library(ggridges)
library(DescTools)
library(lmtest)
library(plm)
library(stargazer)
library(modelr)
library(xlsx)
# tinytex::install_tinytex()
# # installing/loading the package:
# if(!require(installr)) { install.packages("installr"); require(installr)} #load / install+load installr
#  
# # Installing pandoc
# install.pandoc()
select = dplyr::select
# devtools::install_github("hadley/dplyr#2190")
library(officer)
library(gghighlight)
library(ggthemes)
```

\par 
The present draft performs the final version of the empirical analysis. Regarding the main explanatory variable , here I have constructed the new land rights measure and I try to repeat the empirical analysis. The difference is that now we account for plots that have "selling rights" and "selling + security rights" as having selling rights. Before we only accounted for those which only had "selling rights"


\section{Land Rights - Descriptive}

```{r land_rights_updated_jan_21}
###### Primary Info
setwd("C:/Users/gnman/Desktop/Datafiles")
key_hh_info = read.dta("./key_hhld_info.dta")

key_hh_info = key_hh_info %>% 
  mutate(id1_names = id1) %>% 
  mutate(id1 = as.numeric(id1))


file = "./land_size.csv"
plot_size = read.csv(file) %>% filter(!is.na(plotsize_ha)) # This is for both waves and plot specific, 10 plots do not have size data - i remove them. 

# First I insert the A.45 and A.50 question from wave 1. This should be at the plot level. 

a45_a50 = read_dta("./S4AIV.dta")

landrights_w1 = a45_a50 %>%  
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(plot_id = as.numeric(paste(hhno, s4aiv_plotno, sep=""))) %>% 
  mutate(s4aiv_a50 = as.numeric(s4aiv_a50)) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, plot_id, s4aiv_a45, s4aiv_a50) %>%
  filter(!is.na(plot_id))

colnames(landrights_w1)[colnames(landrights_w1)=="s4aiv_a45"]="obtainhow"
colnames(landrights_w1)[colnames(landrights_w1)=="s4aiv_a50"]="plot_rights"


# BELOW I GROUP THE ANSWERS TO HAVING LAND RIGHTS OR NOT. 

# Change the obtainhow in order to make it consistent with wave 2 categories. ie  you put rented/sharecropped/sharecropped with down payment as 3
# and allocated free as 4. 
landrights_w1 = landrights_w1 %>% 
  mutate(obtainhow = case_when(obtainhow==3 | obtainhow==4 | obtainhow==6 ~3, 
                               TRUE~as.numeric(obtainhow))) %>% 
  mutate(obtainhow = ifelse(obtainhow==5, 4, as.numeric(obtainhow))) %>% 
  mutate(sell.rights = case_when(plot_rights ==1 | plot_rights == 3 ~ 1, 
                                 plot_rights == 4 | plot_rights==2 ~ 0, 
                                 TRUE~as.numeric(NA)))  %>%
   filter(obtainhow!=3)       # Here we filter out all rented/sharecropped/sharecropped with down payment land

## wAVE 2
# Second I insert the I.1 and I.32 question from wave 2. This should be at the plot level. 
# Note that in wave 2 suprisingly enough there are no NA answers to the I.32 question as a result, we do not have to implement the two last approaches to the issue. 
i1_i32 = read_dta("./04i_landtenure.dta")


landrights_w2 = i1_i32 %>% 
  mutate(FPrimary = as.numeric(FPrimary)) %>%                 
  mutate(plot_id = as.numeric(paste(FPrimary, plotid, sep=""))) %>% 
  mutate(wave=2) %>% 
  select(wave, FPrimary, plot_id, obtainhow, righttosell) 

colnames(landrights_w2)[colnames(landrights_w2)=="FPrimary"]="hhno"
colnames(landrights_w2)[colnames(landrights_w2)=="obtainhow"]="obtainhow"
colnames(landrights_w2)[colnames(landrights_w2)=="righttosell"]="plot_rights"

landrights_w2 = left_join(landrights_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave,id1, id2, id3, hhno, plot_id, obtainhow, plot_rights)

# Change the answer to plot_rights when 0 to 4 in order to be consistent with wave 1 
landrights_w2 = landrights_w2 %>% 
                mutate(plot_rights = case_when(plot_rights==0~4, 
                                 TRUE~as.numeric(plot_rights))) %>% 
                mutate(sell.rights = case_when(plot_rights == 4 | plot_rights == 2 ~ 0, 
                                 plot_rights == 1 | plot_rights == 3 ~ 1)) %>%
                filter(obtainhow!=3)       # Here we filter out all rented/sharecropped/sharecropped with down payment land

# Next, I bind the two waves together to have the sell rights per plot for both waves. 
land_rights = rbind(landrights_w1, landrights_w2) %>% 
              mutate(plot_rights = as.numeric(plot_rights)) %>% 
              select(wave, id1, id2, id3, hhno, plot_id, sell.rights) %>% 
              mutate(id2 = as.numeric(id2)) %>% 
              mutate(id3 = as.numeric(id3)) %>%  
              mutate(hhno = as.numeric(hhno)) %>%  
              mutate(plot_id = as.numeric(plot_id))



######################################### sO WE HAVE LAND RIGHTS FOR BOTH WAVES IN ONE DATAFRAME. 

# Below add the primary information. 1/ key hh info

land_rights_final = left_join(land_rights, key_hh_info[,c("id1_names", 'id1', 'id2', 'id3', 'hhno', 'urbrur')], by =c('id1', 'id2', 'id3', 'hhno')) %>% 
                    select(wave, id1_names, id1, id2, id3, hhno, urbrur, plot_id, sell.rights) %>% 
                    filter(!is.na(id3)) # there are plots that do not have id1,id2, id3 data - i remove them.
# 2/ plotsize_ha
land_rights_final = left_join(land_rights_final,plot_size, by = c('wave', 'id1', 'id2', 'id3', 'hhno', 'plot_id')) %>% 
                    filter(!is.na(plotsize_ha))


####################################### NOW I TAKE A STANCE TO THE NA ANSWERS OF THE FIRST WAVE REGARDING THE SELLING RIGHTS. 
# 1/ i completely ignore the NAS. 

land_rights_final.ign.na= land_rights_final %>% filter(!is.na(sell.rights)) %>%  # From 10,030 you end up w/ 7,026 plots.
                          select(wave, id1_names, id1, id2, id3, hhno, urbrur, plot_id, plotsize_ha, sell.rights)
# # 2/ i treat NAs as 0s

land_rights_final.na0 = land_rights_final %>% mutate(sell.rights_na0 = case_when(is.na(sell.rights)~0, 
                                                                                 TRUE ~ sell.rights)) %>% 
                         select(wave, id1_names, id1, id2, id3, hhno, urbrur, plot_id, plotsize_ha, sell.rights_na0)


#########################
## THIS IS THE TRANSFORMATION: ALL HHS W/ ALL PLOTS NAS IN W1 --> W2 ALL NAS AT THE HHS. 
#########################

# land_rights_final.ign.na = land_rights_final %>% group_by(wave, hhno) %>% mutate(avg.sell = mean(sell.rights)) %>% mutate(avg.sell2 = mean(sell.rights, na.rm=T)) %>% group_by(hhno) %>% mutate(avg.sell3 = mean(avg.sell2)) %>%  group_by(wave, plot_id) %>% mutate(sell.rights = case_when(is.nan(avg.sell3) ~ as.numeric(NA),
#                                                               TRUE ~ sell.rights)) %>% ungroup() %>%
#   select(wave, id1_names, id1, id2, id3, hhno, urbrur, plot_id, plotsize_ha, sell.rights) %>% filter(!is.na(sell.rights))


#you dont care about the merging at the 


 

# summary(land_rights_final.ign.na$sell.rights)
#summary(land_rights_final.na0$sell.rights_na0) # the later exhibits much lower mean. 
```

\par 
```{r, results='asis'}
####################################### DESCRIPTIVE TABLES 
# NAs removed - Both waves
land_rights_final.ign.na_table = land_rights_final.ign.na %>% ungroup() %>% group_by(sell.rights) %>% mutate(tot_land_size = sum(plotsize_ha)) %>% add_tally(name = 'num_plots') %>% select("sell.rights", "num_plots", 'tot_land_size') %>% filter(!duplicated(sell.rights))
kable(land_rights_final.ign.na_table, col.names = c('Selling-rights', 'Number of plots', 'Land size (ha)'), 'latex', caption = 'Number of plots w/ selling rights in both waves (NAs removed)') %>% kable_styling(latex_options = c("striped", "hold_position"))

# NAs as 0s - Both waves 
land_rights_final.na0_table = land_rights_final.na0 %>% ungroup() %>% group_by(sell.rights_na0) %>% mutate(tot_land_size = sum(plotsize_ha)) %>% add_tally(name = 'num_plots') %>% select("sell.rights_na0", "num_plots", 'tot_land_size') %>% filter(!duplicated(sell.rights_na0))
kable(land_rights_final.na0_table, col.names = c('Selling-rights', 'Number of plots', 'Land size (ha)'), 'latex', caption = 'Number of plots w/ selling rights in both waves (NAs as 0s)') %>% kable_styling(latex_options = c("striped", "hold_position"))

# NAs removed - Wave 1
land_rights_final.ign.na.w1_table = land_rights_final.ign.na %>% 
                              filter(wave ==1) %>% ungroup() %>% group_by(sell.rights )%>% mutate(tot_land_size = sum(plotsize_ha)) %>% add_tally(name = 'num_plots') %>% select("sell.rights", "num_plots", 'tot_land_size') %>% filter(!duplicated(sell.rights))
kable(land_rights_final.ign.na.w1_table, col.names = c('Selling-rights', 'Number of plots', 'Land size (ha)'), 'latex', caption = 'Number of plots w/ selling rights in wave 1 (NAs removed)') %>% kable_styling(latex_options = c("striped", "hold_position"))

# NAs removed - Wave 2
land_rights_final.ign.na.w2_table = land_rights_final.ign.na %>% 
                              filter(wave ==2) %>% ungroup() %>% group_by(sell.rights)%>% mutate(tot_land_size = sum(plotsize_ha)) %>% add_tally(name = 'num_plots') %>% select("sell.rights", "num_plots", 'tot_land_size') %>% filter(!duplicated(sell.rights))
kable(land_rights_final.ign.na.w2_table, col.names = c('Selling-rights', 'Number of plots', 'Land size (ha)'), 'latex', caption = 'Number of plots w/ selling rights in wave 2 (NAs removed)') %>% kable_styling(latex_options = c("striped", "hold_position"))

# NAs as 0s - Wave 1
land_rights_final.na0.w1_table = land_rights_final.na0 %>% 
                           filter(wave ==1) %>% ungroup() %>% group_by(sell.rights_na0)%>% mutate(tot_land_size = sum(plotsize_ha)) %>% add_tally(name = 'num_plots') %>% select("sell.rights_na0", "num_plots", 'tot_land_size') %>% filter(!duplicated(sell.rights_na0))
kable(land_rights_final.na0.w1_table, col.names = c('Selling-rights', 'Number of plots', 'Land size (ha)'), 'latex', caption = 'Number of plots w/ selling rights in wave 1 (NAs as 0s)') %>% kable_styling(latex_options = c("striped", "hold_position"))

# NAs as 0s - Wave 2
land_rights_final.na0.w2_table = land_rights_final.na0 %>% 
                           filter(wave ==2) %>% ungroup() %>% group_by(sell.rights_na0)%>% mutate(tot_land_size = sum(plotsize_ha)) %>% add_tally(name = 'num_plots') %>% select("sell.rights_na0", "num_plots", 'tot_land_size') %>% filter(!duplicated(sell.rights_na0))
kable(land_rights_final.na0.w2_table, col.names = c('Selling-rights', 'Number of plots', 'Land size (ha)'), 'latex', caption = 'Number of plots w/ selling rights in wave 2 (NAs as 0s)') %>% kable_styling(latex_options = c("striped", "hold_position"))

```
\par 
Notice that in \textbf{wave 2} there are not NA entries, it is only \textbf{wave 1} that has 3,004 plots with NA entry.  



<!---->
<!-- 45 DEGREE GRAPHS WITH THE UPDATED DATA -->
<!---->

```{r impose that if a hh in w1 has all plots w/ NAs  then impose NA for wa2 for the same plotsw/ corrct measurm}

```


```{r Deriving the selling rights from the land rights}
########################################### Group the land rights by wave and id3 and derive the ratio of sell rights per id3 
sell.rights_ea = land_rights_final.ign.na %>%  
                 ungroup() %>% 
                 group_by(wave, id3) %>% # For each wave and each village
                 mutate(tot_ea_land = sum(plotsize_ha, na.rm = T)) %>%  # i calculate the total village land by summing up all plots belonging there. 
                 ungroup() %>%  
                 group_by(wave, plot_id) %>% # For each plot in each wave, i calculate its weight in the formula as the ratio of its size over village land. 
                 mutate(weights = plotsize_ha/tot_ea_land) %>% 
                 ungroup() %>% 
                 group_by(wave, id3) %>%  # For each wave and each village, I calculate the weighted mean of the sell rights. 
                 mutate(sell.rights_ea.weighted = weighted.mean(sell.rights, weights, na.rm = T)) %>% 
                 group_by(wave) %>% # now just keep the village leve information and get rid of the rest.  
                 filter(!duplicated(id3)) %>% 
                 select(-plot_id, -plotsize_ha, -hhno,  -sell.rights, - weights) 

# when ignoring the NAs,  i end up w/ 519 villages in both waves 


sell.rights_ea.na0 = land_rights_final.na0 %>% 
                      ungroup() %>% 
                      group_by(wave, id3) %>% # For each wave and each village
                      mutate(tot_ea_land = sum(plotsize_ha, na.rm = T)) %>%  # i calculate the total village land by summing up all plots belonging there. 
                      ungroup() %>%  
                      group_by(wave, plot_id) %>% # For each plot in each wave, i calculate its weight in the formula as the ratio of its size over village land. 
                      mutate(weights = plotsize_ha/tot_ea_land) %>% 
                      ungroup() %>% 
                      group_by(wave, id3) %>%  # For each wave and each village, I calculate the weighted mean of the sell rights. 
                      mutate(sell.rights_ea.weighted_na0 = weighted.mean(sell.rights_na0, weights, na.rm = T)) %>% 
                      group_by(wave) %>% # now just keep the village leve information and get rid of the rest.  
                      filter(!duplicated(id3)) %>% 
                      select(-plot_id, -plotsize_ha, -hhno, -sell.rights_na0, - weights)

```




\section{From Land Rights to Selling rights measures}
\par 
Here I have grouped by wave and village and derive the size of village land that does have selling rights. This is exactly the measure that will be the main explanatory variable described by the formula below (the weighted mean of land w/ selling rights). Notice that this is a continuous variable $\in[0,1]$.

\begin{equation*}
sell\text{-}rights_{v,t} = \sum_{p\in v} \frac{\kappa_{p,t}}{\sum_{p\in v}\kappa_{p,t}}sell\text{-}rights_{p,t}
\end{equation*}

```{r Descriptive tables with number of rural and urban villages and size of land }
sell.rights_ea_tabledesc = sell.rights_ea %>% ungroup() %>% group_by(wave,urbrur) %>% mutate(loc_land = sum(tot_ea_land, na.rm = T)) %>% add_tally(name="num_of_villages") %>% filter(!duplicated(urbrur)) %>% select("wave", "urbrur", "loc_land", "num_of_villages")
kable(sell.rights_ea_tabledesc, col.names = c('Wave', 'Locality', 'Land size (ha)', "Number of villages"), 'latex', caption = 'General land info at the village level (Ignoring NAs)') %>% kable_styling(latex_options = c("striped", "hold_position"))

```

```{r NUmber of hhs participating in each wave and number of plots per hh}
#############################   Create a table with the # of hhs interviewed in each wave ##################################3
num_hhs_interviewed = land_rights_final %>%  
                      ungroup() %>% 
                      group_by(wave, id3) %>% 
                      filter(!duplicated(hhno)) %>% 
                      add_tally(name="num_hhs") %>% 
                      filter(!duplicated(id3))


num_hhs_interviewed_wide = num_hhs_interviewed %>% select(wave, id1_names, id1, id2, id3, urbrur, num_hhs) %>%  pivot_wider(names_from = wave, values_from = c(num_hhs), names_glue = "{.value}_{wave}")
# 45 degree graph with number of hhs in each village per wave. 
ggplot(num_hhs_interviewed_wide) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = num_hhs_1, y = num_hhs_2), color = "red", size = 1, alpha = 2)+
        scale_shape_identity()+
        facet_wrap(~urbrur, ncol = 2)+
        xlim(0, 17) + ylim(0, 17) +
        ggtitle("Number of households in each village in wave 1 and wave 2")+
        labs(y = "number of hhs per village in w2", x = "number of hhs per village in w1")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=10, face="bold"), 
        strip.text.x = element_text(
        size = 8, face = "bold"
        ))


# 45 degree graph with number of plots per household in each village per wave. 
num_plots_perhh = land_rights_final %>%  
                  ungroup() %>% 
                  group_by(wave, id3, hhno) %>% 
                  # filter(!duplicated(hhno)) %>% 
                  add_tally(name="num_plots_perhh") %>% 
                  mutate(hh_land = sum(plotsize_ha, na.rm = T)) %>% 
                  filter(!duplicated(hhno))

num_plots_perhh_wide = num_plots_perhh %>% select(wave, id1_names, id1, id2, id3, urbrur,hhno, num_plots_perhh, hh_land) %>%  pivot_wider(names_from = wave, values_from = c(num_plots_perhh, hh_land), names_glue = "{.value}_{wave}") %>% filter(!is.na(num_plots_perhh_1)) %>% filter(!is.na(num_plots_perhh_2))

ggplot(num_plots_perhh_wide) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = num_plots_perhh_1, y = num_plots_perhh_2), color = "red", size = 1, alpha = .1)+
        # scale_shape_identity()+
        facet_wrap(~urbrur, ncol = 2)+
        # xlim(0, 17) + ylim(0, 17) +
        ggtitle("Number of plots per household in wave 1 and wave 2")+
        labs(y = "number of plots per hh in w2", x = "number of plots per hh in w1", caption = "Matched hhs = 2182")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=10, face="bold"), 
        strip.text.x = element_text(
        size = 8, face = "bold"
        ))

ggplot(num_plots_perhh_wide) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = hh_land_1, y = hh_land_2), color = "red", size = 1, alpha = .1)+
        # scale_shape_identity()+
        facet_wrap(~urbrur, ncol = 2)+
        xlim(0, 25) + ylim(0, 25) +
        ggtitle("HH land size in wave 1 and wave 2")+
        labs(y = "hh land size in w2 (ha)", x = "hh land size in w1 (ha)", caption = "Matched hhs = 2155")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=10, face="bold"), 
        strip.text.x = element_text(
        size = 8, face = "bold"
        ))


```


```{r Descriptive, results='asis'}
pander(summary(sell.rights_ea$sell.rights_ea.weighted), caption = "Sell rights at the village level both waves (Ignoring NAs)")
pander(summary(sell.rights_ea.na0$sell.rights_ea.weighted_na0), caption = "Sell rights at the village level both waves (NAs as 0s)")
```



```{r Split the sell-rights tables into two waves} 
# Us
sell.rights_ea.spreaded =sell.rights_ea %>%  pivot_wider(names_from = wave, values_from = c(tot_ea_land, sell.rights_ea.weighted))
sell.rights_ea.na0.spreaded = sell.rights_ea.na0 %>%pivot_wider(names_from = wave, values_from = c(tot_ea_land, sell.rights_ea.weighted_na0))

```

```{r Change in land, fig.align='center'}
levels(sell.rights_ea.spreaded$id1_names) <- gsub( "Region", "", levels(sell.rights_ea.spreaded$id1_names))
levels(sell.rights_ea.na0.spreaded$id1_names) <- gsub( "Region", "", levels(sell.rights_ea.na0.spreaded$id1_names))

ggplot(subset(sell.rights_ea.spreaded, urbrur == "Rural")) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = tot_ea_land_1, y = tot_ea_land_2), color = "red", size = 1, alpha = 2)+
        scale_shape_identity()+
        facet_wrap(~id1_names, nrow = 2)+
        xlim(0, 100) + ylim(0, 100) +
        ggtitle("Village land size")+
        labs(y = "village land in w2 (ha)", x = "village land in w1 (ha)", caption = "(Rural EAs, Ignoring NAs)")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=10, face="bold"), 
        strip.text.x = element_text(
        size = 8, face = "bold"
        ))


ggplot(subset(sell.rights_ea.na0.spreaded, urbrur == "Rural")) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = tot_ea_land_1, y = tot_ea_land_2), color = "red", size = 1, alpha = 2)+
        scale_shape_identity()+
        facet_wrap(~id1_names, nrow = 2)+
        xlim(0, 100) + ylim(0, 100) +
        ggtitle("Village land size")+
        labs(y = "village land in w2 (ha)", x = "village land in w1 (ha)", caption = "(Rural EAs, NAs as 0s)")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=1, face="bold"), 
        strip.text.x = element_text(
        size = 8, face = "bold"
        ))
```



```{r, fig.align='center'} 

levels(sell.rights_ea.spreaded$id1_names) <- gsub( "Region", "", levels(sell.rights_ea.spreaded$id1_names))
levels(sell.rights_ea.na0.spreaded$id1_names) <- gsub( "Region", "", levels(sell.rights_ea.na0.spreaded$id1_names))


ggplot(subset(sell.rights_ea.spreaded, urbrur == "Rural")) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = sell.rights_ea.weighted_1, y = sell.rights_ea.weighted_2), color = "red", size = 1, alpha = 2)+
        scale_shape_identity()+
        facet_wrap(~id1_names, nrow = 2)+
        xlim(0, 1) + ylim(0, 1) +
        ggtitle("Selling rights at the village level")+
        labs(y = "sell rights in w2 (% of village land)", x = "sell rights in w1 (% of village land)", caption = "(Rural EAs, Ignoring NAs)")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=10, face="bold"), 
        strip.text.x = element_text(
        size = 8, face = "bold"
        ))


ggplot(subset(sell.rights_ea.na0.spreaded, urbrur == "Rural")) +
        geom_abline(slope=1, intercept=0)+
        geom_point(aes(x = sell.rights_ea.weighted_na0_1, y = sell.rights_ea.weighted_na0_2), color = "red", size = 2, alpha = 2)+
        scale_shape_identity()+
        facet_wrap(~id1_names, nrow = 2)+
        xlim(0, 1) + ylim(0, 1) +
        ggtitle("Selling rights at the village level")+
        labs(y = "sell rights in w2 (% of village land)", x = "sell rights in w1 (% of village land)")+
        theme(
        legend.position = "none",
        plot.title = element_text(hjust = 0.5, size=12, face="bold"),
        strip.text.x = element_text(
        size = 11, face = "bold"
        ))


```

<!-- \newpage  -->
<!-- \section{Townsend Regressions} -->
<!-- \begin{equation} -->
<!--     ihs(c_{h,v,t}) = \alpha +\beta_1\cdot ihs(y_{h,v,t}) + \beta_2\cdot ihs(y_{h,v,t})\cdot sell\text{-}rights_{v,t} + \beta_3\cdot sell\text{-}rights_{v,t} + \beta_4\cdot X_{h,v,t} + \epsilon_{h,v,t} -->
<!--     \label{eq:town} -->
<!-- \end{equation} -->

<!-- \par  -->
<!-- \begin{itemize} -->
<!-- \item $sell\text{-}rights_{v,t}$ has been analysed in the previous section.  -->
<!-- \item $c_{h,v,t}$ is consumption of household $h$ which belongs to village $v$ at period $t$. -->
<!-- \end{itemize} -->
<!-- ################################################################################################################################################################################################################################################## -->
<!-- #####################################################################              CONSUMPTION                 ################################################################################################################################## -->
<!-- ################################################################################################################################################################################################################################################## -->





\newpage
\section{Consumption}
\par 
\subsection{On total consumption} 
Our measure of consumption consists of the following categories: 
\begin{enumerate}
  \item Food Items 
  \item Clothing 
  \item Fuels
  \item Other expenditures
\end{enumerate}
\par 
In the graph below, I aggregate consumption at the village level and we present the percentage contribution of each of the 4 components on total village consumption. Food consumption is the largest bulk of total consumption, however notice that the consumption spending on other
expenditures has a considerable contribution. This component of consumption includes durable gooods such as structures, vehicles etc and we exclude it when computing the non-durable consumption.

```{r Components of total consumption this part is taken from all consumptions, fig.align='center', fig.width= 8, fig.height=5}

#1. Food Consumption
file = "./food_consumption.csv"

# Insert it to the current Rscript.
food_consumption = read.csv(file) %>% 
  # Comment in the three lines below and comment out the 4th, if you want to measure food consumption as the total sum of all 4 counterparts.
  ungroup() %>%
  rowwise() %>%
  mutate(tot_value_food_consumption_annual = (tot_value_purchased + tot_value_received + tot_value_given)*12)
  # select(wave, id1, id2, id3, hhno, tot_value_food_consumption_annual)

#2 Cloth Consumption
file = "./cloth_consumption.csv"

# Insert it to the current Rscript.
cloth_consumption = read.csv(file) %>% 
  select(wave, hhno, tot_cloth_expenses)

#3 Other Consumption
file = "./other_consumption.csv"

# Insert it to the current Rscript.
other_consumption = read.csv(file) %>% 
  select(wave, hhno, tot_other_exp)

#4 Fuel Consumption

file = "./fuel_consumption.csv"

# Insert it to the current Rscript.
fuel_consumption = read.csv(file) %>% 
  select(wave, hhno, tot_fuel_value)

# Merge all consumption categories together:
consumption = full_join(food_consumption, cloth_consumption, by=c("wave", "hhno"))
consumption = full_join(consumption, other_consumption, by = c("wave", "hhno"))
consumption = full_join(consumption, fuel_consumption, by = c("wave", "hhno"))

# replace NAs with 0s
consumption[is.na(consumption)] = 0
consumption = consumption %>%  
              ungroup() %>% 
              mutate(total_consumption = tot_value_food_consumption_annual+tot_cloth_expenses+tot_other_exp+tot_fuel_value) %>% 
              mutate(total_consumption_nd = total_consumption - tot_other_exp)

consumption[consumption<0] = 0 



consumption_long = consumption %>% pivot_longer(cols = contains('tot_'), names_to = 'cons_comp', values_to = "consumption_value") %>% 
                   select(-total_consumption, -total_consumption_nd)


consumption_long.id3 = consumption_long %>%  
                       ungroup() %>%  
                       mutate(consumption_value_infl.adj = case_when(wave ==2 ~ consumption_value*(90.328/150.21), 
                                                                     TRUE ~ consumption_value)) %>% 
                       group_by(wave, id3, cons_comp) %>%  
                       mutate(mean_id3_consumption = mean(consumption_value, na.rm=T)) %>%  
                       mutate(mean_id3_consumption_infl.adj = mean(consumption_value_infl.adj, na.rm=T)) %>%  
                       filter(!duplicated(id3))

# # Adjust consumption in wave 2 for inflation
# ggplot(consumption_long.id3, aes(fill=cons_comp, y=mean_id3_consumption_infl.adj, x=id3)) + 
#     geom_bar(position="stack", stat="identity")+
#     facet_wrap(~wave)+
#     ggtitle('Total consumption breakdown in cedis')+
#     xlab('Villages (id3)')+ylab("mean village consumption (cedis)")+
#     labs(caption = 'Wave 2 prices are adjusted for inflation')+
#     theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
#         plot.caption = element_text(hjust = 1), 
#         axis.text.x=element_text(angle = 0, face="bold"),
#         axis.text.y = element_text(angle = 0, face="bold"))

# Make a percentage stack
# Adjust consumption in wave 2 for inflation
ggplot(consumption_long.id3, aes(fill=cons_comp, y=mean_id3_consumption_infl.adj, x=id3)) + 
    geom_bar(position="fill", stat="identity")+
    facet_wrap(~wave)+
    ggtitle('Break down (%) of mean village total consumption')+
    xlab('Villages (id3)')+ylab("mean village consumption (cedis)")+
    labs(caption = 'Shows the percentage of each component in the mean value of village food consumption')+
    theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
        plot.caption = element_text(hjust = 1), 
        axis.text.x=element_text(angle = 0, face="bold"),
        axis.text.y = element_text(angle = 0, face="bold"))




```





\subsection{on Food Consumption}
\par 
As food consumption constitutes the largest part of total consumption, we zoom in further in the components of it which are the following: 
\begin{itemize}
\item Total value of food consumption purchased. 
\item Total value of food consumption produced. 
\item Total value of food consumption received. 
\item Total value of food consumption given. 
\end{itemize}
\par 
Below we present the percentage contribution of each of the components above in the value of total consumption. Notice that this will be used when we compare the home - produced consumption vs the home - produced production. 

```{r Food Consumption, fig.align='center', fig.width= 8, fig.height=5}
# Before proceeding in manipulating the total value of consumption, I go back to the components of it to analyze them better. 
# In particular, I am interested in food consumption, which corresponds to the largest bulk of it and especially in the part of food consumption, that was home produced. 

# Insert food consumption.csv
food_consumption = read.csv("./food_consumption.csv") 

food_consumption.long = food_consumption %>% pivot_longer(cols = contains('value'), names_to = 'cons_type', values_to = "consumption_value") %>% 
                        filter(cons_type == "tot_value_produced" |cons_type == "tot_value_purchased" | cons_type == "tot_value_received" |cons_type ==     "tot_value_given")

# Now group_by wave and id3 and find the mean value for each type of consumption
food_consumption.long.id3 = food_consumption.long %>%  
                            ungroup() %>% 
                            mutate(consumption_value_infl.adj = case_when(wave==2 ~ consumption_value*(90.328/150.21), 
                                                                          TRUE ~ consumption_value)) %>% 
                            group_by(wave, id3, cons_type) %>%
                            mutate(mean_id3_consumption = mean(consumption_value, na.rm=T)) %>% 
                            mutate(mean_id3_consumption_infl.adj = mean(consumption_value_infl.adj, na.rm=T)) %>% 
                            filter(!duplicated(id3)) %>% 
                            select(-consumption_value)

# ggplot(food_consumption.long.id3, aes(fill=cons_type, y=mean_id3_consumption, x=id3)) + 
#     geom_bar(position="stack", stat="identity")+
#     facet_wrap(~wave)+
#     ggtitle('Food consumption breakdown in cedis')+
#     xlab('Villages (id3)')+ylab("mean village consumption (cedis)")+
#     labs(caption = 'Note that wave 2 prices are not inflation adjusted')+
#     theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
#         plot.caption = element_text(hjust = 1), 
#         axis.text.x=element_text(angle = 0, face="bold"),
#         axis.text.y = element_text(angle = 0, face="bold"))
# 
# # Adjust consumption in wave 2 for inflation
# ggplot(food_consumption.long.id3, aes(fill=cons_type, y=mean_id3_consumption_infl.adj, x=id3)) + 
#     geom_bar(position="stack", stat="identity")+
#     facet_wrap(~wave)+
#     ggtitle('Food consumption breakdown in cedis')+
#     xlab('Villages (id3)')+ylab("mean village consumption (cedis)")+
#     labs(caption = 'Wave 2 prices are adjusted for inflation')+
#     theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
#         plot.caption = element_text(hjust = 1), 
#         axis.text.x=element_text(angle = 0, face="bold"),
#         axis.text.y = element_text(angle = 0, face="bold"))

# Make a percentage stack
# Adjust consumption in wave 2 for inflation
ggplot(food_consumption.long.id3, aes(fill=cons_type, y=mean_id3_consumption_infl.adj, x=id3)) + 
    geom_bar(position="fill", stat="identity")+
    facet_wrap(~wave)+
    ggtitle('Break-down (%) of mean village food consumption')+
    xlab('Villages (id3)')+ylab("mean village consumption (cedis)")+
    labs(caption = 'Shows the percentage of each component in the mean value of village food consumption')+
    theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
        plot.caption = element_text(hjust = 1), 
        axis.text.x=element_text(angle = 0, face="bold"),
        axis.text.y = element_text(angle = 0, face="bold"))



```








```{r Consumption data from the consumption df above}
# add hh size cause you need it to calculate per capita values. 
file = "./hh_size.csv"
hh_size = read.csv(file) %>%group_by(wave, hhno) %>% filter(!duplicated(hhno)) %>% ungroup()




consumption = left_join(consumption, hh_size, by=c("wave", "hhno")) %>% select(wave, id1, id2, id3, hhno, hhsize, hh_weightsize,tot_value_food_consumption_annual, tot_cloth_expenses, tot_other_exp,                            tot_fuel_value, total_consumption, total_consumption_nd)

 

consumption_all = consumption %>% select(-tot_value_food_consumption_annual, -tot_cloth_expenses, -tot_other_exp, -tot_fuel_value) %>% 
                  group_by(wave, id3) %>% 
                  mutate(village_consumption = sum(total_consumption, na.rm=T)) %>%   # these are village level measures
                  mutate(village_consumption_nd = sum(total_consumption_nd, na.rm=T)) %>% 
                  ungroup() %>% 
                  mutate(rest_ea_consumption = village_consumption - total_consumption) %>% 
                  mutate(rest_ea_consumption_nd = village_consumption_nd - total_consumption_nd) %>% 
                  mutate(across(c("total_consumption", "total_consumption_nd"),  # create the deflated consumption
                                list(~ifelse((wave ==2), .*0.6013, .)),
                                .names="{.col}_defl")) %>% 
                  ungroup() %>%
                  mutate(across(contains('consumption'), list(~./hhsize), .names='{.col}_pc')) %>% 
                  ungroup() %>%  
                  mutate(across(contains('consumption'), list(~./hh_weightsize), .names = '{.col}_pc2')) %>% select(-contains('pc_pc2')) %>% 
                  ungroup() %>% 
                  mutate(across(contains('consumption'), list(~log(.)), .names ='log_{.col}')) %>% 
                  mutate(across(contains('consumption'), list(~log(.+(.^2+1)^0.5)), .names = 'ihs_{.col}')) %>% select(-contains('ihs_log')) %>% 
                  group_by(wave) %>% #### Comment it out if you want winsorization across BOTH waves
                  mutate(across(contains("consumption"),                         # create the winsorized levels. 
                                 list(~ DescTools::Winsorize(., probs = c(.025, .975), na.rm = TRUE)),
                                 .names="win_{.col}")) %>% 
                                  ungroup() 
                  
                  

# divide consumption into different df based on 1. levels, 2. pc & pc2, 3. log & ihs 
consumption_levels = consumption_all %>% select(wave, id1, id2, id3, hhno, 
                                                total_consumption,total_consumption_nd,
                                                total_consumption_defl,total_consumption_nd_defl, 
                                                win_total_consumption, win_total_consumption_nd,             
                                                win_total_consumption_defl,win_total_consumption_nd_defl) 

consumption_pc = consumption_all %>% select(wave, id1, id2, id3, hhno, 
                                            total_consumption_pc,total_consumption_nd_pc,
                                            total_consumption_defl_pc,total_consumption_nd_defl_pc,
                                            total_consumption_pc2,total_consumption_nd_pc2,
                                            total_consumption_defl_pc2,total_consumption_nd_defl_pc2,
                                            win_total_consumption_pc,win_total_consumption_nd_pc, 
                                            win_total_consumption_defl_pc, win_total_consumption_nd_defl_pc,
                                            win_total_consumption_pc2, win_total_consumption_nd_pc2,
                                            win_total_consumption_defl_pc2,win_total_consumption_nd_defl_pc2)

consumption_log.ihs = consumption_all %>% select(wave, id1, id2, id3, hhno, 
                                                 log_total_consumption,log_total_consumption_nd,
                                                 log_total_consumption_defl,log_total_consumption_nd_defl,
                                                 log_total_consumption_pc,log_total_consumption_nd_pc,
                                                 log_total_consumption_defl_pc,log_total_consumption_nd_defl_pc,
                                                 log_total_consumption_pc2,log_total_consumption_nd_pc2,
                                                 log_total_consumption_defl_pc2,log_total_consumption_nd_defl_pc2,
                                                 ihs_total_consumption,ihs_total_consumption_nd,
                                                 ihs_total_consumption_defl,ihs_total_consumption_nd_defl,
                                                 ihs_total_consumption_pc,ihs_total_consumption_nd_pc,
                                                 ihs_total_consumption_defl_pc,ihs_total_consumption_nd_defl_pc,
                                                 ihs_total_consumption_pc2,ihs_total_consumption_nd_pc2,
                                                 ihs_total_consumption_defl_pc2,ihs_total_consumption_nd_defl_pc2,
                                                 win_log_total_consumption_pc,win_log_total_consumption_nd_pc,
                                                 win_log_total_consumption_defl_pc, win_log_total_consumption_nd_defl_pc,
                                                 win_log_total_consumption_pc2,win_log_total_consumption_nd_pc2,   
                                                 win_log_total_consumption_defl_pc2, win_log_total_consumption_nd_defl_pc2,
                                                 win_ihs_total_consumption, win_ihs_total_consumption_nd, win_ihs_total_consumption_defl,
                                                 win_ihs_total_consumption_nd_defl, win_ihs_total_consumption_pc,
                                                 win_ihs_total_consumption_nd_pc, win_ihs_total_consumption_defl_pc,
                                                 win_ihs_total_consumption_nd_defl_pc, win_ihs_total_consumption_pc2,
                                                 win_ihs_total_consumption_nd_pc2, win_ihs_total_consumption_defl_pc2,
                                                 win_ihs_total_consumption_nd_defl_pc2)


consumption_ea = consumption_all %>% select(wave, id1, id2, id3, hhno,
                                            contains('village'),
                                            contains('rest_ea')) %>% 
                                     select(-contains('pc'), -contains('pc2'))

```


\subsection{Distribution of consumption}
\par 
On deriving the winsorized data at the 2.5\% level, notice that we do so grouped by wave, and you can see that as the min/max levels of the winsorized data between the two waves are different (in the opposite case, they would be the same, as consumption in both waves would be treated as one distribution). We choose that because (i) much larger value of consumption in wave 2 compared to wave 1, (ii) if we treat both waves as one distribution, we might end up with values at the max consumption in wave 1 which is not there and (iii) this difference is largely attributed to inflation between the two waves, so it would not be correct to treat it as one distribution. 
```{r Descriptive statistics on Consumption}
# total consumption
pander(summary(subset(consumption_levels,wave==1)$total_consumption), caption = "hh consumption in wave 1 (raw data/in cedis)")
pander(summary(subset(consumption_levels,wave==2)$total_consumption), caption = "hh consumption in wave 2 (raw data/in cedis)")

# total non-durable consumption
pander(summary(subset(consumption_levels,wave==1)$total_consumption_nd), caption = "hh non-durable consumption in wave 1 (raw data/in cedis)")
pander(summary(subset(consumption_levels,wave==2)$total_consumption_nd), caption = "hh non-durable consumption in wave 2 (raw data/in cedis)")

# Winsorized total consumption
pander(summary(subset(consumption_levels,wave==1)$win_total_consumption), caption = "hh consumption in wave 1 (winsorized data/in cedis)")
pander(summary(subset(consumption_levels,wave==2)$win_total_consumption), caption = "hh consumption in wave 2 (winsorized data/in cedis)")

# Winsorized total non- durable consumption
pander(summary(subset(consumption_levels,wave==1)$win_total_consumption_nd), caption = "hh non-durable consumption in wave 1 (winsorized data/in cedis)")
pander(summary(subset(consumption_levels,wave==2)$win_total_consumption_nd), caption = "hh non-durable consumption in wave 2 (winsorized data/in cedis)")
```

\par
Notice the difference in the value of consumption between wave 1 and wave 2. The increase in consumption value between the two waves is more than \textcolor{red}{twofold}. This is because of increased level of prices faced in Ghana. According to world bank data, CPI in 2009 was 90.328 points and the CPI in 2014 was 150.21. 
\par 
Hence, we deflate total value of consumption in wave 2 using :
\begin{equation}
consumption_{\text{w:2, in 2009 prices}} = consumption_{w:2} \times \frac{CPI_{2009}}{CPI_{2014}}
\end{equation}

```{r deflated wave 2 descriptive statistics}
pander(summary(subset(consumption_levels, wave==2)$total_consumption_defl), caption = "hh total consumption in wave 2 (deflated/in cedis)")
pander(summary(subset(consumption_levels, wave==2)$total_consumption_nd_defl), caption = "hh non-durable consumption in wave 2 (deflated/in cedis)")
```


<!-- \par -->

<!-- \subsection{Consumption} -->

<!-- ```{r Consumption DATA} -->
<!-- # Insert total consumption data -->
<!-- consumption = read.csv("./Wave 1/R-files/total_consumption.csv") -->

<!-- # hh-specific rest of the village consumption -->
<!-- consumption_ea_hhlvl = consumption %>% select(wave, id1, id2, id3, num_hhs_in.ea, vil_pop, hhno, rest.ea_consumption, rest.ea_consumption_nd, rest.ea_consumption_pc, rest.ea_consumption_nd.pc, rest.ea_consumption_ph, rest.ea_consumption_nd.ph)# This is calculated as the consumption of all other households at the village level - hence it is at the hh level. -->

<!-- # Village level consumption -->
<!-- consumption_ea_villvl = consumption %>% select(wave, id1, id2, id3, ea_consumption, ea_consumption_nd, ea.consumption_pc, ea.consumption_nd.pc, ea.consumption_pc2, ea.consumption_nd.pc2, ea.consumption_ph, ea.consumption_nd.ph, ea.ihs_consumption, ea.ihs_consumption.nd) %>%  group_by(wave, id3) %>% filter(!duplicated(id3))# This is consumption calculated at the village level so it is village specific. -->
<!-- ``` -->



<!-- ```{r Inflation adjusted consumption and nd_consumption} -->
<!-- consumption = consumption %>% mutate(across(c("consumption", "nd_consumption"),  # types of consumption -->
<!--                               list(~ifelse((wave ==2), .*0.6013, .)), -->
<!--                               .names="{.col}_defl")) %>% -->
<!--                               group_by(wave) %>% -->
<!--                               mutate(across(c("consumption_defl", "nd_consumption_defl"),  # types of consumption -->
<!--                               list(~ DescTools::Winsorize(., probs = c(.025, .975), na.rm = TRUE)), -->
<!--                               .names="win_{.col}")) %>% -->
<!--                               ungroup() -->
<!-- ``` -->


<!-- Notice the difference in the value of consumption between wave 1 and wave 2. The increase in consumption value between the two waves is almost \textcolor{red}{threefold}. -->


<!-- ```{r desciptive statistics of consumption - broken into two waves} -->
<!-- consumption.w1 = consumption %>% filter(wave ==1) -->
<!-- consumption.w2 = consumption %>% filter(wave ==2) -->
<!-- # raw consumption summary tables -->
<!-- pander(summary(consumption.w1$consumption), caption = "hh consumption in wave 1 (raw data/in cedis)") -->
<!-- pander(summary(consumption.w2$consumption), caption = "hh consumption in wave 2 (raw data/in cedis)") -->

<!-- # summary tables of winsorized consumption -->
<!-- pander(summary(consumption.w1$win_consumption), caption = "hh consumption (in cedis) in wave 1 (winsorized at 2.5% level)") -->
<!-- pander(summary(consumption.w2$win_consumption), caption = "hh consumption (in cedis) in wave 2 (winsorized at 2.5% level)") -->

<!-- #summary tables of consumption in 2009 prices -->
<!-- pander(summary(consumption.w1$consumption_defl), caption = "hh consumption (in cedis) in wave 1 (in 2009 prices)") -->
<!-- pander(summary(consumption.w2$consumption_defl), caption = "hh consumption (in cedis) in wave 2 (in 2009 prices)") -->

<!-- pander(summary(consumption.w1$win_consumption_defl), caption = "hh consumption (in cedis) in wave 1 (in 2009 prices/winsorized at 2.5% level)") -->
<!-- pander(summary(consumption.w2$win_consumption_defl), caption = "hh consumption (in cedis) in wave 2 (in 2009 prices/winsorized at 2.5% level)") -->
<!-- ``` -->

<!-- ```{r Consumption Graphs - HHlevel} -->
<!-- consumtpion_graph = consumption %>% select(wave, id1,id2,id3,hhno,consumption, nd_consumption, consumption_pc, consumption_pc2, consumption.nd_pc, consumption.nd_pc2, ihs_consumption, ihs_consumption_pc, ihs_consumption_pc2, ihs_consumption.nd, ihs_consumption.nd_pc, ihs_consumption.nd_pc2, win_consumption, win_consumption_pc, win_consumption_pc2, win_consumption.nd, win_consumption.nd_pc2, win_ihs_consumption, win_ihs_consumption_pc, win_ihs_consumption_pc2,win_ihs_consumption.nd, win_ihs_consumption_nd.pc, win_ihs_consumption_nd.pc2) -->

<!-- consumption_graph_den = consumtpion_graph %>% pivot_longer(cols = c(consumption, nd_consumption, consumption_pc, consumption_pc2, consumption.nd_pc, consumption.nd_pc2, ihs_consumption, ihs_consumption_pc, ihs_consumption_pc2, ihs_consumption.nd, ihs_consumption.nd_pc, ihs_consumption.nd_pc2, win_consumption, win_consumption_pc, win_consumption_pc2, win_consumption.nd, win_consumption.nd_pc2, win_ihs_consumption, win_ihs_consumption_pc, win_ihs_consumption_pc2,win_ihs_consumption.nd, win_ihs_consumption_nd.pc, win_ihs_consumption_nd.pc2), names_to = 'consumption_type', values_to = "consumption_value") -->

<!-- consumption_graph_den_lvls = consumption_graph_den %>% filter(consumption_type == "consumption" | consumption_type == "nd_consumption" | consumption_type == "win_consumption" | consumption_type == "win_consumption.nd") -->

<!-- # ggplot(consumption_graph_den_lvls, aes(x=consumption_value, y =consumption_type, group=consumption_type, fill = consumption_type)) + -->
<!-- #   geom_density_ridges()+ -->
<!-- #   stat_density_ridges(quantile_lines = TRUE, quantiles = 2, vline_size = 1, vline_color = "red", alpha=.2)+ -->
<!-- #   facet_wrap(~wave)+ -->
<!-- #   xlim(c(0, 10000))+ -->
<!-- #   ggtitle("Consumption - levels")+ -->
<!-- #   # labs(caption='Source: European Social Survey')+ -->
<!-- #   theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), -->
<!-- #         plot.caption = element_text(hjust = 1), -->
<!-- #         axis.text.x=element_text(angle = 0, face="bold"), -->
<!-- #         axis.text.y = element_text(angle = 0, face="bold"), -->
<!-- #         legend.position = "none") -->

<!-- consumption_graph_den_pc = consumption_graph_den %>% filter(consumption_type == "consumption_pc" | consumption_type == "consumption_pc2" | consumption_type == "consumption.nd_pc" | consumption_type == "consumption.nd_pc2" -->
<!--                                                             | consumption_type == "win_consumption_pc"| consumption_type == "win_consumption_pc2"| consumption_type == "win_consumption.nd_pc"| consumption_type == "win_consumption.nd_pc2") -->

<!-- # ggplot(consumption_graph_den_pc, aes(x=consumption_value, y =consumption_type, group=consumption_type, fill = consumption_type)) + -->
<!-- #   geom_density_ridges()+ -->
<!-- #   stat_density_ridges(quantile_lines = TRUE, quantiles = 2, vline_size = 1, vline_color = "red", alpha=.2)+ -->
<!-- #   facet_wrap(~wave)+ -->
<!-- #   xlim(c(0, 5000))+ -->
<!-- #   ggtitle("Consumption - pc")+ -->
<!-- #   # labs(caption='Source: European Social Survey')+ -->
<!-- #   theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), -->
<!-- #         plot.caption = element_text(hjust = 1), -->
<!-- #         axis.text.x=element_text(angle = 0, face="bold"), -->
<!-- #         axis.text.y = element_text(angle = 0, face="bold"), -->
<!-- #         legend.position = "none") -->

<!-- consumption_graph_den_ihs = consumption_graph_den %>% filter(consumption_type == "ihs_consumption" | consumption_type == "ihs_consumption_pc" | consumption_type == "ihs_consumption_pc2" | consumption_type == "ihs_consumption.nd" -->
<!--                                                             | consumption_type == "ihs_consumption.nd_pc"| consumption_type == "ihs_consumption.nd_pc2"| consumption_type == "win_ihs_consumption"| consumption_type == "win_ihs_consumption_pc" -->
<!--                                                             | consumption_type == "win_ihs_consumption_pc2"| consumption_type == "win_ihs_consumption.nd"| consumption_type == "win_ihs_consumption_nd.pc"| consumption_type == "win_ihs_consumption_nd.pc2") -->


<!-- # ggplot(consumption_graph_den_ihs, aes(x=consumption_value, y =consumption_type, group=consumption_type, fill = consumption_type)) + -->
<!-- #   geom_density_ridges()+ -->
<!-- #   stat_density_ridges(quantile_lines = TRUE, quantiles = 2, vline_size = 1, vline_color = "red", alpha=.2)+ -->
<!-- #   facet_wrap(~wave)+ -->
<!-- #   xlim(c(5, 15))+ -->
<!-- #   ggtitle("Consumption - ihs")+ -->
<!-- #   theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), -->
<!-- #         plot.caption = element_text(hjust = 1), -->
<!-- #         axis.text.x=element_text(angle = 0, face="bold"), -->
<!-- #         axis.text.y = element_text(angle = 0, face="bold"), -->
<!-- #         legend.position = "none") -->

<!-- consumption_graph_restea1 = consumption_ea_hhlvl %>% select(wave, id1, id2, id3, num_hhs_in.ea, vil_pop, hhno,rest.ea_consumption_pc, rest.ea_consumption_nd.pc, rest.ea_consumption_ph, rest.ea_consumption_nd.ph) %>% pivot_longer(cols = c(rest.ea_consumption_pc, rest.ea_consumption_nd.pc, rest.ea_consumption_ph, rest.ea_consumption_nd.ph), names_to = 'consumption_type', values_to = "consumption_value") -->

<!-- consumption_graph_restea2 = consumption_ea_hhlvl %>% select(wave, id1, id2, id3, num_hhs_in.ea, vil_pop, hhno,rest.ea_consumption, rest.ea_consumption_nd) %>% pivot_longer(cols = c(rest.ea_consumption, rest.ea_consumption_nd), names_to = 'consumption_type', values_to = "consumption_value") -->


<!-- #  -->
<!-- # ggplot(consumption_graph_restea1, aes(x=consumption_value, y =consumption_type, group=consumption_type, fill = consumption_type)) + -->
<!-- #   geom_density_ridges()+ -->
<!-- #   stat_density_ridges(quantile_lines = TRUE, quantiles = 2, vline_size = 1, vline_color = "red", alpha=.2)+ -->
<!-- #   facet_wrap(~wave)+ -->
<!-- #   xlim(c(0, 10000))+ -->
<!-- #   ggtitle("Rest of the village consumption (per capita/hh)")+ -->
<!-- #   theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), -->
<!-- #         plot.caption = element_text(hjust = 1), -->
<!-- #         axis.text.x=element_text(angle = 0, face="bold"), -->
<!-- #         axis.text.y = element_text(angle = 0, face="bold"), -->
<!-- #         legend.position = "none") -->
<!-- #  -->
<!-- # ggplot(consumption_graph_restea2, aes(x=consumption_value, y =consumption_type, group=consumption_type, fill = consumption_type)) + -->
<!-- #   geom_density_ridges()+ -->
<!-- #   stat_density_ridges(quantile_lines = TRUE, quantiles = 2, vline_size = 1, vline_color = "red", alpha=.2)+ -->
<!-- #   facet_wrap(~wave)+ -->
<!-- #   xlim(c(0,70000))+ -->
<!-- #   ggtitle("Rest of the village consumption (lvls)")+ -->
<!-- #   theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), -->
<!-- #         plot.caption = element_text(hjust = 1), -->
<!-- #         axis.text.x=element_text(angle = 0, face="bold"), -->
<!-- #         axis.text.y = element_text(angle = 0, face="bold"), -->
<!-- #         legend.position = "none") -->

<!-- ``` -->


<!-- ################################################################################################################################################################################################################################################## -->
<!-- CONSUMPTION ENDS HERE -->
<!-- ################################################################################################################################################################################################################################################## -->


<!-- ################################################################################################################################################################################################################################################## -->
<!-- INCOME  STARTS HERE-->
<!-- ################################################################################################################################################################################################################################################## -->
\newpage
\section{Income}
\par 
<!-- We construct two measures for income.  -->
<!-- \begin{enumerate} -->
<!-- \item Total gross income (all revenues included) -->
<!-- \item Total gross income (excluding financial income) -->
<!-- \end{enumerate} -->
<!-- Both are \textit{gross} but while the former includes all available income sources:  -->
\begin{enumerate}
\item \textbf{Main occupation income}.
\par This labour income source belongs to (Part E: Employment). It is recorded for the past 7 days from the interview date but it also records the number of weeks the respondent held this occupation the past year (q. 7). In order to find the payment i sum q. 10 and q. 13 which report the payment in cedis and the value of any goods/services that were provided as a payment. Then I multiply by the number of weeks that respondent reported and derive the annual income from main occupation. 
\par 
There is no information about the value of taxes deducted from the payment, only whether the payment is gross or net. 
\end{enumerate}


```{r Main occupation income}
##############################################################################################################################################
########################                               Key HH info                ############################################################
##############################################################################################################################################
# This will be used mainly for wave 2 in which certain data sections do not have information other than the hhno (named as FPrimary) while 
# we need id1, id2, id3 in order to perform aggregations at the EA/district/regional/country level in later analysis. 

key_hh_info = read.dta("./key_hhld_info.dta")
key_hh_info = key_hh_info %>% 
  mutate(id1 = as.numeric(id1))

##############################################################################################################################################
########################                               Sources of Income          ############################################################
##############################################################################################################################################


##############################################################################################################################################
########################                           Main Occupation                             ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Main Occupation: 
sec1pE_w1 = read_dta("./S1EI.dta")

mainocc_income_w1 = sec1pE_w1 %>% 
  select(id1, id2, id3, hhno, hhmid, 
         s1ei_7i,                    # Number of weeks during the last year - that held the job
         s1ei_10i, s1ei_10ii,        # Amount that the hhmid received from this job (probably in the last 7 days) in cedis pesewas
         s1ei_13i, s1ei_13ii) %>%    # Amount of good or services that hhmid received from the job. 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s1ei_7i = as.numeric(s1ei_7i)) %>% 
  group_by(hhno, hhmid) %>% 
  mutate(s1ei_10ii = as.numeric(s1ei_10ii*0.01)) %>% 
  mutate(s1ei_13ii = as.numeric(s1ei_13ii*0.01)) %>% 
  ungroup() %>% 
  mutate(mainocc_income_7d = rowSums(select(.,7:10), na.rm = T)) %>% 
  select(id1, id2, id3, hhno, hhmid, s1ei_7i, mainocc_income_7d) %>% 
  group_by(hhno, hhmid) %>% 
  mutate(mainocc_income_annual = case_when(s1ei_7i>52~mainocc_income_7d*52, # here I just set the number of weeks the past year to 52 
                                           TRUE~mainocc_income_7d*s1ei_7i)) %>% # if those are more than 52. 
  group_by(hhno) %>% 
  mutate(mainocc_income_7d = sum(mainocc_income_7d, na.rm = T)) %>% 
  mutate(mainocc_income_annual = sum(mainocc_income_annual, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, mainocc_income_7d, mainocc_income_annual)

# Note that I have derived the mainocc_income_7d and mainocc_income_annual per household - Only 1171 households have income for jobs. 


#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

sec1pE_w2 <- read_dta("./01ei_employmentmain.dta") 

mainocc_income_w2 = sec1pE_w2 %>% 
  select(FPrimary, hhmid, 
         jobweeksperyear,        # Number of weeks during the last year - that held the job
         paidamount,             # Amount that the hhmid received from this job (probably in the last 7 days) in cedis pesewas
         paidothervalue) %>%     # Amount of good or services that hhmid received from the job. 
  mutate(FPrimary = as.numeric(FPrimary)) %>% 
  ungroup() %>% 
  mutate(mainocc_income_7d = rowSums(select(.,4:5), na.rm = T)) %>% 
  select(FPrimary, hhmid, jobweeksperyear, mainocc_income_7d) %>%   
  group_by(FPrimary, hhmid) %>%
  mutate(mainocc_income_annual = case_when(jobweeksperyear>52~mainocc_income_7d*52, # here I just set the number of weeks the past year to 52 
                                           TRUE~mainocc_income_7d*jobweeksperyear)) %>%
  ungroup() %>% 
  group_by(FPrimary) %>% 
  mutate(mainocc_income_7d = sum(mainocc_income_7d, na.rm = T)) %>% 
  mutate(mainocc_income_annual = sum(mainocc_income_annual, na.rm=T)) %>% 
  filter(!duplicated(FPrimary)) %>% 
  mutate(wave=2) %>% 
  select(wave, FPrimary, mainocc_income_7d, mainocc_income_annual)

colnames(mainocc_income_w2)[colnames(mainocc_income_w2)=="FPrimary"]="hhno"  

# Merge it with the key hh info to get the id1, id2, id3, 
mainocc_income_w2 = left_join(mainocc_income_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, mainocc_income_7d, mainocc_income_annual)


mainoccupation_income = rbind(mainocc_income_w1, mainocc_income_w2) %>%  # deflate income in w2
                        mutate(across(contains("income"),  # 7d and annual main occupation income
                              list(~ifelse((wave ==2), .*0.6013, .)),
                              .names="{.col}_defl"))
                        

#write.table(mainoccupation_income,"./mainoccupation_gross_income.csv", sep="," )
```


```{r display distribution of main occupation income deflated}
# deflated measure
pander(summary(subset(mainoccupation_income, wave==1)$mainocc_income_annual_defl), caption = "main occ annual income in w.1 (in cedis)")
pander(summary(subset(mainoccupation_income, wave==2)$mainocc_income_annual_defl), caption = "main occ annual income in w.2 (in 2009 cedis)")
```

\begin{enumerate}
\item[2] \textbf{Secondary occupation income}. (Part E: Employment - same structure as the main occupation income)
\end{enumerate}



```{r Secondary Income}
##############################################################################################################################################
########################                           Secondary Occupation                        ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Secondary Occupation: 
sec1pEsec_w1 = read_dta("./S1EII.dta")

secocc_income_w1 = sec1pEsec_w1 %>% 
  select(id1, id2, id3, hhno, hhmid, 
         s1eii_36i,                    # Number of weeks during the last year - that held the job
         s1eii_41i, s1eii_41ii,        # Amount that the hhmid received from this job (probably in the last 7 days) in cedis pesewas
         s1eii_44i, s1eii_44ii) %>%    # Amount of good or services that hhmid received from the job. 
  mutate(id1 = as.numeric(id1)) %>% 
  group_by(hhno, hhmid) %>% 
  mutate(s1eii_41ii = as.numeric(s1eii_41ii*0.01)) %>% 
  mutate(s1eii_44ii = as.numeric(s1eii_44ii*0.01)) %>%               
  ungroup() %>% 
  mutate(secocc_income_7d = rowSums(select(.,7:10), na.rm = T)) %>% 
  select(id1, id2, id3, hhno, hhmid, s1eii_36i, secocc_income_7d) %>% 
  group_by(hhno, hhmid) %>% 
  mutate(secocc_income_annual = case_when(s1eii_36i>52~secocc_income_7d*52, # here I just set the number of weeks the past year to 52 
                                          TRUE~secocc_income_7d*s1eii_36i)) %>% 
  group_by(hhno) %>% 
  mutate(secocc_income_7d = sum(secocc_income_7d, na.rm = T)) %>% 
  mutate(secocc_income_annual = sum(secocc_income_annual, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, secocc_income_7d, secocc_income_annual)


#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

sec1pEsec_w2 <- read_dta("./01eii_employmentsecondary.dta") 


secocc_income_w2 = sec1pEsec_w2 %>% 
  select(FPrimary, hhmid, 
         jobweeksperyear,        # Number of weeks during the last year - that held the job
         paidamount,             # Amount that the hhmid received from this job (probably in the last 7 days) in cedis pesewas
         paidothervalue) %>%     # Amount of good or services that hhmid received from the job. 
  mutate(FPrimary = as.numeric(FPrimary)) %>% 
  ungroup() %>% 
  mutate(secocc_income_7d = rowSums(select(.,4:5), na.rm = T)) %>% 
  select(FPrimary, hhmid, jobweeksperyear, secocc_income_7d) %>%   
  group_by(FPrimary, hhmid) %>%
  mutate(secocc_income_annual = case_when(jobweeksperyear>52~secocc_income_7d*52, # here I just set the number of weeks the past year to 52 
                                          TRUE~secocc_income_7d*jobweeksperyear)) %>%
  ungroup() %>% 
  group_by(FPrimary) %>% 
  mutate(secocc_income_7d = sum(secocc_income_7d, na.rm = T)) %>% 
  mutate(secocc_income_annual = sum(secocc_income_annual, na.rm=T)) %>% 
  filter(!duplicated(FPrimary)) %>% 
  mutate(wave=2) %>% 
  select(wave, FPrimary, secocc_income_7d, secocc_income_annual)


colnames(secocc_income_w2)[colnames(secocc_income_w2)=="FPrimary"]="hhno"  

# Merge it with the key hh info to get the id1, id2, id3, 
secocc_income_w2 = left_join(secocc_income_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, secocc_income_7d, secocc_income_annual)


secoccupation_income = rbind(secocc_income_w1, secocc_income_w2) %>% 
                       mutate(across(contains("income"),  # 7d and annual main occupation income
                              list(~ifelse((wave ==2), .*0.6013, .)),
                              .names="{.col}_defl"))


#write.table(secoccupation_income, "./secoccupation_gross_income.csv", sep=",")

```


```{r display distribution of sec occupation income deflated}
# deflated measure
pander(summary(subset(secoccupation_income, wave==1)$secocc_income_annual_defl), caption = "sec occ annual income in w.1 (in cedis)")
pander(summary(subset(secoccupation_income, wave==2)$secocc_income_annual_defl), caption = "sec occ annual income in w.2 (in 2009 cedis)")
```

\begin{enumerate}
\item[3] \textbf{Non-farm enterprise income} 
\par 
Belongs to section 5 where q.11 reports which months of the past year the bussiness was operating. q.12 reports whether business income belongs entirely to the household and if not then reports what percent of it flows to the hh (q.13). Then q.23 classifies each month as an High, Average, Low sales month and then q.24,25,26 report the average sales in each classification also q. 27,28,29 reports the respective bussiness costs for each classification (so the it is the \underline{net income} recorded). Notice that there are household businesses that make losses. 
\end{enumerate}

```{r Non Farm Enterprize income}
##############################################################################################################################################
########################                           Non-Farm Enterprise                         ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Non-Farm Enterprise: 
sec5pA_w1 = read_dta("./S5AI.dta")

nonfarm_enterprise_w1 = sec5pA_w1 %>% 
  select(id1, id2, id3, hhno, entno, 
         s5a_11,                                                           # Number of months in operation the past year. 
         s5a_12, s5a_13,                                                   # Does the income belong entirely to the hh? if no what percent?   
         s5a_23i,s5a_23ii, s5a_23iii,s5a_23iv,s5a_23v, s5a_23vi,           # Month as A-verage, H-igh or L-ow
         s5a_23vii, s5a_23viii, s5a_23ix, s5a_23x,s5a_23xi, s5a_23xii,
         s5a_24i, s5a_24ii, s5a_25i, s5a_25ii, s5a_26i, s5a_26ii,          # Average sales in Avenrage, High, Low month  
         s5a_27i, s5a_27ii, s5a_28i, s5a_28ii, s5a_29i, s5a_29ii) %>%      # Average cost in Average, High, Low month
  mutate(id1=as.numeric(id1)) %>% 
  mutate(s5a_12 = as.numeric(s5a_12))

# First find the total sales: 
nonfarm_enterprise_w1 = nonfarm_enterprise_w1 %>% 
  group_by(hhno, entno) %>% 
  mutate(s5a_24ii = s5a_24ii*0.01) %>% 
  mutate(s5a_25ii = s5a_25ii*0.01) %>% 
  mutate(s5a_26ii = s5a_26ii*0.01) %>% 
  mutate(s5a_27ii = s5a_27ii*0.01) %>% 
  mutate(s5a_28ii = s5a_28ii*0.01) %>% 
  mutate(s5a_29ii = s5a_29ii*0.01) %>% 
  ungroup() %>% 
  mutate(sales_H = rowSums(select(.,21:22), na.rm = T)) %>% 
  mutate(sales_A = rowSums(select(.,23:24), na.rm = T)) %>%  
  mutate(sales_L = rowSums(select(.,25:26), na.rm = T)) %>% 
  mutate(costs_H = rowSums(select(.,27:28), na.rm = T)) %>% 
  mutate(costs_A = rowSums(select(.,29:30), na.rm = T)) %>% 
  mutate(costs_L = rowSums(select(.,31:32), na.rm = T)) %>%  
  select(-s5a_24i, -s5a_24ii, -s5a_25i, -s5a_25ii, -s5a_26i, -s5a_26ii,          # Average sales in Average, High, Low month  
         -s5a_27i, -s5a_27ii, -s5a_28i, -s5a_28ii, -s5a_29i, -s5a_29ii) %>% 
  mutate(costs_H = -costs_H) %>% 
  mutate(costs_A = -costs_A) %>% 
  mutate(costs_L = -costs_L) %>%  
  mutate(profits_H = rowSums(select(.,c(21,24)),na.rm = T)) %>% 
  mutate(profits_A = rowSums(select(.,c(22,25)), na.rm = T)) %>% 
  mutate(profits_L = rowSums(select(.,c(23,26)), na.rm = T)) %>% 
  select(-sales_L, -sales_A, -sales_H, -costs_L, -costs_A, -costs_H) %>% 
  mutate(s5a_23i = case_when(s5a_23i=="H"~as.character(profits_H), 
                             s5a_23i=="A"~as.character(profits_A), 
                             s5a_23i=="L"~as.character(profits_L), 
                             TRUE~"NA")) %>%
  mutate(s5a_23i = as.numeric(s5a_23i)) %>% 
  mutate(s5a_23ii = case_when(s5a_23ii=="H"~as.character(profits_H), 
                              s5a_23ii=="A"~as.character(profits_A), 
                              s5a_23ii=="L"~as.character(profits_L), 
                              TRUE~"NA")) %>%
  mutate(s5a_23ii = as.numeric(s5a_23ii)) %>%  
  mutate(s5a_23iii = case_when(s5a_23iii=="H"~as.character(profits_H), 
                               s5a_23iii=="A"~as.character(profits_A), 
                               s5a_23iii=="L"~as.character(profits_L), 
                               TRUE~"NA")) %>%
  mutate(s5a_23iii = as.numeric(s5a_23iii)) %>%  
  mutate(s5a_23iv = case_when(s5a_23iv=="H"~as.character(profits_H), 
                              s5a_23iv=="A"~as.character(profits_A), 
                              s5a_23iv=="L"~as.character(profits_L), 
                              TRUE~"NA")) %>%
  mutate(s5a_23iv = as.numeric(s5a_23iv)) %>% 
  mutate(s5a_23v = case_when(s5a_23v=="H"~as.character(profits_H), 
                             s5a_23v=="A"~as.character(profits_A), 
                             s5a_23v=="L"~as.character(profits_L), 
                             TRUE~"NA")) %>%
  mutate(s5a_23v = as.numeric(s5a_23v)) %>%  
  mutate(s5a_23vi = case_when(s5a_23vi=="H"~as.character(profits_H), 
                              s5a_23vi=="A"~as.character(profits_A), 
                              s5a_23vi=="L"~as.character(profits_L), 
                              TRUE~"NA")) %>%
  mutate(s5a_23vi = as.numeric(s5a_23vi)) %>% 
  mutate(s5a_23vii = case_when(s5a_23vii=="H"~as.character(profits_H), 
                               s5a_23vii=="A"~as.character(profits_A), 
                               s5a_23vii=="L"~as.character(profits_L), 
                               TRUE~"NA")) %>%
  mutate(s5a_23vii = as.numeric(s5a_23vii)) %>% 
  mutate(s5a_23viii = case_when(s5a_23viii=="H"~as.character(profits_H), 
                                s5a_23viii=="A"~as.character(profits_A), 
                                s5a_23viii=="L"~as.character(profits_L), 
                                TRUE~"NA")) %>%
  mutate(s5a_23viii = as.numeric(s5a_23viii)) %>%
  mutate(s5a_23ix = case_when(s5a_23ix=="H"~as.character(profits_H), 
                              s5a_23ix=="A"~as.character(profits_A), 
                              s5a_23ix=="L"~as.character(profits_L), 
                              TRUE~"NA")) %>%
  mutate(s5a_23ix = as.numeric(s5a_23ix)) %>% 
  mutate(s5a_23x = case_when(s5a_23x=="H"~as.character(profits_H), 
                             s5a_23x=="A"~as.character(profits_A), 
                             s5a_23x=="L"~as.character(profits_L), 
                             TRUE~"NA")) %>%
  mutate(s5a_23x = as.numeric(s5a_23x)) %>%  
  mutate(s5a_23xi = case_when(s5a_23xi=="H"~as.character(profits_H), 
                              s5a_23xi=="A"~as.character(profits_A), 
                              s5a_23xi=="L"~as.character(profits_L), 
                              TRUE~"NA")) %>%
  mutate(s5a_23xi = as.numeric(s5a_23xi)) %>%
  mutate(s5a_23xii = case_when(s5a_23xii=="H"~as.character(profits_H), 
                               s5a_23xii=="A"~as.character(profits_A), 
                               s5a_23xii=="L"~as.character(profits_L), 
                               TRUE~"NA")) %>%
  mutate(s5a_23xii = as.numeric(s5a_23xii)) %>%
  ungroup() %>% 
  mutate(profits_annual =rowSums(select(.,9:20), na.rm = T))%>%  
  select(-s5a_23i,-s5a_23ii,-s5a_23iii,-s5a_23iv,-s5a_23v,-s5a_23vi,           
         -s5a_23vii,-s5a_23viii,-s5a_23ix,-s5a_23x,-s5a_23xi,-s5a_23xii,
         -profits_L, -profits_A, -profits_H) %>%  
  group_by(hhno, entno) %>% 
  mutate(profits_annual_percenthh = case_when(s5a_12==1~1*profits_annual, 
                                              s5a_12==2~s5a_13*0.01*profits_annual, 
                                              TRUE~as.numeric(NA))) %>% 
  group_by(hhno) %>% 
  mutate(profits_annual_final = sum(profits_annual_percenthh, na.rm = T)) %>% 
  mutate(wave=1) %>% 
  ungroup() %>% 
  filter(!duplicated(hhno)) %>% 
  select(wave, id1, id2, id3, hhno, profits_annual_final)



colnames(nonfarm_enterprise_w1)[colnames(nonfarm_enterprise_w1)=="profits_annual_final"]="profits_annual"  


#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

# Non-Farm Enterprise:  
sec5pA_w2 <- read_dta("./05ai_basicinfo.dta") 

nonfarm_enterprise_w2 = sec5pA_w2 %>% 
  select(FPrimary, InstanceNumber,
         incomealltohouse, percenttohousehold, 
         jansales, febsales, marsales, aprsales, maysales, junsales, julsales, augsales, 
         sepsales, octsales, novsales, decsales,
         averagesaleshigh, averagesalesaverage, averagesaleslow, 
         averagecostshigh, averagecostsaverage, averagecostslow, 
         valueconsumed, valuegifted) %>% 
  mutate(jansales = as.numeric(jansales)) %>% 
  mutate(febsales = as.numeric(febsales)) %>% 
  mutate(marsales = as.numeric(marsales)) %>% 
  mutate(aprsales = as.numeric(aprsales)) %>% 
  mutate(maysales = as.numeric(maysales)) %>% 
  mutate(junsales = as.numeric(junsales)) %>% 
  mutate(julsales = as.numeric(julsales)) %>% 
  mutate(augsales = as.numeric(augsales)) %>% 
  mutate(sepsales = as.numeric(sepsales)) %>% 
  mutate(octsales = as.numeric(octsales)) %>% 
  mutate(novsales = as.numeric(novsales)) %>% 
  mutate(decsales = as.numeric(decsales)) %>% 
  group_by(FPrimary, InstanceNumber) %>% 
  mutate(profits_H = averagesaleshigh - averagecostshigh) %>% 
  mutate(profits_A = averagesalesaverage - averagecostsaverage) %>% 
  mutate(profits_L = averagesaleslow - averagecostslow) %>% 
  select(-averagesaleshigh,-averagesalesaverage,-averagesaleslow, 
         -averagecostshigh,-averagecostsaverage,-averagecostslow) %>% 
  mutate(jansales = case_when(jansales ==0~0, 
                              jansales ==1~profits_L, 
                              jansales ==3~profits_A, 
                              jansales ==5~profits_H, 
                              TRUE~jansales)) %>% 
  mutate(febsales = case_when(febsales ==0~0, 
                              febsales ==1~profits_L, 
                              febsales ==3~profits_A, 
                              febsales ==5~profits_H, 
                              TRUE~febsales)) %>% 
  mutate(marsales = case_when(marsales ==0~0, 
                              marsales ==1~profits_L, 
                              marsales ==3~profits_A, 
                              marsales ==5~profits_H, 
                              TRUE~marsales)) %>% 
  mutate(aprsales = case_when(aprsales ==0~0, 
                              aprsales ==1~profits_L, 
                              aprsales ==3~profits_A, 
                              aprsales ==5~profits_H, 
                              TRUE~aprsales)) %>% 
  mutate(maysales = case_when(maysales ==0~0, 
                              maysales ==1~profits_L, 
                              maysales ==3~profits_A, 
                              maysales ==5~profits_H, 
                              TRUE~maysales)) %>% 
  mutate(junsales = case_when(junsales ==0~0, 
                              junsales ==1~profits_L, 
                              junsales ==3~profits_A, 
                              junsales ==5~profits_H, 
                              TRUE~junsales)) %>% 
  mutate(julsales = case_when(jansales ==0~0, 
                              julsales ==1~profits_L, 
                              julsales ==3~profits_A, 
                              julsales ==5~profits_H, 
                              TRUE~julsales)) %>% 
  mutate(augsales = case_when(augsales ==0~0, 
                              augsales ==1~profits_L, 
                              augsales ==3~profits_A, 
                              augsales ==5~profits_H, 
                              TRUE~augsales)) %>% 
  mutate(sepsales = case_when(sepsales ==0~0, 
                              sepsales ==1~profits_L, 
                              sepsales ==3~profits_A, 
                              sepsales ==5~profits_H, 
                              TRUE~sepsales)) %>% 
  mutate(octsales = case_when(octsales ==0~0, 
                              octsales ==1~profits_L, 
                              octsales ==3~profits_A, 
                              octsales ==5~profits_H, 
                              TRUE~octsales)) %>% 
  mutate(novsales = case_when(novsales ==0~0, 
                              novsales ==1~profits_L, 
                              novsales ==3~profits_A, 
                              novsales ==5~profits_H, 
                              TRUE~novsales)) %>% 
  mutate(decsales = case_when(decsales ==0~0, 
                              decsales ==1~profits_L, 
                              decsales ==3~profits_A, 
                              decsales ==5~profits_H, 
                              TRUE~decsales)) %>% 
  select(-profits_A, -profits_L, -profits_H) %>% 
  ungroup() %>% 
  mutate(profits_annual = rowSums(select(.,5:16), na.rm = T)) %>% 
  # mutate(valueconsumed = -valueconsumed) %>% 
  # mutate(valuegifted = -valuegifted) %>% 
  mutate(profits_annual_final = profits_annual) %>% 
  select(FPrimary, InstanceNumber, incomealltohouse, percenttohousehold,profits_annual_final) %>% 
  group_by(FPrimary, InstanceNumber) %>% 
  mutate(profits_annual_final = case_when(incomealltohouse == 1 ~ profits_annual_final,
                                          incomealltohouse == 5 ~ profits_annual_final*percenttohousehold*0.01,
                                          TRUE~profits_annual_final)) %>% 
  group_by(FPrimary) %>% 
  mutate(profits_annual_final = sum(profits_annual_final, na.rm = T)) %>% 
  filter(!duplicated(FPrimary)) %>%  
  mutate(wave=2) %>%
  ungroup() %>% 
  mutate(FPrimary = as.numeric(FPrimary)) %>% 
  select(wave, FPrimary, profits_annual_final)


colnames(nonfarm_enterprise_w2)[colnames(nonfarm_enterprise_w2)=="profits_annual_final"]="profits_annual"  
colnames(nonfarm_enterprise_w2)[colnames(nonfarm_enterprise_w2)=="FPrimary"]="hhno"  

# Merge it with key hh info to get the id1, id2, id3

nonfarm_enterprise_w2 = left_join(nonfarm_enterprise_w2,  key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, profits_annual)

# Merge by rows the two waves 
nonfarm_enterprise = rbind(nonfarm_enterprise_w1, nonfarm_enterprise_w2) %>% 
                      mutate(across(contains("profits"),  #annual
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl"))


#write.table(nonfarm_enterprise, "./nonfarm_enterprise_gross_income.csv",sep=",")

```


```{r display distribution of bussiness profits deflated}
# deflated measure
pander(summary(subset(nonfarm_enterprise, wave==1)$profits_annual_defl), caption = "business annual profits in w.1 (in cedis)")
pander(summary(subset(nonfarm_enterprise, wave==2)$profits_annual_defl), caption = "business annual profits in w.2 (in 2009 cedis)")
```

\begin{enumerate}
\item[4] \textbf{Animal income}
\par 
It is part of the 'Household assets' section. It records the number of animals per kind of animal and the expenses to maintain it and the revenues. So by subtracting costs of maintanance from the revenues we compute the net animal income.  
\end{enumerate}





```{r Household Assets - Animal Income}
##############################################################################################################################################
########################                          Household Assets                             ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Farm Assets
# Animals: 
sec3pA_w1 = read_dta("./S3AI.dta") %>% mutate(num_anim = s3ai_1)

animalinc_w1 = sec3pA_w1 %>% filter(num_anim>0) %>% 
  select(id1, id2, id3, hhno, animal_id, num_anim,
         s3ai_5i, s3ai_5ii, 
         s3ai_6i, s3ai_6ii,
         s3ai_7i, s3ai_7ii, 
         s3ai_8i, s3ai_8ii, 
         s3ai_9i, s3ai_9ii,
         s3ai_10i, s3ai_10ii, 
         s3ai_11i, s3ai_11ii, 
         s3ai_12i, s3ai_12ii) %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(id2 = as.numeric(id2)) %>% 
  mutate(animal_id = as.numeric(animal_id)) %>% 
  mutate(across(contains('ii'), ~.*0.01, .names='{.col}_pes-ced')) %>% 
  select(-s3ai_5ii,-s3ai_6ii, -s3ai_7ii, -s3ai_8ii,-s3ai_9ii, -s3ai_10ii, -s3ai_11ii, -s3ai_12ii) %>% 
  mutate(across(contains("s3ai"), ~.*(-1))) %>% 
  mutate(across(c("s3ai_12i", "s3ai_12ii_pes-ced"), ~.*(-1))) %>% 
  ungroup() %>% 
  mutate(anim_income = rowSums(select(.,6:22), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(anim_income = sum(anim_income, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave = 1) %>% 
  select(wave, id1, id2, id3, hhno, anim_income)



#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

sec3pA_w2 = read_dta("./03ai_animalquestions.dta") 

animalinc_w2 = sec3pA_w2 %>% filter(quantity>0) %>% select(-contains("ownersask"), -currentvalue, -maintain, -xmoreanimals) %>% 
  mutate(FPrimary = as.numeric(FPrimary)) %>%  
  mutate(across(c(contains('feed'),contains('expenses')), ~.*(-1))) %>% 
  mutate(anim_income = rowSums(select(.,5:13), na.rm = T)) %>% 
  group_by(FPrimary) %>%  
  mutate(anim_income = sum(anim_income, na.rm = T)) %>% 
  filter(!duplicated(FPrimary)) %>% 
  mutate(wave=2) %>% 
  ungroup() %>% 
  select(wave, FPrimary, anim_income)
    
    
colnames(animalinc_w2)[colnames(animalinc_w2)=="FPrimary"]="hhno"  

# Merge it with the key hh info to get id1, id2, id3:

animalinc_w2 = left_join(animalinc_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, anim_income)


# Merge the two waves by row:
animal_income = rbind(data.frame(animalinc_w1), data.frame(animalinc_w2)) %>% 
                      mutate(across(contains("income"),  #annual
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl"))


#write.table(animal_income, "./animal_gross_income.csv", sep=",")

```


```{r display distribution of animal income profits deflated}
# deflated measure
pander(summary(subset(animal_income, wave==1)$anim_income_defl), caption = "animal annual net income in w.1 (in cedis)")
pander(summary(subset(animal_income, wave==2)$anim_income_defl), caption = "animal annual net income in w.2 (in 2009 cedis)")
```

\begin{enumerate}
\item[5] \textbf{Financial income} 
\par 
It also belongs to the 'Household assets'. It records (i) Borrowing, (ii) Lending, (iii) In transfers, (iv) out transfers and (v) Savings. To compute the net financial income we derive the net credit (lending-borrowing) + the net transfers (in - out transfers) + savings. For this case we also compute the gross fin income (lending + in-transfers + savings). 
\end{enumerate}

```{r Financial Assets}
##############################################################################################################################################
########################                         Financial Assets                              ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Financial Assets 
# Borrowing:
sec3pB_bor_w1 = read_dta("./S3BI.dta")
# Lending
sec3pB_lend_w1 = read_dta("./S3BII.dta")
# Out-transfers
sec3pB_outtr_w1 = read_dta("./S3BIII.dta")
# In-transfers
sec3pB_intr_w1 = read_dta("./S3BIV.dta")
# Savings 
sec3pB_sav_w1 = read_dta("./S3BV.dta")


borrowing_w1 = sec3pB_bor_w1 %>% 
  select(id1, id2, id3, hhno, debt_no,
         s3bi_12i, s3bi_12ii) %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s3bi_12ii = s3bi_12ii*0.01) %>% 
  mutate(debt = rowSums(select(.,6:7), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(debt = sum(debt, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, debt)

lending_w1 = sec3pB_lend_w1 %>% 
  select(id1, id2, id3, hhno, credit_no, 
         s3bii_23i, s3bii_23ii) %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s3bii_23ii = s3bii_23ii*0.01) %>% 
  mutate(credit = rowSums(select(.,6:7), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(credit = sum(credit, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, credit)


outrans_w1 = sec3pB_outtr_w1 %>% 
  select(id1, id2, id3, hhno, otrans_no, 
         s3biii_34i, s3biii_34ii)%>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s3biii_34ii = s3biii_34ii*0.01) %>% 
  mutate(outtr = rowSums(select(.,6:7), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(outtr = sum(outtr, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, outtr)

intrans_w1 = sec3pB_intr_w1 %>% 
  select(id1, id2, id3, hhno, itrans_no, 
         s3biv_46i, s3biv_46ii)%>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s3biv_46ii = s3biv_46ii*0.01) %>% 
  mutate(intr = rowSums(select(.,6:7), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(intr = sum(intr, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, intr)

savings_w1 = sec3pB_sav_w1 %>%  
  select(id1, id2, id3, id4, hhno, 
         s3bv_53i, s3bv_53ii,
         s3bv_56i, s3bv_56ii) %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s3bv_53ii = s3bv_53ii*0.01) %>% 
  mutate(s3bv_56ii = s3bv_56ii*0.01) %>%
  mutate(home_sav = rowSums(select(.,6:7), na.rm = T)) %>% 
  mutate(bank_sav = rowSums(select(.,8:9), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(home_sav = sum(home_sav, na.rm = T)) %>% 
  mutate(bank_sav = sum(bank_sav, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, home_sav, bank_sav) %>% 
  ungroup() %>% 
  mutate(total_savings = rowSums(select(.,5:6), na.rm = T)) %>% 
  mutate(total_savings = ifelse(total_savings==-8, 0, as.numeric(total_savings)))


finincome_w1 = full_join(borrowing_w1, lending_w1[,c("hhno", "credit")], by="hhno")
finincome_w1 = full_join(finincome_w1, outrans_w1[,c("hhno", "outtr")], by="hhno")
finincome_w1 = full_join(finincome_w1, intrans_w1[,c("hhno", "intr")], by="hhno") 
finincome_w1 = full_join(finincome_w1, savings_w1[,c("hhno", "total_savings")], by="hhno") %>% 
  ungroup() %>% 
  mutate(outtr = outtr*(-1)) %>%
  mutate(debt = debt*(-1)) %>% 
  mutate(net_finincome = rowSums(select(.,5:9), na.rm = T)) %>% 
  mutate(gross_finincome = rowSums(select(.,6,8:9), na.rm=T) ) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, debt, credit, outtr, intr, total_savings, net_finincome, gross_finincome)


#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

# Financial Assets 
# Borrowing:
sec3pB_bor_w2 =  read_dta("./03bi_borrowingquestions.dta")
# Lending
sec3pB_lend_w2 = read_dta("./03bii_lendingquestions.dta")
# Out-transfers
sec3pB_outtr_w2 = read_dta("./03biii_outtransfersquestions.dta")
# In-transfers
sec3pB_intr_w2 = read_dta("./03biv_intransfersquestions.dta")
# Savings
sec3pB_sav_w2 = read_dta("./03bv_savingquestions.dta")






borrowing_w2 = sec3pB_bor_w2 %>% 
  select(FPrimary,  
         borrowpaidbackyear) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  group_by(hhno) %>% 
  mutate(debt = sum(borrowpaidbackyear, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(hhno, debt)


lending_w2 = sec3pB_lend_w2 %>% 
  select(FPrimary,
         loanpaidback) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  group_by(hhno) %>% 
  mutate(credit = sum(loanpaidback, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(hhno, credit)

outrans_w2 = sec3pB_outtr_w2 %>% 
  select(FPrimary,
         outcash, outfood, outgoods)%>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  mutate(outtr = rowSums(select(.,2:4), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(outtr = sum(outtr, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(hhno, outtr)


intrans_w2 = sec3pB_intr_w2 %>% 
  select(FPrimary,
         incash, infood, ingoods)%>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  mutate(intr = rowSums(select(.,2:4), na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(intr = sum(intr, na.rm=T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(hhno, intr)

savings_w2 = sec3pB_sav_w2 %>% 
  select(FPrimary, 
         savingsathomeamount, savingsbalance) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  mutate(tot_sav = rowSums(select(.,2:3), na.rm=T)) %>% 
  group_by(hhno) %>% 
  mutate(total_savings = sum(tot_sav, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(hhno, total_savings)


finincome_w2 = full_join(borrowing_w2, lending_w2[,c("hhno", "credit")], by="hhno")
finincome_w2 = full_join(finincome_w2, outrans_w2[,c("hhno", "outtr")], by="hhno")
finincome_w2 = full_join(finincome_w2, intrans_w2[,c("hhno", "intr")], by="hhno")
finincome_w2 = full_join(finincome_w2, savings_w2[,c("hhno", "total_savings")], by="hhno") %>% 
  ungroup() %>% 
  mutate(outtr = -outtr) %>% 
  mutate(debt = -debt) %>% 
  mutate(net_finincome = rowSums(select(.,2:6), na.rm = T)) %>% 
  mutate(gross_finincome = rowSums(select(.,3,5:6), na.rm=T) ) %>% 
  mutate(wave=2)


# %>% 
  # select(wave, hhno, net_finincome)

# summary(finincome_w2$net_finincome)


# Merge it with the key hh info to get the id1, id2, id3, 
finincome_w2 = left_join(finincome_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
    select(wave, id1, id2, id3, hhno, debt, credit, outtr, intr, total_savings, net_finincome, gross_finincome)

aux = finincome_w2 %>% filter(!duplicated(id3))


# Merge the two waves by row:
financial_income0= rbind(data.frame(finincome_w1), data.frame(finincome_w2))

financial_income = financial_income0 %>% 
                   mutate(across(contains("finincome"),  #annual
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) %>% 
                    select(wave, id1, id2, id3, hhno, net_finincome, gross_finincome, 
                           net_finincome_defl, gross_finincome_defl)
                   

#write.table(financial_income, "./financial_gross_income.csv",sep="," )


```

\par 
To sum up, the net financial income for each hh has been calculated as: 
\begin{equation}
net.fin.income_{w,h} = (lending_{w,h} - borrowing_{w,h}) + (in.transfers_{w,h} - out.transfers_{w,h}) + savings_{w,h}
\end{equation}
and the gross fin income:
\begin{equation}
gross.fin.income_{w,h} = (lending_{w,h} + in.transfers_{w,h}  + savings_{w,h}
\end{equation}

```{r display distribution of financal income profits deflated}
# deflated measure - net fin income
pander(summary(subset(financial_income, wave==1)$net_finincome_defl), caption = "net fin annual income in w.1 (in cedis)")
pander(summary(subset(financial_income, wave==2)$net_finincome_defl), caption = "net fin annual income in w.2 (in 2009 cedis)")

# deflated measure - gross fin income
pander(summary(subset(financial_income, wave==1)$gross_finincome_defl), caption = "gross fin annual income in w.1 (in cedis)")
pander(summary(subset(financial_income, wave==2)$gross_finincome_defl), caption = "gross fin annual income in w.2 (in 2009 cedis)")

```


\par 
As we can see below there is no clear pattern across villages regarding the contribution of each component of the absolute value of financial assets. Here we have taken the absolute value of the components in the legend and we check their contribution to the village mean total value of finaincial assets. 

```{r Finincome by village, fig.align='center', fig.width= 8, fig.height=5}
finincome.id3 = financial_income0 %>% ungroup() %>% 
  mutate(across(c("outtr", "debt"), ~.*(-1))) %>% 
  group_by(wave, id3) %>% 
  mutate((across(c("debt", "credit", "outtr", "intr", "total_savings" ), ~mean(.,na.rm=T), .names = '{.col}_id3.mean'))) %>% 
  filter(!duplicated(id3)) %>% 
    select(wave, id1, id2, id3, contains('mean')) 


finincome.id3[is.na(finincome.id3)] =0

finincome.id3.long = finincome.id3 %>% pivot_longer(cols = contains('mean'), names_to = 'fin_comp', values_to = "fin_asset_value")


ggplot(finincome.id3.long, aes(fill=fin_comp, y=fin_asset_value, x=id3)) + 
    geom_bar(position="fill", stat="identity")+
    facet_wrap(~wave)+
    ggtitle('Break-down (%)of mean village financial value')+
    xlab('Villages (id3)')+ylab("mean village consumption (cedis)")+
    labs(caption = 'Shows the percentage of each component in the mean value of village finanical asset value')+
    theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
        plot.caption = element_text(hjust = 1), 
        axis.text.x=element_text(angle = 0, face="bold"),
        axis.text.y = element_text(angle = 0, face="bold"))
```


\begin{enumerate}
\item[6] \textbf{Land rent income} 
\par 
This source belongs to section 4: Agricultural Production Part A:Land information, iv: Investment Ownership and Rental status. In this question we record both rent ins and rent outs. It is negligible less than 10 people report non zero income from land rents and also there is an inconsistency in the questions asked for land rents. In particular, the survey is not clear on the rent that was received/given the past year. 
\end{enumerate}




```{r Land Rents}
##############################################################################################################################################
########################                          Land Rents                                   ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Section 4 - IV: Investment Ownership Rentals
sec4pA_w1 = read_dta("./S4AIV.dta")

landrent_income_w1 = sec4pA_w1 %>% 
  select(id1, id2, id3, hhno, s4aiv_plotno, 
         s4aiv_a52i, s4aiv_a52ii, 
         s4aiv_a74i, s4aiv_a74ii) %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(plot_id = as.numeric(paste(hhno,s4aiv_plotno, sep=""))) %>% 
  select(id1, id2, id3, hhno, plot_id, s4aiv_a52i, s4aiv_a52ii, s4aiv_a74i, s4aiv_a74ii) %>% 
  mutate(s4aiv_a52ii = s4aiv_a52ii*0.01) %>% 
  mutate(s4aiv_a74ii = s4aiv_a74ii*0.01) %>% 
  ungroup() %>% 
  mutate(landrent_expenses = -rowSums(select(.,6:7), na.rm = F)) %>% 
  mutate(landrent_revenues = rowSums(select(.,8:9), na.rm = F)) %>% 
  group_by(hhno) %>% 
  mutate(landrent_expenses_hh = sum(landrent_expenses, na.rm = T)) %>% 
  mutate(landrent_expenses_hh = ifelse(landrent_expenses==0, as.numeric(NA), landrent_expenses_hh)) %>% 
  mutate(landrent_revenues_hh = sum(landrent_revenues, na.rm = T)) %>% 
  mutate(landrent_revenues_hh = ifelse(landrent_revenues==0, as.numeric(NA), landrent_revenues_hh)) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, landrent_expenses_hh, landrent_revenues_hh) %>% 
  ungroup() %>% 
  mutate(landrent_netincome = landrent_revenues_hh) %>% 
  mutate(landrent_netincome = ifelse(landrent_netincome==0, as.numeric(NA), landrent_netincome)) %>% 
  select(wave, id1, id2, id3, hhno, landrent_netincome)

#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

sec4pA_w2 = read_dta("./04i_landtenure.dta") 

landrent_income_w2 = sec4pA_w2 %>% 
  select(FPrimary, plotid, 
         rentcashannualvalue, 
         otherrent) %>%
  mutate(FPrimary = as.numeric(FPrimary)) %>% 
  mutate(landrent_expenses = - rentcashannualvalue) %>% 
  mutate(landrent_revenues = otherrent) %>% 
  select(-rentcashannualvalue, -otherrent) %>% 
  group_by(FPrimary) %>% 
  mutate(landrent_expenses = sum(landrent_expenses, na.rm = T)) %>% 
  mutate(landrent_revenues = sum(landrent_revenues, na.rm = T)) %>% 
  filter(!duplicated(FPrimary)) %>% 
  mutate(landrent_expenses =ifelse(landrent_expenses==0, as.numeric(NA), landrent_expenses)) %>% 
  mutate(landrent_revenues =ifelse(landrent_revenues==0, as.numeric(NA), landrent_revenues)) %>% 
  ungroup() %>% 
  mutate(landrent_netincome = landrent_revenues) %>% 
  mutate(landrent_netincome =ifelse(landrent_netincome==0, as.numeric(NA), landrent_netincome)) %>% 
  mutate(wave=2) %>% 
  select(wave, FPrimary, landrent_netincome)



colnames(landrent_income_w2)[colnames(landrent_income_w2)=="FPrimary"]="hhno"  

# Merge it with the key hh info to get the id1, id2, id3, 
landrent_income_w2 = left_join(landrent_income_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, landrent_netincome)


# Merge the two waves by row:
landrent_income= rbind(landrent_income_w1, landrent_income_w2)




#write.table(landrent_income, "./landrent_gross_income.csv", sep=",")

``` 


\begin{enumerate}
\item[7] \textbf{Crop Sales Income} 
\end{enumerate}

\begin{center}
Crop Sales I
\end{center}
\par 
We retrieve data from Section 4: Agricultural Production, Part B: Crop Sales and Storage (i) Revenues from crop production. However, note that these revenues do not correspond to crop production as they are the revenues from selling the harvest - which can be vastly different from what was produced - therefore, it does not constitute a good measure to compute productivity. We address this issue in the next section of Market Value from crop production.  
\par 
In particular we use question B.71: What was the total revenue from this crop? for wave 1. Unfortunately, in wave 1 there is no question on the quantity sold, we only have the revenues from sold crops. In wave 2 the survey is more detailed providing information on the quantity sold, the price per unit and to whom it was sold. 
<!-- \par  -->
<!-- Another complication is that in wave 1 the corresponding question refers to the total revenues for sold crops - while in wave 2 they ask the per unit price of sold haverst and they also give the quantity that was sold. This is not a problem for now (to compute crops sales net income) however it is when we compute the market value of production to derive a productivity measure (this is the reason why we utilize Andre's conversion table and price data for wave 1). -->
<!-- \par  -->
<!-- We derive the net-income from crop sales as in this section the survey provides information about \textit{transportation cost}. in particular we use B.71 for the crop-sales revenues and B.67 for the transportation costs.  -->



\begin{enumerate}
\item[7.1] Revenues
\end{enumerate}

```{r Crop Sales}
##############################################################################################################################################
########################                         Crop Sales                                   ###############################################
##############################################################################################################################################

#################################################################################################################
#####################                       Wave 1                    ###########################################
#################################################################################################################

# Section 4 Part B Revenues from crop production
sec4pB_w1 = read_dta("./S4BI.dta")

cropsales_income_w1 = sec4pB_w1 %>% 
  select(id1, id2, id3, hhno, plotno, crop_no, 
         s4bi_b67i, s4bi_b67ii, 
         s4bi_b71i, s4bi_b71ii) %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(s4bi_b67ii = s4bi_b67ii*0.01) %>% 
  mutate(s4bi_b71ii = s4bi_b71ii*0.01) %>% 
  ungroup() %>% 
  mutate(cropsales_income = rowSums(select(.,9:10), na.rm = T)) %>% 
  mutate(cropsales_income = ifelse(cropsales_income==0, as.numeric(NA), cropsales_income)) %>% 
  mutate(cropsales_income = ifelse(cropsales_income<0, cropsales_income*-1, cropsales_income)) %>% 
  # mutate(cropsales_expenses = rowSums(select(.,7:8), na.rm = T)) %>% 
  # mutate(cropsales_expenses = ifelse(cropsales_expenses==0, as.numeric(NA), cropsales_expenses)) %>% 
  # mutate(cropsales_expenses = ifelse(cropsales_expenses>0,cropsales_expenses*-1, cropsales_expenses)) %>% 
  # select(-s4bi_b67i, -s4bi_b67ii, 
  #        -s4bi_b71i, -s4bi_b71ii) %>% 
  # ungroup() %>% 
  # mutate(cropsales_netincome =rowSums(select(.,7:8), na.rm = T)) %>%  
  # group_by(hhno, plotno, crop_no) %>% 
  # mutate(cropsales_netincome = ifelse(is.na(cropsales_income), as.numeric(NA), cropsales_netincome)) %>% 
  group_by(hhno) %>% 
  mutate(cropsales_income =sum(cropsales_income, na.rm = T)) %>% 
  # ungroup() %>% 
  # mutate(cropsales_netincome = ifelse(cropsales_netincome==0  & is.na(cropsales_income), as.numeric(NA), cropsales_netincome)) %>%  
  filter(!duplicated(hhno)) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, cropsales_income)


#################################################################################################################
#####################                       Wave 2                    ###########################################
#################################################################################################################

# Section 4 Part o Revenues from crop production
sec4pB_w2 = read_dta("./04o_cropsalesstoresquestions.dta") 

cropsales_income_w2 = sec4pB_w2 %>%
  select(FPrimary, cropcode, 
         samecommsoldquantity,  samecommsoldprice, 
         othercommsoldquantity, othercommsoldprice,
         traderssoldquantity,  traderssoldprice, 
         contractorssoldquantity, contractorssoldprice,
         orgssoldquantity,  orgssoldprice, 
         aggsoldquantity,  aggsoldprice,
         outgrowsoldquantity, outgrowsoldprice, 
         coopsoldquantity,  coopsoldprice,
         othersoldquantity, othersoldprice)%>%
         # transportcosts)  
  mutate(FPrimary = as.numeric(FPrimary)) %>% 
  group_by(FPrimary, cropcode) %>% 
  mutate(samecommsoldquantity = ifelse(is.na(samecommsoldquantity), 0, samecommsoldquantity)) %>% 
  mutate(samecommsoldprice = ifelse(is.na(samecommsoldprice), 0, samecommsoldprice)) %>% 
  mutate(othercommsoldquantity = ifelse(is.na(othercommsoldquantity), 0, othercommsoldquantity)) %>% 
  mutate(othercommsoldprice = ifelse(is.na(othercommsoldprice), 0, othercommsoldprice)) %>% 
  mutate(traderssoldquantity = ifelse(is.na(traderssoldquantity), 0, traderssoldquantity)) %>% 
  mutate(traderssoldprice = ifelse(is.na(traderssoldprice), 0, traderssoldprice)) %>%
  mutate(orgssoldquantity = ifelse(is.na(orgssoldquantity), 0, orgssoldquantity)) %>% 
  mutate(orgssoldprice = ifelse(is.na(orgssoldprice), 0, orgssoldprice)) %>% 
  mutate(aggsoldquantity = ifelse(is.na(aggsoldquantity), 0, aggsoldquantity)) %>% 
  mutate(aggsoldprice = ifelse(is.na(aggsoldprice), 0, aggsoldprice)) %>% 
  mutate(outgrowsoldquantity = ifelse(is.na(outgrowsoldquantity), 0, outgrowsoldquantity)) %>% 
  mutate(outgrowsoldprice = ifelse(is.na(outgrowsoldprice), 0, outgrowsoldprice)) %>% 
  mutate(coopsoldquantity = ifelse(is.na(coopsoldquantity), 0, coopsoldquantity)) %>% 
  mutate(coopsoldprice = ifelse(is.na(coopsoldprice), 0, coopsoldprice)) %>% 
  mutate(othersoldquantity = ifelse(is.na(othersoldquantity), 0, othersoldquantity)) %>% 
  mutate(othersoldprice = ifelse(is.na(othersoldprice), 0, othersoldprice)) %>% 
  mutate(contractorssoldquantity = ifelse(is.na(contractorssoldquantity), 0, contractorssoldquantity)) %>% 
  mutate(contractorssoldprice = ifelse(is.na(contractorssoldprice), 0, contractorssoldprice)) %>% 
  mutate(cropsales_revenues = (samecommsoldquantity*samecommsoldprice)+
           othercommsoldquantity*othercommsoldprice+traderssoldquantity*traderssoldprice+contractorssoldquantity*contractorssoldprice+
           orgssoldquantity*orgssoldprice+aggsoldquantity*aggsoldprice+outgrowsoldquantity*outgrowsoldprice+coopsoldquantity*coopsoldprice+
           othersoldquantity*othersoldprice) %>% 
  select(FPrimary, cropcode, cropsales_revenues) %>% 
  # mutate(cropsales_expenses = - transportcosts) %>% 
  # select(-transportcosts) %>% 
  ungroup() %>%
  mutate(cropsales_income = cropsales_revenues) %>% 
  group_by(FPrimary) %>% 
  mutate(cropsales_income = sum(cropsales_income, na.rm = T)) %>% 
  filter(!duplicated(FPrimary)) %>% 
  # mutate(cropsales_netincome = ifelse(cropsales_netincome==0, as.numeric(NA), cropsales_netincome)) %>% 
  mutate(wave =2) %>% 
  select(wave, FPrimary, cropsales_income)

colnames(cropsales_income_w2)[colnames(cropsales_income_w2)=="FPrimary"]="hhno"  

# Merge it with the key hh info to get the id1, id2, id3, 
cropsales_income_w2 = left_join(cropsales_income_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, cropsales_income)


# Merge the two waves by row:
cropsales_income= rbind(data.frame(cropsales_income_w1), data.frame(cropsales_income_w2)) %>% 
                  mutate(across(contains("income"),  #annual
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 



#write.table(cropsales_income, "./cropsales_gross_income.csv", sep=",")

```


```{r display distribution of crop sales income profits deflated}
# deflated measure - net fin income
pander(summary(subset(cropsales_income, wave==1)$cropsales_income_defl), caption = "net crop sales income in w.1 (in cedis)")
pander(summary(subset(cropsales_income, wave==2)$cropsales_income_defl), caption = "net crop sales income income in w.2 (in 2009 cedis)")

```

\begin{center}
Crop Sales II
\end{center}
\par 
In this section we utilize another question (not from crops sales) from crops production that delivers the same information as the one above. In particular, in section V referring to crops harvest there is one relevant question: A.83: What was the total revenue from this crops harvest (sold)? which should coincide with the one above as it refers to sold production. 
\par 
Notice that the comparison only refers to wave 1 as in wave 2 the particular question is absent and crop-sales information is only on the crop-sales section. 
\par 
Notice that there is large difference between the two distribution of net income from crops-sales. HoWever, in order to maintain some consistency I think this information should be discarded as it does not appear in wave 2. 


```{r Crops sales revenue from production section}
### Major Season
crop_prod = read.dta("./S4AV1.dta") %>%
  mutate(id1= as.numeric(id1)) %>% 
  mutate(id2= as.numeric(id2)) %>% 
  mutate(id3= as.numeric(id3)) %>%
  mutate(hhno = as.numeric(hhno)) %>% 
  filter(!is.na(s4av1_plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>% 
  select(id1, id2, id3, hhno, plot_id, 
         s4v_a83i, s4v_a83ii, # for crop 1
         s4v_a91i, s4v_a91ii, # for crop 2
         s4v_a99i, s4v_a99ii, # for crop 3
         s4v_a107i, s4v_a107ii, # for crop 4
         s4v_a115i, s4v_a115ii) # for crop 5 

crop_prod_min = read.dta("./S4AV2.dta") %>%
  mutate(id1= as.numeric(id1)) %>% 
  mutate(id2= as.numeric(id2)) %>% 
  mutate(id3= as.numeric(id3)) %>%
  mutate(hhno = as.numeric(hhno)) %>% 
  filter(!is.na(s4av2_plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>% 
  select(id1, id2, id3, hhno, plot_id, 
         s4v_a124i, s4v_a124ii, # for crop 1
         s4v_a132i, s4v_a132ii, # for crop 2
         s4v_a140i, s4v_a140ii, # for crop 3
         s4v_a148i, s4v_a148ii, # for crop 4
         s4v_a156i, s4v_a156ii) # for crop 5 

crop_sales_income_ii = left_join(crop_prod, crop_prod_min, by = c("id1", "id2", "id3", "hhno", "plot_id")) %>% 
  mutate(across(contains('ii'), ~.*0.01)) %>% 
  pivot_longer(cols = contains("s4v"), names_to = 'crops', values_to = 'crops_value') %>% 
  group_by(hhno) %>% 
  mutate(cropsales_revenues = sum(crops_value, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% select(-crops, -crops_value, -plot_id) %>% 
  mutate(cropsales_revenues = case_when(cropsales_revenues<0 ~ 0, TRUE~cropsales_revenues))

 # Note that for wave 2 there is not a similar question in the crops-harvest section, it only asks about revenues from sold harvest in the crops-sales section, so for wave 2 the data will be the same as wave 2's in crop-saled income above. 


```

```{r display distribution of crop sales from the production question only for wave 1}
# deflated measure - net fin income
pander(summary(crop_sales_income_ii$cropsales_revenues), caption = "crop sales income in w.1 (in cedis/from production question) ")
```

\begin{enumerate}
\item[7.2] Costs
\end{enumerate}


\begin{enumerate}
\item \underline{Chemicals}:
\par 
We use questions: A.165: What was the value of the amount of the chemicals that you used and A.168: What is the value of the subsidy. 
\par 
The survey asks this question for all chemicals (total 5) and for both major and minor season. 
\par 
\underline{Notes on chemicals}: In wave 2 they do not ask any question about subsidy on chemicals - which apparently in some cases is larger than the cost (as seen in wave 1). Moreover, in wave 2 they as about the total cost of of chemicals in the previous farmin season (setion L q.L10)- so they do not ask separately about major and minor. 
\item \underline{Tractor}:
\par 
We use questions A.244: What was the total cost of the tractor for opeartions on this plot for the last major season. and A.246: same question for the last minor season. 
\item \underline{Seeds}:
\par 
We use questions A.252: What was the values of this seed (major season) and A.270 What was the value of this seed (minor season) 
\par 
The survey asks this question for all seeds (total 5)
\item \underline{Labour Input}
\par 
Here we utilize questions A.290, A.291 and A.292 which ask how much \textbf{casual work} was provided by men, women and children respectively. Questions A.293, A.294, A.295 which ask how much \textbf{permanent labour} was provided by men, women and children respectively and Questions A.296, A.297, A.298 which ask how much \textbf{family labour} was provided by men, women and children respectively. (we exclude family labour as we assume that is non-paid) 
\par 
The survey asks this set of 9 questions for all stages of crops-production (i) Land preparation, (ii) Field Management (iii) Harvesting and (iv) Post Harvest. It also asks these questions for both major and minor seasons. 
\par 
Notice that regarding labour inputs we only have the \textbf{time} for each type of labour provided. In order to assign value of this labour, we utilise information from the main occupation section which gives the income of people working on the field.
\item \underline{Transportation Costs}: question B.67 for the transportation costs in the crops-sales section. 
\end{enumerate}

\subsubsection{Chemicals}

```{r Production COSTS 1 - Chemicals}
# Chemicals Wave 1
chemicals_major = read.dta("./S4AVI1.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4avi1_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2, id3, hhno, plot_id, 
         s4avi_a165i,s4avi_a165ii,s4avi_a168i,s4avi_a168ii,
         s4avi_a173i,s4avi_a173ii,s4avi_a176i,s4avi_a176ii,
         s4avi_a181i,s4avi_a181ii,s4avi_a184i,s4avi_a184ii,
         s4avi_a189i,s4avi_a189ii,s4avi_a192i,s4avi_a192ii,
         s4avi_a197i,s4avi_a197ii,s4avi_a200i,s4avi_a200ii) %>% 
  mutate(across(contains("ii"), ~.*(0.01))) %>% 
  mutate(across(c(s4avi_a168i,s4avi_a168ii, s4avi_a176i,s4avi_a176ii,
         s4avi_a184i,s4avi_a184ii,s4avi_a192i,s4avi_a192ii,
         s4avi_a200i,s4avi_a200ii), ~.*(-1))) %>% 
  ungroup() %>% 
  mutate(chemical_major_netcost = rowSums(select(.,6:25), na.rm = T)) %>%
  select(id1, id2, id3, hhno, plot_id, chemical_major_netcost) %>% 
  group_by(hhno) %>% 
  mutate(chemical_major_netcost = sum(chemical_major_netcost, na.rm = T)) %>% 
  filter(!duplicated(hhno))

chemicals_minor = read.dta("./S4AVI2.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4avi2_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2, id3, hhno, plot_id, 
         s4avi_206i,s4avi_206ii,s4avi_209i,s4avi_209ii,
         s4avi_214i,s4avi_214ii,s4avi_217i,s4avi_217ii,
         s4avi_222i,s4avi_222ii,s4avi_225i,s4avi_225ii,
         s4avi_230i,s4avi_230ii,s4avi_233i,s4avi_233ii,
         s4avi_238i,s4avi_238ii,s4avi_241i,s4avi_241ii) %>% 
  mutate(across(contains("ii"), ~.*(0.01))) %>% 
  mutate(across(c(s4avi_209i,s4avi_209ii, s4avi_217i,s4avi_217ii,
         s4avi_225i,s4avi_225ii,s4avi_233i,s4avi_233ii,
         s4avi_241i,s4avi_241ii), ~.*(-1))) %>% 
  ungroup() %>% 
  mutate(chemical_minor_netcost = rowSums(select(.,6:25), na.rm = T)) %>%
  select(id1, id2, id3, hhno, plot_id, chemical_minor_netcost) %>% 
  group_by(hhno) %>% 
  mutate(chemical_minor_netcost = sum(chemical_minor_netcost, na.rm = T)) %>% 
  filter(!duplicated(hhno))

chemicals_w1 = full_join(chemicals_major, chemicals_minor, by = c("id1", "id2", "id3", "hhno")) %>% select(-contains("plot_id")) %>% 
  ungroup() %>% 
  mutate(chemicals_net_cost = rowSums(select(.,5:6), na.rm=T)) %>% 
  select(-chemical_major_netcost, -chemical_minor_netcost) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, chemicals_net_cost)

# Chemicals Wave 2
chemicals_w2 = read_dta("./04l_chemquestions.dta") %>% 
  select(FPrimary, chempurchasedprice) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  group_by(hhno) %>% 
  mutate(chemicals_net_cost = sum(chempurchasedprice, na.rm = T)) %>% 
  select(hhno, chemicals_net_cost) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave = 2)


# Merge it with the key hh info to get the id1, id2, id3, 
chemicals_w2 = left_join(chemicals_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, chemicals_net_cost)

# Merge the two waves by row:
chemicals_cost= rbind(data.frame(chemicals_w1), data.frame(chemicals_w2)) %>% 
                  mutate(across(contains("net_cost"),  
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 



#write.table(chemicals_cost, "./chemicals_cost.csv", sep=",")

```


```{r display distribution of chemical costs deflated}
# deflated measure - net fin income
pander(summary(subset(chemicals_cost, wave==1)$chemicals_net_cost_defl), caption = "net (cost-subs.) chemical costs in w.1 (in cedis)")
pander(summary(subset(chemicals_cost, wave==2)$chemicals_net_cost_defl), caption = "net chemical costs in w.2 (in 2009 cedis)")

```

\subsubsection{Seeds}

```{r Production COSTS 2 - SEEDS}
# seeds Wave 1
seeds_major = read.dta("./S4AVIII1.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aviii1_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2, id3, hhno, plot_id, s4aviii_250,
         s4aviii_252i,s4aviii_252ii,
         s4aviii_257i,s4aviii_257ii,
         s4aviii_262i,s4aviii_262ii,
         s4aviii_267i,s4aviii_267ii) %>% 
  mutate(across(c("s4aviii_252ii", "s4aviii_257ii", "s4aviii_262ii", "s4aviii_267ii"), ~.*(0.01))) %>% 
  # mutate(across(c(s4avi_a168i,s4avi_a168ii, s4avi_a176i,s4avi_a176ii,
  #        s4avi_a184i,s4avi_a184ii,s4avi_a192i,s4avi_a192ii,
  #        s4avi_a200i,s4avi_a200ii), ~.*(-1))) %>% 
  ungroup() %>% 
  mutate(seeds_major_cost = rowSums(select(.,7:14), na.rm = T)) %>%
  select(id1, id2, id3, hhno, plot_id, s4aviii_250, seeds_major_cost) %>% 
  mutate(seeds_major_purchcost = case_when(s4aviii_250 == 'Purchased' ~ seeds_major_cost, 
                                           TRUE ~ 0)) %>% 
  group_by(hhno) %>% 
  mutate(seeds_major_cost_hh = sum(seeds_major_cost, na.rm = T)) %>% 
  mutate(seeds_major_purchcost_hh = sum(seeds_major_purchcost, na.rm=T)) %>% 
  select(-seeds_major_cost, -seeds_major_purchcost) %>% 
   filter(!duplicated(hhno))
```

\par 
Notice that not all seeds are purchased, therefore, we include two measures of costs for seed. The first includes the total value of seeds used by the households, and the second the total value of seeds that were purchased and used. We actually drop the first measure because in wave 2, the corresponding question only asks for value of the purchased seeds leaving out all other types. 
```{r display how many seeds were purchased w1major}
seeds_major_how = read.dta("./S4AVIII1.dta") 
pander(freq(seeds_major_how$s4aviii_250), caption = 'How did you obtain the seed w1 in major season')

```

```{r seeds continued - minor season wave 1}

# seeds Wave 1 - minor season
seeds_minor = read_dta("./S4AVIII2.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aviii2_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2, id3, hhno, plot_id, s4aviii_271,
         s4aviii_273i,s4aviii_273ii,
         s4aviii_278i,s4aviii_278ii,
         s4aviii_283i,s4aviii_283ii,
         s4aviii_288i,s4aviii_288ii) %>% 
  mutate(across(c("s4aviii_273ii", "s4aviii_278ii", "s4aviii_283ii", "s4aviii_288ii"), ~.*(0.01))) %>% 
  # mutate(across(c(s4avi_a168i,s4avi_a168ii, s4avi_a176i,s4avi_a176ii,
  #        s4avi_a184i,s4avi_a184ii,s4avi_a192i,s4avi_a192ii,
  #        s4avi_a200i,s4avi_a200ii), ~.*(-1))) %>% 
  ungroup() %>% 
  mutate(seeds_minor_cost = rowSums(select(.,7:14), na.rm = T)) %>%
  select(id1, id2, id3, hhno, plot_id, s4aviii_271, seeds_minor_cost) %>% 
  mutate(seeds_minor_purchcost = case_when(s4aviii_271 == 2 ~ seeds_minor_cost, 
                                           TRUE ~ 0)) %>% 
  group_by(hhno) %>% 
  mutate(seeds_minor_cost_hh = sum(seeds_minor_cost, na.rm = T)) %>% 
  mutate(seeds_minor_purchcost_hh = sum(seeds_minor_purchcost, na.rm=T)) %>% 
  select(-seeds_minor_cost, -seeds_minor_purchcost) %>% 
   filter(!duplicated(hhno))

# merge major minor
seeds_w1 = full_join(seeds_major, seeds_minor, by = c("id1", "id2", "id3", "hhno")) %>% select(-contains("plot_id"), -contains('iii')) %>% 
  select(id1, id2, id3, hhno, seeds_major_cost_hh, seeds_minor_cost_hh, seeds_major_purchcost_hh, seeds_minor_purchcost_hh) %>% 
  ungroup() %>% 
  mutate(seeds_cost = rowSums(select(.,5:6), na.rm=T)) %>% 
  mutate(seeds_purch_cost = rowSums(select(.,7:8), na.rm = T)) %>% 
  select(-seeds_major_cost_hh, -seeds_minor_cost_hh, -seeds_major_purchcost_hh, -seeds_minor_purchcost_hh) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, -seeds_cost, seeds_purch_cost)

# Chemicals Wave 2
seeds_w2 = read_dta("./04k_seedquestions.dta") %>% 
  select(FPrimary, seedpaid) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  group_by(hhno) %>% 
  mutate(seeds_purch_cost = sum(seedpaid, na.rm = T)) %>% 
  select(hhno, seeds_purch_cost) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave = 2)


# Merge it with the key hh info to get the id1, id2, id3, 
seeds_w2 = left_join(seeds_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, seeds_purch_cost)

# Merge the two waves by row:
seeds_cost= rbind(data.frame(seeds_w1), data.frame(seeds_w2)) %>% 
                  mutate(across(contains("purch_cost"),  
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 



#write.table(seeds_cost, "./seeds_cost.csv", sep=",")

```


```{r display distribution of seeds costs deflated}
# deflated measure - net fin income
pander(summary(subset(seeds_cost, wave==1)$seeds_purch_cost_defl), caption = "seeds (purchased) costs in w.1 (in cedis)")
pander(summary(subset(seeds_cost, wave==2)$seeds_purch_cost_defl), caption = "seeds (purchased) costs in w.2 (in 2009 cedis)")

```

\subsubsection{Tractor}

```{r tractor use}
#tractor cost wave 1
tractor_w1 = read_dta("./S4AVII.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4avii_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2, id3, hhno, plot_id, 
         s4avii_244i,s4avii_244ii,
         s4avii_246i,s4avii_246ii) %>% 
  mutate(across(c("s4avii_244ii", "s4avii_246ii"), ~.*(0.01))) %>% 
  ungroup() %>% 
  mutate(tractor_cost = rowSums(select(.,6:9), na.rm = T)) %>%
  select(id1, id2, id3, hhno, plot_id, tractor_cost) %>% 
  group_by(hhno) %>% 
  mutate(tractor_cost = sum(tractor_cost, na.rm = T)) %>% 
  mutate(wave =1) %>% 
  select(wave, id1, id2, id3, hhno, tractor_cost) %>% 
  filter(!duplicated(hhno))

#tractor cost wave 2

tractor_w2 = read_dta("./04j_tracploughuse.dta") %>% 
  select(FPrimary, ploughpaymentcash) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  group_by(hhno) %>% 
  mutate(tractor_cost = sum(ploughpaymentcash, na.rm = T)) %>% 
  select(hhno, tractor_cost) %>% 
  filter(!duplicated(hhno)) %>% 
  mutate(wave = 2)


# Merge it with the key hh info to get the id1, id2, id3, 
tractor_w2 = left_join(tractor_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, tractor_cost)

# Merge the two waves by row:
tractor_cost= rbind(data.frame(tractor_w1), data.frame(tractor_w2)) %>% 
                  mutate(across(contains("cost"),  
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 



#write.table(tractor_cost, "./tractor_cost.csv", sep=",")

```


```{r display distribution of tractor costs deflated}
# deflated measure - net fin income
pander(summary(subset(tractor_cost, wave==1)$tractor_cost_defl), caption = "tractor costs in w.1 (in cedis)")
pander(summary(subset(tractor_cost, wave==2)$tractor_cost_defl), caption = "tractor costs in w.2 (in 2009 cedis)")

```


\subsubsection{Labour Inputs}
\par 
The section is concerned with labour inputs in each plot is much detailed. It divides the process of harvesting in 4 different stages ((i) Land preparation, (ii) Field Management, (iii) Harvesting, (iv) Post-Harvest) and asks about three types of labour ((a) casual, (b) permanent, (c) family) separately for (1.men, 2. women, 3. children). 
\par 
From this categorization we focus on all stages of harvesting, on (a) casual and (b) permanent labour, as we expect that family labour is not paid, and for men and women as child labour will not be paid. 
\par 
Despite reporting the number of days, average hours per day and avergage number of workers for each plot, the survey does not ask for wages. Therefore we resort to the section of \textit{income from main occcupation} to retrieve wages from people occupied in agriculture -related jobs. In main occupation survey section, people report the 'kind of trade, service and industry their work connects to'. From those reported we focus on the following sectors (as they appear in the responses): 1/Agric Labourer, 2/Agric Service, 3/Agric Subistence, 4/ Agriculture, 5/ Agric, 6/ Agriculture Service, 7/Farming, 8/ Harvesting crops on farm, 9/ Weeding, 10/Weeding, irrigation, harvesting. Those categories however, exhibit vast heterogeneity in terms of daily (0.4- 207 cedis per day) and hourly wages, this is also due to those categories including from farm labourers to land managers. Therefore, we restrict the sample to those that report as their main duty 'farm labourer'. Taking the mean of thei daily and hourly wage we end up in \textbf{10.9 cedis per day} and \textbf{1.6 cedis} per hour for the average farm labourer. 
\par 
In wave 2, the survey divides harvesting in 7 stages (i) Clearing and land preparation, (ii) Plowing, (iii) Planting, (iv) Chemical Application, (v) Weeding, (vi) Harvesting and (vii) Post harvesting. It does not provide average hours only average days so we are going to use the average daily wage from main occupation data in wave 2. Following the same process to derive a mean wage per day and a mean wage per hour using wave 2's main occupation data, we find a mean wage per day of \textbf{7.67 cedis per day} and \textbf{1.47 cedis per hour} for the average farm labourer in wave 2. 

```{r Labour Inputs w1}
sec1pE_w1 = read_dta("./S1EI.dta") %>% 
   filter(s1ei_4 == "AGRIC LABOURER"|
          s1ei_4 == 'AGRIC SERVICE'|
          s1ei_4 == 'AGRICULTURE'|
          s1ei_4 == 'AGRIC'|
          s1ei_4 == 'AGRICULTURE SERVICE'|
          s1ei_4 == 'FARMING'|
          s1ei_4 == 'HARVESTING CROPS ON FARM'|
          s1ei_4 == 'WEEDING'|
          s1ei_4 == 'WEEDING, IRRIGATION, HARVESTING'|
          s1ei_4 == 'WELDING'|
          s1ei_4 == 'AGRIC SUBSISTENCE') %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  select(id1, id2, id3, hhno, 
         s1ei_2, s1ei_4, 
         s1ei_8i, s1ei_8ii, 
         s1ei_10i, s1ei_10ii) %>% 
  ungroup() %>% 
  mutate(s1ei_10ii = s1ei_10ii*0.01) %>% 
  ungroup() %>% 
  mutate(sevenday_income = rowSums(select(.,9:10), na.rm = T)) %>% 
  select(-s1ei_10ii, -s1ei_10i) %>% 
  ungroup() %>% 
  mutate(wage_per_day = sevenday_income/s1ei_8i) %>% 
  mutate(wage_per_hour = sevenday_income/(s1ei_8i*s1ei_8ii)) %>% 
  select(-s1ei_8i, -s1ei_8ii) %>% 
  filter(s1ei_2 == 'FARM LABOURER') %>% 
  mutate(farm_labour_meanwageperday = mean(wage_per_day)) %>% 
  mutate(farm_labour_meanwageperhr = mean(wage_per_hour))
  
# Labour inputs wave 1 major season. stage 1

labour_inp_major1 = read_dta("./S4AIX1.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(plotno=as.numeric(s4aix1_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2, hhno, plot_id, 
         s4aix_290i, s4aix_290ii, s4aix_290iii, 
         s4aix_291i, s4aix_291ii, s4aix_291iii, 
         s4aix_293i, s4aix_293ii, s4aix_293iii, 
         s4aix_294i, s4aix_294ii, s4aix_294iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_290i*s4aix_290ii*s4aix_290iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_291i*s4aix_291ii*s4aix_291iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_293i*s4aix_293ii*s4aix_293iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_294i*s4aix_294ii*s4aix_294iii) %>% 
  mutate(tot_hrs = rowSums(select(.,17:20), na.rm=T)) %>% 
  mutate(labour_cost1 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost1 = sum(labour_cost1, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, hhno, labour_cost1)

# Labour inputs wave 1 major season. stage 2

  
labour_inp_major2 = read_dta("./S4AIX2.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix2_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_299i, s4aix_299ii, s4aix_299iii, 
         s4aix_300i, s4aix_300ii, s4aix_300iii, 
         s4aix_302i, s4aix_302ii, s4aix_302iii, 
         s4aix_303i, s4aix_303ii, s4aix_303iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_299i*s4aix_299ii*s4aix_299iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_300i*s4aix_300ii*s4aix_300iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_302i*s4aix_302ii*s4aix_302iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_303i*s4aix_303ii*s4aix_303iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost2 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost2 = sum(labour_cost2, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost2)
    

# Labour inputs wave 1 major season. stage 3

  
labour_inp_major3 = read_dta("./S4AIX3.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix3_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_308i, s4aix_308ii, s4aix_308iii, 
         s4aix_309i, s4aix_309ii, s4aix_309iii, 
         s4aix_311i, s4aix_311ii, s4aix_311iii, 
         s4aix_312i, s4aix_312ii, s4aix_312iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_308i*s4aix_308ii*s4aix_308iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_309i*s4aix_309ii*s4aix_309iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_311i*s4aix_311ii*s4aix_311iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_312i*s4aix_312ii*s4aix_312iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost3 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost3 = sum(labour_cost3, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost3)

# Labour inputs wave 1 major season. stage 4

  
labour_inp_major4 = read_dta("./S4AIX4.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix4_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_317i, s4aix_317ii, s4aix_317iii, 
         s4aix_318i, s4aix_318ii, s4aix_318iii, 
         s4aix_320i, s4aix_320ii, s4aix_320iii, 
         s4aix_321i, s4aix_321ii, s4aix_321iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_317i*s4aix_317ii*s4aix_317iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_318i*s4aix_318ii*s4aix_318iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_320i*s4aix_320ii*s4aix_320iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_321i*s4aix_321ii*s4aix_321iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost4 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost4 = sum(labour_cost4, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost4)


# Labour inputs wave 1 minor season. stage 1

  
labour_inp_minor1 = read_dta("./S4AIX5.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix5_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_327i, s4aix_327ii, s4aix_327iii, 
         s4aix_328i, s4aix_328ii, s4aix_328iii, 
         s4aix_330i, s4aix_330ii, s4aix_330iii, 
         s4aix_331i, s4aix_331ii, s4aix_331iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_327i*s4aix_327ii*s4aix_327iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_328i*s4aix_328ii*s4aix_328iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_330i*s4aix_330ii*s4aix_330iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_331i*s4aix_331ii*s4aix_331iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost1 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost1 = sum(labour_cost1, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost1)

# Labour inputs wave 1 minor season. stage 2

  
labour_inp_minor2 = read_dta("./S4AIX6.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix6_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_336i, s4aix_336ii, s4aix_336iii, 
         s4aix_337i, s4aix_337ii, s4aix_337iii, 
         s4aix_339i, s4aix_339ii, s4aix_339iii, 
         s4aix_340i, s4aix_340ii, s4aix_340iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_336i*s4aix_336ii*s4aix_336iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_337i*s4aix_337ii*s4aix_337iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_339i*s4aix_339ii*s4aix_339iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_340i*s4aix_340ii*s4aix_340iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost2 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost2 = sum(labour_cost2, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost2)


# Labour inputs wave 1 minor season. stage 3

  
labour_inp_minor3 = read_dta("./S4AIX7.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix7_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_345i, s4aix_345ii, s4aix_345iii, 
         s4aix_346i, s4aix_346ii, s4aix_346iii, 
         s4aix_348i, s4aix_348ii, s4aix_348iii, 
         s4aix_349i, s4aix_349ii, s4aix_349iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_345i*s4aix_345ii*s4aix_345iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_346i*s4aix_346ii*s4aix_346iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_348i*s4aix_348ii*s4aix_348iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_349i*s4aix_349ii*s4aix_349iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost3 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost3 = sum(labour_cost3, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost3)



# Labour inputs wave 1 minor season. stage 4

  
labour_inp_minor4 = read_dta("./S4AIX8.dta") %>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(s4aix8_plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  filter(!is.na(plotno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>% select(-plotno) %>% 
  select(id1, id2,id3, hhno, plot_id, 
         s4aix_354i, s4aix_354ii, s4aix_354iii, 
         s4aix_355i, s4aix_355ii, s4aix_355iii, 
         s4aix_357i, s4aix_357ii, s4aix_357iii, 
         s4aix_358i, s4aix_358ii, s4aix_358iii) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_hrs_men_casual = s4aix_354i*s4aix_354ii*s4aix_354iii) %>% 
  mutate(tot_hrs_wom_casual = s4aix_355i*s4aix_355ii*s4aix_355iii) %>% 
  mutate(tot_hrs_men_perm = s4aix_357i*s4aix_357ii*s4aix_357iii) %>% 
  mutate(tot_hrs_wom_perm = s4aix_358i*s4aix_358ii*s4aix_358iii) %>% 
  mutate(tot_hrs = rowSums(select(.,18:21), na.rm=T)) %>% 
  mutate(labour_cost4 = tot_hrs*1.6) %>% 
  group_by(hhno) %>% 
  mutate(labour_cost4 = sum(labour_cost4, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>% 
  select(id1, id2, id3, hhno, labour_cost4)

labour_cost_w1 = full_join(labour_inp_major1, labour_inp_major2, by = c("id1", 'id2', "hhno"))
labour_cost_w1 = full_join(labour_cost_w1, labour_inp_major3, by = c("id1", 'id2',"id3" ,"hhno"))
labour_cost_w1 = full_join(labour_cost_w1, labour_inp_major4, by = c("id1", 'id2',"id3" ,"hhno"))
labour_cost_w1 = full_join(labour_cost_w1, labour_inp_minor1, by = c("id1", 'id2',"id3" ,"hhno"))
labour_cost_w1 = full_join(labour_cost_w1, labour_inp_minor2, by = c("id1", 'id2',"id3" ,"hhno"))
labour_cost_w1 = full_join(labour_cost_w1, labour_inp_minor3, by = c("id1", 'id2',"id3" ,"hhno"))
labour_cost_w1 = full_join(labour_cost_w1, labour_inp_minor4, by = c("id1", 'id2',"id3" ,"hhno")) %>% 
  select(id1, id2, id3, hhno, contains('labour_cost')) %>% 
  ungroup() %>% 
  mutate(tot_labour_cost = rowSums(select(.,5:12), na.rm = T)) %>% 
  mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, tot_labour_cost)

```


```{r Labour inputs wave 2}

sec1pE_w2 = read_dta("./01ei_employmentmain.dta") %>% 
   filter(maintrade == "agric"|
          maintrade == 'agricultural'|
          maintrade == 'AGRICULTURAL'|
          maintrade == 'AGRICULTURAL (LABOURER)'|
          maintrade == 'agricultural labourer'|
          maintrade == 'agriculture'|
          maintrade == 'Agriculture'|
          maintrade == 'AGRICULTURE'|
          maintrade == 'FARM LABOURER'|
          maintrade == 'farm labourers'|
          maintrade == 'farming'|
          maintrade == 'FARMING'|
            maintrade == 'weeding') %>% 
  mutate(hhno=as.numeric(FPrimary)) %>% 
  select(hhno, maintasks, maintrade,
         last7daysperweek, last7hoursperday, 
         paidamount) %>% 
  ungroup() %>% 
  ungroup() %>% 
  mutate(wage_per_day = paidamount/last7daysperweek) %>% 
  mutate(wage_per_hour = paidamount/(last7daysperweek*last7hoursperday)) %>% 
  filter(wage_per_day<=20) %>% 
  select(-last7daysperweek, -last7hoursperday) %>% 
  mutate(farm_labour_meanwageperday = mean(wage_per_day)) %>% 
  mutate(farm_labour_meanwageperhr = mean(wage_per_hour))
  
# Labour inputs wave 2 major season. stage 1
labour_cost_w2 = read_dta("./04m_aglabourquestions.dta") %>% 
  mutate(hhno=as.numeric(FPrimary)) %>% 
  select(hhno, hiredwomen, hiredmen, hiredwomendays, hiredmendays) %>% 
  mutate(across(everything(), ~replace_na(., 0), .)) %>% 
  ungroup() %>% 
  mutate(tot_days_men = hiredmen*hiredmendays) %>% 
  mutate(tot_days_wom = hiredwomen*hiredwomendays) %>% 
  mutate(tot_days = rowSums(select(.,6:7), na.rm=T)) %>% 
  mutate(labour_cost1 = tot_days*7.67) %>% 
  group_by(hhno) %>% 
  mutate(tot_labour_cost = sum(labour_cost1, na.rm = T)) %>% 
  filter(!duplicated(hhno)) %>%
  mutate(wave=2) %>% 
  select(wave, hhno, tot_labour_cost)


# Merge it with the key hh info to get the id1, id2, id3, 
labour_cost_w2 = left_join(labour_cost_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, tot_labour_cost)

# Merge the two waves by row:
labour_cost= rbind(data.frame(labour_cost_w1), data.frame(labour_cost_w2)) %>% 
                  mutate(across(contains("cost"),  
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 


#write.table(labour_cost, "./labour_cost.csv", sep=",")


```


```{r display distribution of labour input costs deflated}
pander(summary(subset(labour_cost, wave==1)$tot_labour_cost_defl), caption = "labour costs in w.1 (in cedis)")
pander(summary(subset(labour_cost, wave==2)$tot_labour_cost_defl), caption = "labour costs in w.2 (in 2009 cedis)")

```


\subsubsection{Transportation Costs}


```{r Transportation Costs}
# wave 1 Transportation costs

sec4pB_w1 = read_dta("./S4BI.dta") 


transcost_w1 = sec4pB_w1%>% 
  mutate(id1=as.numeric(id1)) %>% 
  mutate(id2=as.numeric(id2)) %>% 
  mutate(id3=as.numeric(id3)) %>% 
  mutate(plotno=as.numeric(plotno)) %>% filter(!is.na(plotno)) %>% 
  mutate(hhno=as.numeric(hhno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, plotno, sep=""))) %>%filter(!is.na(plot_id)) %>%  
  select(id1, id2, id3, hhno, plot_id, s4bi_b67i, s4bi_b67ii) %>% 
  mutate(s4bi_b67ii = case_when(s4bi_b67ii<0~0, TRUE ~ s4bi_b67ii)) %>% 
  mutate(s4bi_b67ii = s4bi_b67ii*0.01) %>% 
  ungroup()%>% 
  mutate(trans_cost = rowSums(select(.,6:7),na.rm = T)) %>% 
  group_by(hhno) %>% 
  mutate(trans_cost = sum(trans_cost)) %>% 
  filter(!duplicated(hhno)) %>% mutate(wave=1) %>% 
  select(wave, id1, id2, id3, hhno, trans_cost)


#Wave 2 transportation costs

sec4pB_w2 = read_dta("./04o_cropsalesstoresquestions.dta") 

transcost_w2 = sec4pB_w2 %>%
  select(FPrimary, 
         transportcosts) %>% 
  mutate(hhno = as.numeric(FPrimary)) %>% 
  group_by(hhno) %>% 
  mutate(trans_cost = sum(transportcosts, na.rm = T)) %>% 
  filter(!duplicated(FPrimary)) %>% 
  mutate(wave =2) %>% ungroup() %>% 
  select(wave, hhno, trans_cost)

# Merge it with the key hh info to get the id1, id2, id3, 
transcost_w2 = left_join(transcost_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, trans_cost)


# Merge the two waves by row:
trans_cost= rbind(data.frame(transcost_w1), data.frame(transcost_w2)) %>% 
                  mutate(across(contains("cost"),  
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 


#write.table(trans_cost, "./trans_cost.csv", sep=",")


```


```{r display distribution of transporation costs deflated}
# deflated measure - net fin income
pander(summary(subset(trans_cost, wave==1)$trans_cost_defl), caption = "transporation costs in w.1 (in cedis)")
pander(summary(subset(trans_cost, wave==2)$trans_cost_defl), caption = "transportation costs in w.2 (in 2009 cedis)")

```

\subsubsection{Total Crop Costs}

```{r Gather all costs and make a graph, fig.align='center', fig.width= 8, fig.height=5}
all_costs = full_join(chemicals_cost, seeds_cost, by = c('wave', 'id1', 'id2', 'id3', "hhno"))
all_costs = full_join(all_costs, tractor_cost, by = c('wave', 'id1', 'id2', 'id3', "hhno"))
all_costs = full_join(all_costs, labour_cost, by = c('wave', 'id1', 'id2', 'id3', "hhno"))
all_costs = full_join(all_costs, trans_cost, by = c('wave', 'id1', 'id2', 'id3', "hhno"))

#write.table(all_costs, "./all_costs.csv", sep=",")

all_costs.id3 = all_costs %>% mutate(chemicals_net_cost_defl = case_when(chemicals_net_cost_defl<0 ~ 0, TRUE ~ chemicals_net_cost_defl)) %>% 
  select(wave, id1, id2, id3, hhno, contains('defl')) %>% 
  group_by(wave, id3) %>% 
  mutate(across(contains("defl"), ~mean(., na.rm=T), .names="mean_{.col}")) %>% 
  filter(!duplicated(id3)) %>% 
  select(wave, id1, id2, id3,  contains('mean'))


all_costs.id3.long = all_costs.id3 %>% pivot_longer(cols = contains('mean'), names_to = 'cost_comp', values_to = "cost_value")


ggplot(all_costs.id3.long, aes(fill=cost_comp, y=cost_value, x=id3)) + 
    geom_bar(position="fill", stat="identity")+
    facet_wrap(~wave)+
    ggtitle('Total crop costs breakdown (%)')+
    xlab('Villages (id3)')+ylab("mean village cost (cedis)")+
    labs(caption = 'Shows the percentage of each component in the mean value of total cost')+
    theme(plot.title = element_text(hjust = 0.5, size=13, face="bold"), 
        plot.caption = element_text(hjust = 1), 
        axis.text.x=element_text(angle = 0, face="bold"),
        axis.text.y = element_text(angle = 0, face="bold"))
```


```{r Distribution of total Crop costs}

all_costs = all_costs %>%
  ungroup() %>% 
  select(wave, id1, id2, id3, hhno, contains('defl')) %>% 
  mutate(tot_crop_costs_defl = rowSums(select(.,6:10), na.rm = T))

```


```{r display distribution of total crop costs deflated}
# deflated measure - net fin income
pander(summary(subset(all_costs, wave==1)$tot_crop_costs_defl), caption = "total crop costs in w.1 (in cedis)")
pander(summary(subset(all_costs, wave==2)$tot_crop_costs_defl), caption = "total crop in w.2 (in 2009 cedis)")
```



\par 
Finally, we can derive the net crop income which will be the following: 
\begin{equation}
\begin{aligned}
& net.crop.income_{w,h} = \\
& crop.sales_{w,h} - transortation.cost_{w,h} - chemical.costs_{w,h} - seed.costs_{w,h} - tractor.cost_{w,h} - labour.costs_{w,h}
\end{aligned}
\end{equation}

```{r crop sales net income}

crop_sales_net_income = full_join(cropsales_income, all_costs, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) %>% 
  ungroup() %>% 
  mutate(across(contains('cost'), ~.*(-1))) %>% 
  select(-cropsales_income, -chemicals_net_cost_defl, -seeds_purch_cost_defl, -tractor_cost_defl, -tot_labour_cost_defl,-trans_cost_defl) %>% #-tot_labour_cost_defl
  ungroup() %>% 
  mutate(crop_sales_net_income_defl = rowSums(select(.,6:7), na.rm = T)) 
  

```



```{r display distribution of total crop sales net income deflated}
# deflated measure - net fin income
pander(summary(subset(crop_sales_net_income, wave==1)$crop_sales_net_income_defl), caption = "crop sales net income in w.1 (in cedis)")
pander(summary(subset(crop_sales_net_income, wave==2)$crop_sales_net_income_defl), caption = "crop sales net income in w.2 (in 2009 cedis)")
```

\subsection{Total Net Income}
\par 
We can now compute the total net income as the sum of all net incomes computed above: 
\begin{equation}
\begin{aligned}
total.net.income_{w,h} = &net.crop.income_{w,h} \\
+ & main.occupation.income_{w,h}\\
+ & secondary.occupation.income_{w,h}\\
+ & non.farm.enterprise.net.income_{w,h}\\
+ & animal.net.income_{w,h}\\
+ & financial.net.income_{w,h}
\end{aligned}
\end{equation}

```{r Gather all net incomes together}

all_net_incomes = full_join(crop_sales_net_income, mainoccupation_income , by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes = full_join(all_net_incomes, secoccupation_income, by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes = full_join(all_net_incomes, nonfarm_enterprise, by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes = full_join(all_net_incomes, animal_income, by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes = full_join(all_net_incomes, financial_income, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) %>% 
  group_by(wave, hhno) %>% 
  mutate(across(contains('income'), ~sum(.,na.rm=T))) %>% 
  filter(!duplicated(hhno)) %>% 
  ungroup() %>% 
  select(wave, id1, id2, id3, hhno, contains('defl')) %>% 
    mutate(across(contains('defl'), ~replace_na(.,0))) %>% 
  rowwise() %>% 
    mutate(total_net_income = sum(crop_sales_net_income_defl,mainocc_income_annual_defl,secocc_income_annual_defl,profits_annual_defl,anim_income_defl,gross_finincome_defl, na.rm = T))




```



```{r display distribution of total net income deflated}
# deflated measure - net fin income
pander(summary(subset(all_net_incomes, wave==1)$total_net_income), caption = "net income in w.1 (in cedis)")
pander(summary(subset(all_net_incomes, wave==2)$total_net_income), caption = "net income in w.2 (in 2009 cedis)")
```



















\newpage
\section{Market value of production}
\begin{center}
Crop Production
\end{center}
\par 
Here we attempt to assign a value on the produced crops to be used for the productivity measure. 


\subsection{Market Value of Production (not sales)}
\par 
We need to derive the market value of produced quantity in wave 1. This raises two problems. First, respondents report quantity in different units of measurement, as a result we do not have everything in one unit to allow for comparisons. Second, we do not have prices per unit, as we only have the estimated market value of the quantity harvested (q.82) which is first a rough estimate of the respondent and is rarely answered. We also have q.83 what is the total revenue from harvested sold - however, we do not know what part of harvest did end up to the market. 
\par 
In order to address the first problem we we proceed as follows:
\begin{enumerate}
\item Employ unitcode for wave 1 by Andre. This is a conversion table from several of measurement units (e.g. American tin, Basket, Bundle etc) appearing in the survey, to kgr. It is ea-crop-unit specific and expresses kgr/'reported measurement unit' values. \footnote{\textit{there is an inconsitency here - because there is a column in the dataset that is called kilograms - and this has values other than 1}}. 
\par 
We also utilize the conversion value (kgr/unit) as ea-crop specific. For example a 'bowl' of bambara beans weight ranges from 2.50 to 3.30 kgr across Ghana according to the conversion table. We maintain this variation accross areas, because (i) other kinds of the same product harvested in different areas might weight more and (ii) different areas might have a different benchmark for the measurement unit (bowl here).   
\par 
In order to exploit this information as much as possible and to capture most of the area-crop-unit combinations that can arise in the dataset, we generalize at (i) district (ii) regional and (iii) country level. In case of missing values for an ea we take the average conversion across all available EAs in the same district - we generalize in the same region and lastly in the country. To contain the variation for the same product and unit that is present in the dataset - we truncate first using the interquartile range of the sample. 
\par 
We end up with each conversion rate having a unique \textit{ea-crop-unit} upon which we merge it to the crop-production data for wave 1 from the survey. 
\end{enumerate}
```{r Revenues wave 1}
# Address problem no 1: insert the unitcode_w1 from Andre's data: 
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#############################                                    ################################################
#############################             WAVE 1                 ################################################
#############################                                    ################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################

#################################################################################################################
############               Crop1 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1. 
crop_prod = read.dta("./S4AV1.dta") %>%
  mutate(id1= as.numeric(id1)) %>% 
  mutate(id2= as.numeric(id2)) %>% 
  mutate(id3= as.numeric(id3)) %>%
  mutate(hhno = as.numeric(hhno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>% 
  filter(!is.na(plot_id))

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity 
# for all 5 crops reported for each plot.
crop_prod_w1 = crop_prod %>% 
  select(id1, id2, id3, hhno, s4av1_plotno, 
         s4v_a80i, s4v_a81i, s4v_a81ii) %>%     # for crop 1
        #s4v_a88i, s4v_a89i, s4v_a89ii) %>%     # for crop 2
        #s4v_a96i, s4v_a97i, s4v_a97ii,         # for crop 3
        #s4v_a104i, s4v_a105i, s4v_a105ii,      # for crop 4
        #s4v_a112i, s4v_a113i, s4v_a113ii) %>%  # for crop 5
  filter(!is.na(s4v_a81ii)) %>% filter(!is.na(s4v_a80i)) %>%  # i filter out plots that do not have either the crop or the unit- cause nothing to learn there. 
  mutate(plot_id = as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>% 
  mutate(ea_crop_unit_id = paste(id3, s4v_a80i,s4v_a81ii, sep=".")) %>% 
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, s4v_a80i,ea_crop_unit_id, s4v_a81ii,s4v_a81i) #,s4v_a88i, s4v_a89ii,s4v_a89i)

crop_prod_w1 = crop_prod_w1[,c(1:5,9,6:8)] # note here that I also leave out the plot no since I have the plot id. 


#################################################################################################################
#############               Unit Conversion for Wave 1         ##################################################
#################################################################################################################



# The following dataframe includes for each EA for each Crop type for each Unit of Quantity Measurement transformation rates to kgr. 
unitcon_W1 = read_dta("./unitcon_W1.dta")

# Below I do the following. i take the unitcon_W1 and in particular the 23 columns of all units included and 
# I transpose them into rows. In this way, we have for each EA and crop all the units in different rows for each unit.
# From 1,295 rows we end up to 1,295*23 = 29,785 rows. I do this in order to generate a unique EA.id-Crop.id-Unit.id  
# and be able to match it to the EA.id-Crop.id-Unit.id with the production quantity in the production of wave 1 data frame. 
# I am expecting very few to match since the unitcon_W1 is very scarce table, however, then we will be able to 
# expand at the district/region and country level conversion. 
conversion_table_reshaped = unitcon_W1 %>% 
  gather(c(9:31), key="unit", value="unit_in_kgr") # transpose the 23 unit columns into rows. 

# rename the "s5" column to "crop_code"
colnames(conversion_table_reshaped)[colnames(conversion_table_reshaped)=="s5"]="crop_code"
# rename the "s5a_1" column to "crop_code"
colnames(conversion_table_reshaped)[colnames(conversion_table_reshaped)=="s5a_1"]="crop_name"

# # The conversion table reshaped is very scarce - since it has many NAs values. 
# summary(conversion_table_reshaped$unit_in_kgr) # From here it shows that we have transformation rates for 1,609 EA/Crop/Unit specific items. Note however, that some of them coincide. 


# Below I assign to each unit appearing in the table the corresponding unit name from the column details. 
conversion_table = conversion_table_reshaped %>% 
  mutate(unit_name = case_when(
    unit=="s5a_a"~"American Tin",
    unit=="s5a_b"~"Balls",
    unit=="s5a_c"~"Basket",
    unit=="s5a_d"~"Bowl",
    unit=="s5a_e"~"Box", 
    unit=="s5a_f"~"Bucket", 
    unit=="s5a_g"~"Bunch", 
    unit=="s5a_h"~"Bundle",
    unit=="s5a_i"~"Crate", 
    unit=="s5a_j"~"Dozen",
    unit=="s5a_k"~"Fingers",
    unit=="s5a_l"~"Fruits", 
    unit=="s5a_m"~"Kgr", 
    unit=="s5a_n"~"Margarine Tin",
    unit=="s5a_o"~"Maxi Bag",
    unit=="s5a_p"~"Mini Bag", 
    unit=="s5a_q"~"Nut", 
    unit=="s5a_r"~"Pair",
    unit=="s5a_s"~"Pieces",
    unit=="s5a_t"~"Singles",
    unit=="s5a_u"~"Stick", 
    unit=="s5a_v"~"Tonne", 
    unit=="s5a_w"~"Tubers",
    TRUE ~ "NA"))

# Below I assign to each unit appearing in the table the corresponding unit code from the Code-Book.

conversion_table = conversion_table %>% 
  mutate(unit_code = case_when(
    unit=="s5a_a"~2,
    unit=="s5a_b"~27,
    unit=="s5a_c"~4,
    unit=="s5a_d"~6,
    unit=="s5a_e"~7, 
    unit=="s5a_f"~29, 
    unit=="s5a_g"~8, 
    unit=="s5a_h"~9,
    unit=="s5a_i"~30, 
    unit=="s5a_j"~31,
    unit=="s5a_k"~11,
    unit=="s5a_l"~12, 
    unit=="s5a_m"~14, 
    unit=="s5a_n"~17,
    unit=="s5a_o"~18,
    unit=="s5a_p"~19, 
    unit=="s5a_q"~20, 
    unit=="s5a_r"~33,
    unit=="s5a_s"~34,
    unit=="s5a_t"~37,
    unit=="s5a_u"~23, 
    unit=="s5a_v"~24, 
    unit=="s5a_w"~26,                          
    TRUE ~ as.numeric(NA)))

# I dont need any more the unit column - since I have both the name of the unit and its code. 
conversion_table = conversion_table %>% 
  select(-unit)

# Since we know that the conversion table is EA/Crop/Unit specific I create a unique id for each entry 
# this id combines the EA id the Crop Code and the Unit Code. I have transformed the table in such a way that the 
# each row corresponds to a EA-Crop-Unit id. 
# The EA/Crop/Unit id is the narrowest level we can go with the data in hand. However, in order to obtain transformation
# rates for as many plots as possible, I perform three generalisations. 
# Gen.1: District/Crop/Unit id - where for the same crop and unit if there is a NA in the EA, I add the district's average. 
#        By applying this, we assume that a maxi bag of cassawa weighs the same within each district. 
# Gen.2: Region/Crop/Unit id - where for the same crop and unit if there is a NA in the EA and the district, I add the 
#        region's average. By applying this, we assume that a maxi bag of cassawa weighs the same within region. 
# Gen.3: Crop/Unit id - where for the same crop and unit if there is a NA in the EA, the District and the Region, I add the 
#        country's average. By applying this, we assume taht a maxi bag of cassawa weight the same all across Ghana. 

conversion_table = conversion_table %>% 
  filter(!is.na(crop_code)) %>% 
  mutate(ea_no=as.numeric(ea_no)) %>%           # turn all ea codes in numeric
  mutate(district=as.numeric(district)) %>%     # turn all district codes in numeric
  mutate(reg=as.numeric(reg)) %>%               # turn all region codes in numeric
  mutate(crop_code = as.numeric(crop_code)) %>%               # turn all crop codes in numeric
  mutate(unit_code=as.numeric(unit_code)) %>%   # turn all unit codes in numeric
  mutate(ea_crop_unit_id = paste(ea_no, crop_code, unit_code, sep=".")) %>%  # create the ea_crop_unit_id
  mutate(dist_crop_unit_id = paste(district, crop_code, unit_code, sep=".")) %>% # create the district_crop_unit_id
  mutate(reg_crop_unit_id = paste(reg, crop_code, unit_code, sep=".")) %>% # create the region_crop_unit_id
  mutate(crop_unit_id = paste(crop_code, unit_code, sep=".")) %>%  # create the country's crop_unit_id
  filter(!is.na(ea_crop_unit_id)) %>%           # filter out all NA values at the ea unit crop id those come from the missing values of s5 (crop_code) so those 805 entries are entirely uselless even at the district level  
  select(regname, reg, district, ea_no, ctycode, crop_code, crop_name, unit_name, unit_code, ea_crop_unit_id, dist_crop_unit_id, reg_crop_unit_id, crop_unit_id ,unit_in_kgr) 


# Note that so far you have the unit_in_kgr that is the conversion rate of the measurement unit for the crop in the EA as specified by the EA_crop_unit_id. 
# First I am renaming this unit_in_kgr to unit_in_kgr_ea to denote that this corresponds to a specific EA. 
colnames(conversion_table)[colnames(conversion_table)=="unit_in_kgr"]="unit_in_kgr_ea"

# Second, I am going to build at this point the "unit_in_kgr_dist". Which is the mean of all unit_in_kgr_ea that belong to the same district. In this way I 
# building a conversion rate at the district level which takes advantage of all available data - even those that will not be matched when I merge the conversion 
# table to the  production data - what I did originally is to derive the mean after I merged - however, in this way I missed all the data that were not mathced at the EA level. 
conversion_table = conversion_table %>%  
                   ungroup() %>% 
                   group_by(dist_crop_unit_id) %>%  
                    mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_ea)~mean(subset(unit_in_kgr_ea, unit_in_kgr_ea>=quantile(unit_in_kgr_ea, 0.25,na.rm = T)-2*((quantile(unit_in_kgr_ea, 0.75,na.rm = T)-                                                                                                                     quantile(unit_in_kgr_ea, 0.25,na.rm = T))) & unit_in_kgr_ea<=quantile(unit_in_kgr_ea, 0.75,na.rm = T)+2*((quantile(unit_in_kgr_ea, 0.75,na.rm = T)-                                   quantile(unit_in_kgr_ea, 0.25,na.rm = T)))), na.rm = T),
    TRUE ~ as.numeric(unit_in_kgr_ea)))  %>% 
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist)) 

# Third, I am doing the same thing at the regional level. 
conversion_table = conversion_table %>%  
  ungroup() %>% 
  group_by(reg_crop_unit_id) %>%  
  mutate(unit_in_kgr_reg = case_when(
    is.na(unit_in_kgr_dist)~mean(subset(unit_in_kgr_dist, unit_in_kgr_dist>=quantile(unit_in_kgr_dist, 0.25,na.rm = T)-2*((quantile(unit_in_kgr_dist, 0.75,na.rm = T)-
                                                                                                                             quantile(unit_in_kgr_dist, 0.25,na.rm = T))) & unit_in_kgr_dist<=quantile(unit_in_kgr_dist, 0.75,na.rm = T)+2*((quantile(unit_in_kgr_dist, 0.75,na.rm = T)-
                                                                                                                                                                                                                                               quantile(unit_in_kgr_dist, 0.25,na.rm = T)))), na.rm = T),
    TRUE ~ as.numeric(unit_in_kgr_dist)))  %>% 
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg)) 

# Fourth, I am doing the same thing at the ghana level. 
conversion_table = conversion_table %>%  
  ungroup() %>% 
  group_by(crop_unit_id) %>%  
  mutate(unit_in_kgr_ghana = case_when(
    is.na(unit_in_kgr_reg)~mean(subset(unit_in_kgr_reg, unit_in_kgr_reg>=quantile(unit_in_kgr_reg, 0.25,na.rm = T)-2*((quantile(unit_in_kgr_reg, 0.75,na.rm = T)-
                                                                                                                         quantile(unit_in_kgr_reg, 0.25,na.rm = T))) & unit_in_kgr_reg<=quantile(unit_in_kgr_reg, 0.75,na.rm = T)+2*((quantile(unit_in_kgr_reg, 0.75,na.rm = T)-
                                                                                                                                                                                                                                        quantile(unit_in_kgr_reg, 0.25,na.rm = T)))), na.rm = T),
    TRUE ~ as.numeric(unit_in_kgr_reg)))  %>% 
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana)) 

# Check how many filled up values you get with the generalisations:
# summary(conversion_table$unit_in_kgr_ea)      # NAs: 27,371 --> you get 28,980-27,371 = 1609 unit_in_kgr_ea
# summary(conversion_table$unit_in_kgr_dist)    # 5369 unit_in_kgr_dist
# summary(conversion_table$unit_in_kgr_reg)     # 11959 unit_in_kgr_reg
# summary(conversion_table$unit_in_kgr_ghana)   # 24398 unit_in_kgr_ghana

# Note that in the conversion table there are multiple instances of the same ea/crop/unit codes - this is because in the original conversion table they recorded multiple 
# transformations in kgr for the same ea the same crop and the same unit. For example in ea: 2 , crop: bananas, unit: maxi bag one instance was 100 kgr, the second 102 kgr 
# the third is 101.5. As a result I have three entries with the same ea-crop-unit id. For those entries I take the mean.

coversion_table_final = conversion_table %>% ### Important Note: The "conversion_table_final" is the version of the conversion that you are using to merge it with the production data. 
  group_by(ea_crop_unit_id) %>% 
  mutate(unit_in_kgr_ea = mean(unit_in_kgr_ea,na.rm = T)) %>% # If there are multiple ea_crop_unit_ids I take the mean of it and not the actual value
  filter(!duplicated(ea_crop_unit_id)) %>%  # I am only filtering out the duplicated EA.Crop.Unit codes. - So I m left with only unique EA.Crop.Unit ids. 
  mutate(unit_in_kgr_ea = ifelse(!is.finite(unit_in_kgr_ea), as.numeric(NA), unit_in_kgr_ea)) %>% 
  ungroup() %>% 
  mutate(unit_in_kgr_ea = ifelse(!is.finite(unit_in_kgr_ea), as.numeric(NA),unit_in_kgr_ea ))
# list(unique(coversion_table_final$ea_crop_unit_id))
# list(unique(coversion_table_final$dist_crop_unit_id))
# list(unique(coversion_table_final$reg_crop_unit_id))

# # Here I do something on the side: 
# # isolate the universal categories that can be applied nationally. (These are the fruits and the pieces and kgr) Note that in case in the production dataframe 
# # there is an entry 3.000 and the measurement unit is Fruits then I can use the information in the conversion table about each fruit in kgr. Same for 
# # pieces. The distinct characteristic of that is that everywhere in Ghana the onion weighs the same. 
# 
# conversion_table_uni_values = coversion_table_final %>% 
#                               filter(unit_code == c(12, 14, 34))
# list(unique(conversion_table_uni_values$crop_name))
# list(unique(conversion_table_uni_values$crop_code)) # Essentially those are the crops for which you have information in "kgr per crop" and not in "kgr per unit per crop" as the rest of the unit measures.
```




```{r Revenues wave 1 contd}
#################################################################################################################
#######            Merge production of wave 1 with conversion table final        ################################
#################################################################################################################

crop_prod_w1_conv_tbl = left_join(crop_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea", "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 3,752 from a total of 4,729 entries - this means that 977 entries have non-NAs number



# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values 
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables 
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254) 
# str(crop_prod_w1_conv_tbl$dist_crop_unit_id)
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(id2 = as.numeric(id2)) %>%
  mutate(id3 = as.numeric(id3)) %>%
  mutate(dist_crop_unit_id = case_when(                                                  # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a80i, s4v_a81ii, sep="."),   # made from the data of production. 
    TRUE ~ dist_crop_unit_id)) %>% 
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a80i, s4v_a81ii, sep="."),    # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a80i, s4v_a81ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to 
# the same district - if it is filled up I leave it as it is. 
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  group_by(dist_crop_unit_id) %>% 
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>% 
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level. 
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  group_by(reg_crop_unit_id) %>% 
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>% 
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level. 
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  group_by(crop_unit_id) %>% 
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>% 
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# # Check how many fill ups you achieve. 
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However, 
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to 
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower 
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>% 
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>% 
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available. 

```

\par 
Note that we manage to do a good job in translating different units of measurement in kgr, however, there is some variation in the translated kgr. Take for example a 'Maxi Bag' of groundnut. In the production data from the survey there are 256 plots growing groundnut and reporting quantity in maxi bags. If we use the unit conversion we manage to match 46 out of 256. 

```{r maxi bag groundnut ea}
x = freq(subset(crop_prod_w1_conv_tbl, crop_unit_id =="14.18")$unit_in_kgr_ea)
pander(x, caption = 'kgr of maxi bag of groundut w/o generalisations')
```

\par 
Implementing the generalizations at the district/regional/country level we manage to match all 256 instances. However, notice that we get outlier values such as 150 kgr. This comes from the original conversion table of Andre, in which there were instances of respondents reporting 160 kgr weight for a maxi bag of groundnut - by taking the mean of truncated sample of those conversation rates we reduce it but we do not eliminate it. Notice that this value was not matched (through the ea-crop-unit id) to the production data - that is why it does not appear here however this information affects other ea's in the district that appear in the production data - that is why we have 2 instances of 150 kgr here. Moreover, it is not 160 because we take the mean of ea-crop-unit conversation rates and other lower values decrease it. 

```{r maxi bag groundnut ghana}
x = freq(subset(crop_prod_w1_conv_tbl, crop_unit_id =="14.18")$unit_in_kgr_ghana)
pander(x, caption = 'kgr of maxi bag of groundut w/ generalisations')
```

\par 
In order to address the second problem of finding a price per unit for the total production per plot, we proceed as follows
\begin{enumerate}
\item We utilize price data from Andre (cropprice-W1), a table of 1,516 ea-crop-unit specific prices after harvest. We again do the same generalization on this table. For those entires that do not have a ea-crop-unit specific price we substitute with the mean crop-unit price at the district, regional and country level.
\par 
We then proceed and merge the price data with the production per plot data from the survey and we perform the same generalisations at the district/regional/country level. 
\end{enumerate}


```{r Reveneues wave 1 contd 2}
##############################################################################################################################################
########################                      Crop Prices Wave 1              ################################################################
##############################################################################################################################################


crop_price = read_dta("./cropprice_W1.dta")
# Note that this table has the price per unit for EA-Crop-Unit specific items.

# Select only the relevant information.
crop_price = crop_price %>%
  select(regname, reg, district, ea_no, s4_1, s4_2, s4_6, s4_5i, s4_5ii) %>% 
  mutate(reg = as.numeric(reg)) %>% 
  mutate(district = as.numeric(district)) %>% 
  mutate(ea_no = as.numeric(ea_no)) %>% 
  mutate(s4_2 = as.numeric(s4_2)) %>% 
  mutate(s4_6 = as.numeric(s4_6)) %>% 
  mutate(s4_5i = as.numeric(s4_5i)) %>% 
  mutate(s4_5ii = as.numeric(s4_5ii))


# rename relevant columns

colnames(crop_price)[colnames(crop_price)=="s4_1"]="crop_name"
colnames(crop_price)[colnames(crop_price)=="s4_2"]="crop_code"
colnames(crop_price)[colnames(crop_price)=="s4_6"]="unit_code"
colnames(crop_price)[colnames(crop_price)=="s4_5i"]="crop_price_ced"
colnames(crop_price)[colnames(crop_price)=="s4_5ii"]="crop_price_pes"

# 1. Add the cedis and pesewas to get one price.
crop_price = crop_price %>%
  mutate(crop_price_pes_in_cedis = crop_price_pes*0.01) %>%
  rowwise() %>%
  mutate(price = sum(crop_price_ced,crop_price_pes_in_cedis, na.rm = T)) %>%
  select(-crop_price_ced, -crop_price_pes, -crop_price_pes_in_cedis) %>% 
  filter(!is.na(crop_code))

# 2. Create the EA-Crop-Unit id
crop_price = crop_price %>%
  filter(!is.na(ea_no)) %>% filter(!is.na(crop_code)) %>% filter(!is.na(unit_code)) %>% 
  mutate(ea_crop_unit_id = paste(ea_no, crop_code, unit_code, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id))  # those that do not have an ea_crop_unit_id are those because of the lack of crops hence they are useless.


crop_price = crop_price %>%
  group_by(ea_crop_unit_id) %>%
  add_tally()


# In particular:
# 192 EA_Crop_Unit_ids appear 2 times - we have the same info twice.
# 48  EA_Crop_Unit_ids appear 3 times
# 12  EA_Crop_Unit_ids appear 4 times
# For all those I substitute by the mean and keep the EA_Crop_Unit_id only once.


crop_price_final = crop_price %>%
  group_by(ea_crop_unit_id) %>%
  mutate(price = mean(price, na.rm = T)) %>%
  filter(!duplicated(ea_crop_unit_id)) %>%
  select(-n)
# Now I do the same as I did in the conversion table. I create the district_crop_unit_id reg_crop_unit_id and ghana_crop_unit_id and create
# the price_dist, price_reg and price ghana.

crop_price_final = crop_price_final %>%
  mutate(dist_crop_unit_id = paste(district, crop_code, unit_code, sep=".")) %>% # create the district_crop_unit_id
  mutate(reg_crop_unit_id = paste(reg, crop_code, unit_code, sep=".")) %>% # create the region_crop_unit_id
  mutate(crop_unit_id = paste(crop_code, unit_code, sep="."))  # create the country's crop_unit_id


colnames(crop_price_final)[colnames(crop_price_final)=="price"]="price_ea"


# Second, I am going to build at this point the "price_dist". Which is the mean of all price_ea that belong to the same district. In this way I
# building a price at the district level which takes advantage of all available data - even those that will not be matched when I merge the price
# table to the  production data
crop_price_final = crop_price_final %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = ifelse(!is.na(dist_crop_unit_id), mean(price_ea, na.rm = T), as.numeric(NA))) # You re going to keep the price_ea if it exists later after the merging.


# Third, I am doing the same thing at the regional level.
crop_price_final = crop_price_final %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = mean(price_dist, na.rm = T)) # You re going to keep the price_ea if it exists later after the merging.

# Fourth, I am doing the same thing at the ghana level.
crop_price_final = crop_price_final %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = mean(price_reg, na.rm = T)) # You re going to keep the price_ea if it exists later after the merging.


crop_price_final = crop_price_final[,c(1:7, 9:12, 8, 13:15)]


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop prices   #################################################
########################################################################################################################################


production_conversion_prices = left_join(crop_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production_conversion_prices$price_ea)
# summary(production_conversion_prices$price_dist)
# summary(production_conversion_prices$price_reg)
# summary(production_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production_conversion_prices$price_ea)
# summary(production_conversion_prices$price_dist)
# summary(production_conversion_prices$price_reg)
# summary(production_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production_conversion_prices_final = production_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a80i, s4v_a81i, s4v_a81ii, unit_in_kgr_ghana, price_ghana)

colnames(production_conversion_prices_final)[colnames(production_conversion_prices_final)=="s4v_a80i"]="crop_code"
colnames(production_conversion_prices_final)[colnames(production_conversion_prices_final)=="s4v_a81i"]="quantity_harvested"
colnames(production_conversion_prices_final)[colnames(production_conversion_prices_final)=="s4v_a81ii"]="unit_code"

production_conversion_prices_final = production_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 4,092 plots out of 4,729 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop_code, quantity_harvested, unit_code,
         unit_in_kgr_ghana, price_ghana)

production_w1c1.orig = production_conversion_prices_final %>%
  mutate(ea_crop1_unit = paste(id3, crop_code, unit_code, sep=".")) %>%
  mutate(quantity1_in_kgr = quantity_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c1 = quantity_harvested*price_ghana) 
  
production_w1c1 = production_w1c1.orig %>% 
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop1_unit, quantity_harvested, quantity1_in_kgr, value_w1c1)
```

\par 
With the raw price data from Andre we manage to match the price for a maxi bag of groundnuts across Ghana for 38 out of 256 instances. Notice the considerable variation in prices for the same unit of the same good across Ghana. In the original dataset the price for a maxi bag of Groundnut ranges from 10 cedis to 130 cedis (in the table below the 10 cedis price was matched to a plot from production data, while the 130 cedis was not - however, it is taken into account to the mean prices substituting for not matched plot data).  

```{r maxi bag groundnut price ea}
x = freq(subset(production_conversion_prices, crop_unit_id =="14.18")$price_ea)
pander(x, caption = 'Per unit price of a maxi bag of groundut w/o generalisations')
```

\par 
Via generalizing at the district/regional/country level we manage to find a per unit price for all 256 instances of a maxi bag of groundnut. 
```{r maxi bag groundnut price Ghana}
x = freq(subset(production_conversion_prices, crop_unit_id =="14.18")$price_ghana)
pander(x, caption = 'Per unit price of a maxi bag of groundut w/ generalisations')
```


\par 
So finally we can derive a value of the production of maxi bags of groundnut.
```{r maxi bag groundnut value ea}
pander(summary(subset(production_w1c1.orig, crop_code == '14' & unit_code == "18")$quantity_harvested), caption = 'Number of maxi bags of groundnut produced in each plot')
pander(summary(subset(production_w1c1.orig, crop_code == '14' & unit_code == "18")$price_ghana), caption = "Range of prices of maxi bag of groundnut")
pander(summary(subset(production_w1c1.orig, crop_code == '14' & unit_code == "18")$value_w1c1), caption = 'Corresponding value in cedis')
```


\par 
These calculations are repeated for all 5 crops recorded in each plot and for both major and minor seasons. 


```{r Revenues wave 1 contd 3}
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
####################################                Same for Crop 2                       ########################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################

# Note so far I have constructed the production_conversion_prices_final however, I have only used production data referring to crop 1
# However, in each plot there are more than one crop grown in different times. And we have data on those.
# Moreover, the remaining crops are not the same - for example in one plot the main crop was Cassava but during the season the farmer also
# grew some Maize.
# Therefore, I will repeat certain parts of the code above to include total production.
# Fortunately the conversion table and the price data do not need to be repeated - only the merging parts.


#################################################################################################################
############               Crop2 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop2_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av1_plotno,
         #s4v_a80i, s4v_a81i, s4v_a81ii) %>%     # for crop 1
         s4v_a88i, s4v_a89i, s4v_a89ii) %>%      # for crop 2
  #s4v_a96i, s4v_a97i, s4v_a97ii,         # for crop 3
  #s4v_a104i, s4v_a105i, s4v_a105ii,      # for crop 4
  #s4v_a112i, s4v_a113i, s4v_a113ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a88i,s4v_a89ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a88i, s4v_a89ii,s4v_a89i)


# crop_prod_w1 = crop_prod_w1[,c(1:5,9,6:8)] # note here that I also leave out the plot no since I have the plot id.
#crop_prod = crop_prod[,c(1:4, 21, 6:20)]



#################################################################################################################
#######            Merge production of wave 1 Crop 2 with conversion table final        #########################
#################################################################################################################

crop2_prod_w1_conv_tbl = left_join(crop2_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 3,752 from a total of 4,729 entries - this means that 977 entries have non-NAs number



# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop2_prod_w1_conv_tbl$dist_crop_unit_id)
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a88i, s4v_a89ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a88i, s4v_a89ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a88i, s4v_a89ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop2 prices   ################################################
########################################################################################################################################


production2_conversion_prices = left_join(crop2_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production2_conversion_prices$price_ea)
# summary(production2_conversion_prices$price_dist)
# summary(production2_conversion_prices$price_reg)
# summary(production2_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production2_conversion_prices$price_ea)
# summary(production2_conversion_prices$price_dist)
# summary(production2_conversion_prices$price_reg)
# summary(production2_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production2_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production2_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production2_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production2_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production2_conversion_prices_final = production2_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a88i, s4v_a89ii, s4v_a89i, unit_in_kgr_ghana, price_ghana)

colnames(production2_conversion_prices_final)[colnames(production2_conversion_prices_final)=="s4v_a88i"]="crop2_code"
colnames(production2_conversion_prices_final)[colnames(production2_conversion_prices_final)=="s4v_a89i"]="quantity2_harvested"
colnames(production2_conversion_prices_final)[colnames(production2_conversion_prices_final)=="s4v_a89ii"]="unit2_code"

production2_conversion_prices_final = production2_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 1956 plots out of 2382 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop2_code, quantity2_harvested, unit2_code,
         unit_in_kgr_ghana, price_ghana)

production_w1c2 = production2_conversion_prices_final %>%
  mutate(ea_crop2_unit = paste(id3, crop2_code, unit2_code, sep=".")) %>%
  mutate(quantity2_in_kgr = quantity2_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c2 = quantity2_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop2_unit, quantity2_harvested, quantity2_in_kgr, value_w1c2)

# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ####################################                Same for Crop 3                       ########################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################



#################################################################################################################
############               Crop3 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop3_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av1_plotno,
         #s4v_a80i, s4v_a81i, s4v_a81ii) %>%     # for crop 1
         #s4v_a88i, s4v_a89i, s4v_a89ii) %>%     # for crop 2
         s4v_a96i, s4v_a97i, s4v_a97ii) %>%      # for crop 3
  #s4v_a104i, s4v_a105i, s4v_a105ii,      # for crop 4
  #s4v_a112i, s4v_a113i, s4v_a113ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a96i,s4v_a97ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a96i, s4v_a97ii,s4v_a97i)


# crop_prod_w1 = crop_prod_w1[,c(1:5,9,6:8)] # note here that I also leave out the plot no since I have the plot id.
#crop_prod = crop_prod[,c(1:4, 21, 6:20)]


#################################################################################################################
#######            Merge production of wave 1 Crop 3 with conversion table final        #########################
#################################################################################################################

crop3_prod_w1_conv_tbl = left_join(crop3_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 987 from a total of 1,223 entries


# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

str(crop3_prod_w1_conv_tbl$dist_crop_unit_id)
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a96i, s4v_a97ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a96i, s4v_a97ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a96i, s4v_a97ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop3 prices   ################################################
########################################################################################################################################


production3_conversion_prices = left_join(crop3_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production3_conversion_prices$price_ea)
# summary(production3_conversion_prices$price_dist)
# summary(production3_conversion_prices$price_reg)
# summary(production3_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production3_conversion_prices$price_ea)
# summary(production3_conversion_prices$price_dist)
# summary(production3_conversion_prices$price_reg)
# summary(production3_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production3_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production3_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production3_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production3_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production3_conversion_prices_final = production3_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a96i, s4v_a97ii, s4v_a97i, unit_in_kgr_ghana, price_ghana)

colnames(production3_conversion_prices_final)[colnames(production3_conversion_prices_final)=="s4v_a96i"]="crop3_code"
colnames(production3_conversion_prices_final)[colnames(production3_conversion_prices_final)=="s4v_a97i"]="quantity3_harvested"
colnames(production3_conversion_prices_final)[colnames(production3_conversion_prices_final)=="s4v_a97ii"]="unit3_code"

production3_conversion_prices_final = production3_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 862 plots out of 1323 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop3_code, quantity3_harvested, unit3_code,
         unit_in_kgr_ghana, price_ghana)


production_w1c3 = production3_conversion_prices_final %>%
  mutate(ea_crop3_unit = paste(id3, crop3_code, unit3_code, sep=".")) %>%
  mutate(quantity3_in_kgr = quantity3_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c3 = quantity3_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop3_unit, quantity3_harvested, quantity3_in_kgr, value_w1c3)

##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
####################################                Same for Crop 4                       ########################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################



#################################################################################################################
############               Crop4 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop4_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av1_plotno,
         #s4v_a80i, s4v_a81i, s4v_a81ii) %>%     # for crop 1
         #s4v_a88i, s4v_a89i, s4v_a89ii) %>%     # for crop 2
         #s4v_a96i, s4v_a97i, s4v_a97ii) %>%     # for crop 3
         s4v_a104i, s4v_a105i, s4v_a105ii) %>%   # for crop 4
  #s4v_a112i, s4v_a113i, s4v_a113ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a104i,s4v_a105ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a104i, s4v_a105ii,s4v_a105i)


#################################################################################################################
#######            Merge production of wave 1 Crop 4 with conversion table final        #########################
#################################################################################################################

crop4_prod_w1_conv_tbl = left_join(crop4_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 493 from a total of 581 entries


# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop4_prod_w1_conv_tbl$dist_crop_unit_id)
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a104i, s4v_a105ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a104i, s4v_a105ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a104i, s4v_a105ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.

########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop4 prices   ################################################
########################################################################################################################################


production4_conversion_prices = left_join(crop4_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production4_conversion_prices$price_ea)
# summary(production4_conversion_prices$price_dist)
# summary(production4_conversion_prices$price_reg)
# summary(production4_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production4_conversion_prices$price_ea)
# summary(production4_conversion_prices$price_dist)
# summary(production4_conversion_prices$price_reg)
# summary(production4_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production4_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production4_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production4_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production4_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production4_conversion_prices_final = production4_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a104i, s4v_a105ii, s4v_a105i, unit_in_kgr_ghana, price_ghana)

colnames(production4_conversion_prices_final)[colnames(production4_conversion_prices_final)=="s4v_a104i"]="crop4_code"
colnames(production4_conversion_prices_final)[colnames(production4_conversion_prices_final)=="s4v_a105i"]="quantity4_harvested"
colnames(production4_conversion_prices_final)[colnames(production4_conversion_prices_final)=="s4v_a105ii"]="unit4_code"

production4_conversion_prices_final = production4_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 298 plots out of 581 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop4_code, quantity4_harvested, unit4_code,
         unit_in_kgr_ghana, price_ghana)

production_w1c4 = production4_conversion_prices_final %>%
  mutate(ea_crop4_unit = paste(id3, crop4_code, unit4_code, sep=".")) %>%
  mutate(quantity4_in_kgr = quantity4_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c4 = quantity4_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop4_unit, quantity4_harvested, quantity4_in_kgr, value_w1c4)

##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
####################################                Same for Crop 5                       ########################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################



#################################################################################################################
############               Crop5 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop5_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av1_plotno,
         #s4v_a80i, s4v_a81i, s4v_a81ii) %>%     # for crop 1
         #s4v_a88i, s4v_a89i, s4v_a89ii) %>%     # for crop 2
         #s4v_a96i, s4v_a97i, s4v_a97ii) %>%     # for crop 3
         #s4v_a104i, s4v_a105i, s4v_a105ii) %>%   # for crop 4
         s4v_a112i, s4v_a113i, s4v_a113ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a112i,s4v_a113ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a112i, s4v_a113ii,s4v_a113i)

#################################################################################################################
#######            Merge production of wave 1 Crop 5 with conversion table final        #########################
#################################################################################################################

crop5_prod_w1_conv_tbl = left_join(crop5_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 493 from a total of 581 entries


# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop5_prod_w1_conv_tbl$dist_crop_unit_id)
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a112i, s4v_a113ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a112i, s4v_a113ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a112i, s4v_a113ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop5 prices   ################################################
########################################################################################################################################


production5_conversion_prices = left_join(crop5_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production5_conversion_prices$price_ea)
# summary(production5_conversion_prices$price_dist)
# summary(production5_conversion_prices$price_reg)
# summary(production5_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production5_conversion_prices$price_ea)
# summary(production5_conversion_prices$price_dist)
# summary(production5_conversion_prices$price_reg)
# summary(production5_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# # Check what you managed to fill up
# summary(production5_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production5_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production5_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production5_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production5_conversion_prices_final = production5_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a112i, s4v_a113ii, s4v_a113i, unit_in_kgr_ghana, price_ghana)

colnames(production5_conversion_prices_final)[colnames(production5_conversion_prices_final)=="s4v_a112i"]="crop5_code"
colnames(production5_conversion_prices_final)[colnames(production5_conversion_prices_final)=="s4v_a113i"]="quantity5_harvested"
colnames(production5_conversion_prices_final)[colnames(production5_conversion_prices_final)=="s4v_a113ii"]="unit5_code"

production5_conversion_prices_final = production5_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 66 plots out of 235 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop5_code, quantity5_harvested, unit5_code,
         unit_in_kgr_ghana, price_ghana)


production_w1c5 = production5_conversion_prices_final %>%
  mutate(ea_crop5_unit = paste(id3, crop5_code, unit5_code, sep=".")) %>%
  mutate(quantity5_in_kgr = quantity5_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c5 = quantity5_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop5_unit, quantity5_harvested, quantity5_in_kgr, value_w1c5)




#########################################################################################################################################
###################                      Merge all the crops of the plots                           #####################################
#########################################################################################################################################


# There is one problem in the merging. Some plots might NOT have crop 1 but they DO have crop 2... As a result, each crop is not a subset of the previous one.
# The problem arises because in crop 1 at some point I cleared out the plots that did not have any crop. I resolve this by taking the plot_ids from the crop and not
# from the production_w1c1


production_w1 = full_join(crop_prod[,c("id1", "id2", "id3","hhno", "plot_id")],production_w1c1[, c("plot_id","ea_crop1_unit", "quantity_harvested", "quantity1_in_kgr", "value_w1c1")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c2[, c("plot_id","ea_crop2_unit", "quantity2_harvested", "quantity2_in_kgr", "value_w1c2")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c3[, c("plot_id","ea_crop3_unit", "quantity3_harvested", "quantity3_in_kgr", "value_w1c3")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c4[, c("plot_id","ea_crop4_unit", "quantity4_harvested", "quantity4_in_kgr", "value_w1c4")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c5[, c("plot_id","ea_crop5_unit", "quantity5_harvested", "quantity5_in_kgr", "value_w1c5")], by='plot_id')


production_w1_final = production_w1 %>%
  group_by(plot_id) %>%
  mutate(tot_production_in_kgr = sum(quantity1_in_kgr, quantity2_in_kgr,quantity3_in_kgr, quantity4_in_kgr, quantity5_in_kgr, na.rm = T)) %>% # Note that you are summing up quantities in kgr but maybe they are different crops.....
  mutate(tot_production_value  = sum(value_w1c1,value_w1c2,value_w1c3,value_w1c4,value_w1c5, na.rm=T)) %>%
  select(id1, id2, id3, hhno, plot_id, tot_production_in_kgr, tot_production_value) %>%
  filter(!is.na(plot_id))

# Note that for wave 1 you have NOT added the expected harvest - however in wave 1 the expected harvest for the specific plot is referred in questions A.85 which is a y/n question
# and in the followup A.86 which asks about the value of the expected harvest if sold in the market. Therefore, I will just add the corresponding questions for each crop and add the
# market value of the expected harvest to the total_production_value column in the production_w1_final dataframe above.

exp_harvest_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av1_plotno,
         s4v_a85i, s4v_a85ii,                 # Market value of crop 1 in cedis and pesewas respectively.
         s4v_a93i, s4v_a93ii,                 # Market value of crop 2 in cedis and pesewas respectively.
         s4v_a101i, s4v_a102,                 # Market value of crop 3 in cedis and pesewas respectively.
         s4v_a109i, s4v_a109ii,               # Market value of crop 4 in cedis and pesewas respectively.
         s4v_a117i, s4v_a117ii) %>%           # Market value of crop 5 in cedis and pesewas respectively.
  mutate(plot_id = as.numeric(paste(hhno, s4av1_plotno, sep=""))) %>%
  group_by(plot_id) %>%
  mutate(pes_in_cedis_crop1 = s4v_a85ii*0.01) %>%
  mutate(pes_in_cedis_crop2 = s4v_a93ii*0.01) %>%
  mutate(pes_in_cedis_crop3 = s4v_a102*0.01) %>%
  mutate(pes_in_cedis_crop4 = s4v_a109ii*0.01) %>%
  mutate(pes_in_cedis_crop5 = s4v_a117ii*0.01) %>%
  mutate(exp_crop1 = sum(s4v_a85i,pes_in_cedis_crop1, na.rm = T)) %>%
  mutate(exp_crop2 = sum(s4v_a93i,pes_in_cedis_crop2, na.rm = T)) %>%
  mutate(exp_crop3 = sum(s4v_a101i,pes_in_cedis_crop3, na.rm = T)) %>%
  mutate(exp_crop4 = sum(s4v_a109i,pes_in_cedis_crop4, na.rm = T)) %>%
  mutate(exp_crop5 = sum(s4v_a117i,pes_in_cedis_crop5, na.rm = T)) %>%
  mutate(tot_exp_harvest = sum(exp_crop1, exp_crop2, exp_crop3, exp_crop4, exp_crop5, na.rm = T)) %>%
  filter(tot_exp_harvest>=0) %>%
  filter(!is.na(plot_id)) %>%
  select(plot_id, tot_exp_harvest)



# Now add the exp_harvest_w1 to the production_w1_final and derive the total_value.
production_w1_final = left_join(production_w1_final, exp_harvest_w1, by="plot_id") %>%
  group_by(plot_id) %>%
  mutate(total_production_harv_exp_value = sum(tot_production_value, tot_exp_harvest, na.rm = T)) %>%
  select(-tot_production_value, -tot_exp_harvest)

colnames(production_w1_final)[colnames(production_w1_final)=="total_production_harv_exp_value"]="tot_production_value"


```




```{r Revenues wave 1  MINOR SEASON}
######################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################          MINOR SEASON        ############################################################################## ##################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################################
# Address problem no 1: insert the unitcode_w1 from Andre's data: 
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#############################                                    ################################################
#############################             WAVE 1                 ################################################
#############################                                    ################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################

#################################################################################################################
############               Crop1 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1. 
crop_prod = read_dta("./S4AV2.dta") %>%
  mutate(id1= as.numeric(id1)) %>% 
  mutate(id2= as.numeric(id2)) %>% 
  mutate(id3= as.numeric(id3)) %>%
  mutate(hhno = as.numeric(hhno)) %>% 
  mutate(plot_id=as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>% 
  filter(!is.na(plot_id))

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity 
# for all 5 crops reported for each plot.
crop_prod_w1 = crop_prod %>% 
  select(id1, id2, id3, hhno, s4av2_plotno, 
         s4v_a121i, s4v_a122i, s4v_a122ii) %>%     # for crop 1
        #s4v_a129i, s4v_a130i, s4v_a130ii) %>%     # for crop 2
        #s4v_a137i, s4v_a138i, s4v_a138ii,         # for crop 3
        #s4v_a145i, s4v_a146i, s4v_a146ii,      # for crop 4
        #s4v_a153i, s4v_a154i, s4v_a154ii) %>%  # for crop 5
  filter(!is.na(s4v_a121i)) %>% filter(!is.na(s4v_a122ii)) %>%  # i filter out plots that do not have either the crop or the unit- cause nothing to learn there. 
  mutate(plot_id = as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>% 
  mutate(ea_crop_unit_id = paste(id3, s4v_a121i,s4v_a122ii, sep=".")) %>% 
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, s4v_a121i,ea_crop_unit_id, s4v_a122ii,s4v_a122i) #,s4v_a129i, s4v_a130ii,s4v_a130i)

crop_prod_w1 = crop_prod_w1[,c(1:5,9,6:8)] # note here that I also leave out the plot no since I have the plot id. 


#################################################################################################################
#############               Unit Conversion for Wave 1         ##################################################
#################################################################################################################



# The following dataframe includes for each EA for each Crop type for each Unit of Quantity Measurement transformation rates to kgr. 
unitcon_W1 = read_dta("./unitcon_W1.dta")

# Below I do the following. i take the unitcon_W1 and in particular the 23 columns of all units included and 
# I transpose them into rows. In this way, we have for each EA and crop all the units in different rows for each unit.
# From 1,295 rows we end up to 1,295*23 = 29,785 rows. I do this in order to generate a unique EA.id-Crop.id-Unit.id  
# and be able to match it to the EA.id-Crop.id-Unit.id with the production quantity in the production of wave 1 data frame. 
# I am expecting very few to match since the unitcon_W1 is very scarce table, however, then we will be able to 
# expand at the district/region and country level conversion. 
conversion_table_reshaped = unitcon_W1 %>% 
  gather(c(9:31), key="unit", value="unit_in_kgr") # transpose the 23 unit columns into rows. 

# rename the "s5" column to "crop_code"
colnames(conversion_table_reshaped)[colnames(conversion_table_reshaped)=="s5"]="crop_code"
# rename the "s5a_1" column to "crop_code"
colnames(conversion_table_reshaped)[colnames(conversion_table_reshaped)=="s5a_1"]="crop_name"

# # The conversion table reshaped is very scarce - since it has many NAs values. 
# summary(conversion_table_reshaped$unit_in_kgr) # From here it shows that we have transformation rates for 1,609 EA/Crop/Unit specific items. Note however, that some of them coincide. 


# Below I assign to each unit appearing in the table the corresponding unit name from the column details. 
conversion_table = conversion_table_reshaped %>% 
  mutate(unit_name = case_when(
    unit=="s5a_a"~"American Tin",
    unit=="s5a_b"~"Balls",
    unit=="s5a_c"~"Basket",
    unit=="s5a_d"~"Bowl",
    unit=="s5a_e"~"Box", 
    unit=="s5a_f"~"Bucket", 
    unit=="s5a_g"~"Bunch", 
    unit=="s5a_h"~"Bundle",
    unit=="s5a_i"~"Crate", 
    unit=="s5a_j"~"Dozen",
    unit=="s5a_k"~"Fingers",
    unit=="s5a_l"~"Fruits", 
    unit=="s5a_m"~"Kgr", 
    unit=="s5a_n"~"Margarine Tin",
    unit=="s5a_o"~"Maxi Bag",
    unit=="s5a_p"~"Mini Bag", 
    unit=="s5a_q"~"Nut", 
    unit=="s5a_r"~"Pair",
    unit=="s5a_s"~"Pieces",
    unit=="s5a_t"~"Singles",
    unit=="s5a_u"~"Stick", 
    unit=="s5a_v"~"Tonne", 
    unit=="s5a_w"~"Tubers",
    TRUE ~ "NA"))

# Below I assign to each unit appearing in the table the corresponding unit code from the Code-Book.

conversion_table = conversion_table %>% 
  mutate(unit_code = case_when(
    unit=="s5a_a"~2,
    unit=="s5a_b"~27,
    unit=="s5a_c"~4,
    unit=="s5a_d"~6,
    unit=="s5a_e"~7, 
    unit=="s5a_f"~29, 
    unit=="s5a_g"~8, 
    unit=="s5a_h"~9,
    unit=="s5a_i"~30, 
    unit=="s5a_j"~31,
    unit=="s5a_k"~11,
    unit=="s5a_l"~12, 
    unit=="s5a_m"~14, 
    unit=="s5a_n"~17,
    unit=="s5a_o"~18,
    unit=="s5a_p"~19, 
    unit=="s5a_q"~20, 
    unit=="s5a_r"~33,
    unit=="s5a_s"~34,
    unit=="s5a_t"~37,
    unit=="s5a_u"~23, 
    unit=="s5a_v"~24, 
    unit=="s5a_w"~26,                          
    TRUE ~ as.numeric(NA)))

# I dont need any more the unit column - since I have both the name of the unit and its code. 
conversion_table = conversion_table %>% 
  select(-unit)

# Since we know that the conversion table is EA/Crop/Unit specific I create a unique id for each entry 
# this id combines the EA id the Crop Code and the Unit Code. I have transformed the table in such a way that the 
# each row corresponds to a EA-Crop-Unit id. 
# The EA/Crop/Unit id is the narrowest level we can go with the data in hand. However, in order to obtain transformation
# rates for as many plots as possible, I perform three generalisations. 
# Gen.1: District/Crop/Unit id - where for the same crop and unit if there is a NA in the EA, I add the district's average. 
#        By applying this, we assume that a maxi bag of cassawa weighs the same within each district. 
# Gen.2: Region/Crop/Unit id - where for the same crop and unit if there is a NA in the EA and the district, I add the 
#        region's average. By applying this, we assume that a maxi bag of cassawa weighs the same within region. 
# Gen.3: Crop/Unit id - where for the same crop and unit if there is a NA in the EA, the District and the Region, I add the 
#        country's average. By applying this, we assume taht a maxi bag of cassawa weight the same all across Ghana. 

conversion_table = conversion_table %>% 
  filter(!is.na(crop_code)) %>% 
  mutate(ea_no=as.numeric(ea_no)) %>%           # turn all ea codes in numeric
  mutate(district=as.numeric(district)) %>%     # turn all district codes in numeric
  mutate(reg=as.numeric(reg)) %>%               # turn all region codes in numeric
  mutate(crop_code = as.numeric(crop_code)) %>%               # turn all crop codes in numeric
  mutate(unit_code=as.numeric(unit_code)) %>%   # turn all unit codes in numeric
  mutate(ea_crop_unit_id = paste(ea_no, crop_code, unit_code, sep=".")) %>%  # create the ea_crop_unit_id
  mutate(dist_crop_unit_id = paste(district, crop_code, unit_code, sep=".")) %>% # create the district_crop_unit_id
  mutate(reg_crop_unit_id = paste(reg, crop_code, unit_code, sep=".")) %>% # create the region_crop_unit_id
  mutate(crop_unit_id = paste(crop_code, unit_code, sep=".")) %>%  # create the country's crop_unit_id
  filter(!is.na(ea_crop_unit_id)) %>%           # filter out all NA values at the ea unit crop id those come from the missing values of s5 (crop_code) so those 805 entries are entirely uselless even at the district level  
  select(regname, reg, district, ea_no, ctycode, crop_code, crop_name, unit_name, unit_code, ea_crop_unit_id, dist_crop_unit_id, reg_crop_unit_id, crop_unit_id ,unit_in_kgr) 


# Note that so far you have the unit_in_kgr that is the conversion rate of the measurement unit for the crop in the EA as specified by the EA_crop_unit_id. 
# First I am renaming this unit_in_kgr to unit_in_kgr_ea to denote that this corresponds to a specific EA. 
colnames(conversion_table)[colnames(conversion_table)=="unit_in_kgr"]="unit_in_kgr_ea"

# Second, I am going to build at this point the "unit_in_kgr_dist". Which is the mean of all unit_in_kgr_ea that belong to the same district. In this way I 
# building a conversion rate at the district level which takes advantage of all available data - even those that will not be matched when I merge the conversion 
# table to the  production data - what I did originally is to derive the mean after I merged - however, in this way I missed all the data that were not mathced at the EA level. 
conversion_table = conversion_table %>%  
                   ungroup() %>% 
                   group_by(dist_crop_unit_id) %>%  
                    mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_ea)~mean(subset(unit_in_kgr_ea, unit_in_kgr_ea>=quantile(unit_in_kgr_ea, 0.25,na.rm = T)-2*((quantile(unit_in_kgr_ea, 0.75,na.rm = T)-                                                                                                                     quantile(unit_in_kgr_ea, 0.25,na.rm = T))) & unit_in_kgr_ea<=quantile(unit_in_kgr_ea, 0.75,na.rm = T)+2*((quantile(unit_in_kgr_ea, 0.75,na.rm = T)-                                   quantile(unit_in_kgr_ea, 0.25,na.rm = T)))), na.rm = T),
    TRUE ~ as.numeric(unit_in_kgr_ea)))  %>% 
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist)) 

# Third, I am doing the same thing at the regional level. 
conversion_table = conversion_table %>%  
  ungroup() %>% 
  group_by(reg_crop_unit_id) %>%  
  mutate(unit_in_kgr_reg = case_when(
    is.na(unit_in_kgr_dist)~mean(subset(unit_in_kgr_dist, unit_in_kgr_dist>=quantile(unit_in_kgr_dist, 0.25,na.rm = T)-2*((quantile(unit_in_kgr_dist, 0.75,na.rm = T)-
                                                                                                                             quantile(unit_in_kgr_dist, 0.25,na.rm = T))) & unit_in_kgr_dist<=quantile(unit_in_kgr_dist, 0.75,na.rm = T)+2*((quantile(unit_in_kgr_dist, 0.75,na.rm = T)-
                                                                                                                                                                                                                                               quantile(unit_in_kgr_dist, 0.25,na.rm = T)))), na.rm = T),
    TRUE ~ as.numeric(unit_in_kgr_dist)))  %>% 
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg)) 

# Fourth, I am doing the same thing at the ghana level. 
conversion_table = conversion_table %>%  
  ungroup() %>% 
  group_by(crop_unit_id) %>%  
  mutate(unit_in_kgr_ghana = case_when(
    is.na(unit_in_kgr_reg)~mean(subset(unit_in_kgr_reg, unit_in_kgr_reg>=quantile(unit_in_kgr_reg, 0.25,na.rm = T)-2*((quantile(unit_in_kgr_reg, 0.75,na.rm = T)-
                                                                                                                         quantile(unit_in_kgr_reg, 0.25,na.rm = T))) & unit_in_kgr_reg<=quantile(unit_in_kgr_reg, 0.75,na.rm = T)+2*((quantile(unit_in_kgr_reg, 0.75,na.rm = T)-
                                                                                                                                                                                                                                        quantile(unit_in_kgr_reg, 0.25,na.rm = T)))), na.rm = T),
    TRUE ~ as.numeric(unit_in_kgr_reg)))  %>% 
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana)) 

# Check how many filled up values you get with the generalisations:
# summary(conversion_table$unit_in_kgr_ea)      # NAs: 27,371 --> you get 28,980-27,371 = 1609 unit_in_kgr_ea
# summary(conversion_table$unit_in_kgr_dist)    # 5369 unit_in_kgr_dist
# summary(conversion_table$unit_in_kgr_reg)     # 11959 unit_in_kgr_reg
# summary(conversion_table$unit_in_kgr_ghana)   # 24398 unit_in_kgr_ghana

# Note that in the conversion table there are multiple instances of the same ea/crop/unit codes - this is because in the original conversion table they recorded multiple 
# transformations in kgr for the same ea the same crop and the same unit. For example in ea: 2 , crop: bananas, unit: maxi bag one instance was 100 kgr, the second 102 kgr 
# the third is 101.5. As a result I have three entries with the same ea-crop-unit id. For those entries I take the mean.

coversion_table_final = conversion_table %>% ### Important Note: The "conversion_table_final" is the version of the conversion that you are using to merge it with the production data. 
  group_by(ea_crop_unit_id) %>% 
  mutate(unit_in_kgr_ea = mean(unit_in_kgr_ea,na.rm = T)) %>% # If there are multiple ea_crop_unit_ids I take the mean of it and not the actual value
  filter(!duplicated(ea_crop_unit_id)) %>%  # I am only filtering out the duplicated EA.Crop.Unit codes. - So I m left with only unique EA.Crop.Unit ids. 
  mutate(unit_in_kgr_ea = ifelse(!is.finite(unit_in_kgr_ea), as.numeric(NA), unit_in_kgr_ea)) %>% 
  ungroup() %>% 
  mutate(unit_in_kgr_ea = ifelse(!is.finite(unit_in_kgr_ea), as.numeric(NA),unit_in_kgr_ea ))
# list(unique(coversion_table_final$ea_crop_unit_id))
# list(unique(coversion_table_final$dist_crop_unit_id))
# list(unique(coversion_table_final$reg_crop_unit_id))

# # Here I do something on the side: 
# # isolate the universal categories that can be applied nationally. (These are the fruits and the pieces and kgr) Note that in case in the production dataframe 
# # there is an entry 3.000 and the measurement unit is Fruits then I can use the information in the conversion table about each fruit in kgr. Same for 
# # pieces. The distinct characteristic of that is that everywhere in Ghana the onion weighs the same. 
# 
# conversion_table_uni_values = coversion_table_final %>% 
#                               filter(unit_code == c(12, 14, 34))
# list(unique(conversion_table_uni_values$crop_name))
# list(unique(conversion_table_uni_values$crop_code)) # Essentially those are the crops for which you have information in "kgr per crop" and not in "kgr per unit per crop" as the rest of the unit measures.
```




```{r Revenues wave 1 contd MINOR SEASON}

#################################################################################################################
#######            Merge production of wave 1 with conversion table final        ################################
#################################################################################################################

crop_prod_w1_conv_tbl = left_join(crop_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea", "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 3,752 from a total of 4,729 entries - this means that 977 entries have non-NAs number



# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values 
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables 
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254) 
# str(crop_prod_w1_conv_tbl$dist_crop_unit_id)
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  mutate(id1 = as.numeric(id1)) %>% 
  mutate(id2 = as.numeric(id2)) %>%
  mutate(id3 = as.numeric(id3)) %>%
  mutate(dist_crop_unit_id = case_when(                                                  # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a121i, s4v_a122ii, sep="."),   # made from the data of production. 
    TRUE ~ dist_crop_unit_id)) %>% 
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a121i, s4v_a122ii, sep="."),    # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a121i, s4v_a122ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to 
# the same district - if it is filled up I leave it as it is. 
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  group_by(dist_crop_unit_id) %>% 
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>% 
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level. 
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  group_by(reg_crop_unit_id) %>% 
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>% 
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level. 
crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  group_by(crop_unit_id) %>% 
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>% 
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# # Check how many fill ups you achieve. 
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However, 
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to 
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower 
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop_prod_w1_conv_tbl = crop_prod_w1_conv_tbl %>% 
  ungroup() %>% 
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>% 
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>% 
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available. 

```



```{r Reveneues wave 1 contd 2 MINOR SEASON}
##############################################################################################################################################
########################                      Crop Prices Wave 1              ################################################################
##############################################################################################################################################


crop_price = read_dta("./cropprice_W1.dta")
# Note that this table has the price per unit for EA-Crop-Unit specific items.

# Select only the relevant information.
crop_price = crop_price %>%
  select(regname, reg, district, ea_no, s4_1, s4_2, s4_6, s4_5i, s4_5ii) %>% 
  mutate(reg = as.numeric(reg)) %>% 
  mutate(district = as.numeric(district)) %>% 
  mutate(ea_no = as.numeric(ea_no)) %>% 
  mutate(s4_2 = as.numeric(s4_2)) %>% 
  mutate(s4_6 = as.numeric(s4_6)) %>% 
  mutate(s4_5i = as.numeric(s4_5i)) %>% 
  mutate(s4_5ii = as.numeric(s4_5ii))


# rename relevant columns

colnames(crop_price)[colnames(crop_price)=="s4_1"]="crop_name"
colnames(crop_price)[colnames(crop_price)=="s4_2"]="crop_code"
colnames(crop_price)[colnames(crop_price)=="s4_6"]="unit_code"
colnames(crop_price)[colnames(crop_price)=="s4_5i"]="crop_price_ced"
colnames(crop_price)[colnames(crop_price)=="s4_5ii"]="crop_price_pes"

# 1. Add the cedis and pesewas to get one price.
crop_price = crop_price %>%
  mutate(crop_price_pes_in_cedis = crop_price_pes*0.01) %>%
  rowwise() %>%
  mutate(price = sum(crop_price_ced,crop_price_pes_in_cedis, na.rm = T)) %>%
  select(-crop_price_ced, -crop_price_pes, -crop_price_pes_in_cedis) %>% 
  filter(!is.na(crop_code))

# 2. Create the EA-Crop-Unit id
crop_price = crop_price %>%
  filter(!is.na(ea_no)) %>% filter(!is.na(crop_code)) %>% filter(!is.na(unit_code)) %>% 
  mutate(ea_crop_unit_id = paste(ea_no, crop_code, unit_code, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id))  # those that do not have an ea_crop_unit_id are those because of the lack of crops hence they are useless.


crop_price = crop_price %>%
  group_by(ea_crop_unit_id) %>%
  add_tally()


# In particular:
# 192 EA_Crop_Unit_ids appear 2 times - we have the same info twice.
# 48  EA_Crop_Unit_ids appear 3 times
# 12  EA_Crop_Unit_ids appear 4 times
# For all those I substitute by the mean and keep the EA_Crop_Unit_id only once.


crop_price_final = crop_price %>%
  group_by(ea_crop_unit_id) %>%
  mutate(price = mean(price, na.rm = T)) %>%
  filter(!duplicated(ea_crop_unit_id)) %>%
  select(-n)
# Now I do the same as I did in the conversion table. I create the district_crop_unit_id reg_crop_unit_id and ghana_crop_unit_id and create
# the price_dist, price_reg and price ghana.

crop_price_final = crop_price_final %>%
  mutate(dist_crop_unit_id = paste(district, crop_code, unit_code, sep=".")) %>% # create the district_crop_unit_id
  mutate(reg_crop_unit_id = paste(reg, crop_code, unit_code, sep=".")) %>% # create the region_crop_unit_id
  mutate(crop_unit_id = paste(crop_code, unit_code, sep="."))  # create the country's crop_unit_id


colnames(crop_price_final)[colnames(crop_price_final)=="price"]="price_ea"


# Second, I am going to build at this point the "price_dist". Which is the mean of all price_ea that belong to the same district. In this way I
# building a price at the district level which takes advantage of all available data - even those that will not be matched when I merge the price
# table to the  production data
crop_price_final = crop_price_final %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = ifelse(!is.na(dist_crop_unit_id), mean(price_ea, na.rm = T), as.numeric(NA))) # You re going to keep the price_ea if it exists later after the merging.


# Third, I am doing the same thing at the regional level.
crop_price_final = crop_price_final %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = mean(price_dist, na.rm = T)) # You re going to keep the price_ea if it exists later after the merging.

# Fourth, I am doing the same thing at the ghana level.
crop_price_final = crop_price_final %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = mean(price_reg, na.rm = T)) # You re going to keep the price_ea if it exists later after the merging.


crop_price_final = crop_price_final[,c(1:7, 9:12, 8, 13:15)]


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop prices   #################################################
########################################################################################################################################


production_conversion_prices = left_join(crop_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production_conversion_prices$price_ea)
# summary(production_conversion_prices$price_dist)
# summary(production_conversion_prices$price_reg)
# summary(production_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production_conversion_prices$price_ea)
# summary(production_conversion_prices$price_dist)
# summary(production_conversion_prices$price_reg)
# summary(production_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production_conversion_prices = production_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production_conversion_prices_final = production_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a121i, s4v_a122i, s4v_a122ii, unit_in_kgr_ghana, price_ghana)

colnames(production_conversion_prices_final)[colnames(production_conversion_prices_final)=="s4v_a121i"]="crop_code"
colnames(production_conversion_prices_final)[colnames(production_conversion_prices_final)=="s4v_a122i"]="quantity_harvested"
colnames(production_conversion_prices_final)[colnames(production_conversion_prices_final)=="s4v_a122ii"]="unit_code"

production_conversion_prices_final = production_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 4,092 plots out of 4,729 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop_code, quantity_harvested, unit_code,
         unit_in_kgr_ghana, price_ghana)

production_w1c1 = production_conversion_prices_final %>%
  mutate(ea_crop1_unit = paste(id3, crop_code, unit_code, sep=".")) %>%
  mutate(quantity1_in_kgr = quantity_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c1 = quantity_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop1_unit, quantity_harvested, quantity1_in_kgr, value_w1c1)
```


```{r Revenues wave 1 contd 3 MINOR SEASON}
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
####################################                Same for Crop 2                       ########################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################

# Note so far I have constructed the production_conversion_prices_final however, I have only used production data referring to crop 1
# However, in each plot there are more than one crop grown in different times. And we have data on those.
# Moreover, the remaining crops are not the same - for example in one plot the main crop was Cassava but during the season the farmer also
# grew some Maize.
# Therefore, I will repeat certain parts of the code above to include total production.
# Fortunately the conversion table and the price data do not need to be repeated - only the merging parts.


#################################################################################################################
############               Crop2 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop2_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av2_plotno,
         #s4v_a121i, s4v_a122i, s4v_a122ii) %>%     # for crop 1
         s4v_a129i, s4v_a130i, s4v_a130ii) %>%      # for crop 2
  #s4v_a137i, s4v_a138i, s4v_a138ii,         # for crop 3
  #s4v_a145i, s4v_a146i, s4v_a146ii,      # for crop 4
  #s4v_a153i, s4v_a154i, s4v_a154ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a129i,s4v_a130ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a129i, s4v_a130ii,s4v_a130i)


# crop_prod_w1 = crop_prod_w1[,c(1:5,9,6:8)] # note here that I also leave out the plot no since I have the plot id.
#crop_prod = crop_prod[,c(1:4, 21, 6:20)]



#################################################################################################################
#######            Merge production of wave 1 Crop 2 with conversion table final        #########################
#################################################################################################################

crop2_prod_w1_conv_tbl = left_join(crop2_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 3,752 from a total of 4,729 entries - this means that 977 entries have non-NAs number



# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop2_prod_w1_conv_tbl$dist_crop_unit_id)
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a129i, s4v_a130ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a129i, s4v_a130ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a129i, s4v_a130ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop2_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop2_prod_w1_conv_tbl = crop2_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop2 prices   ################################################
########################################################################################################################################


production2_conversion_prices = left_join(crop2_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production2_conversion_prices$price_ea)
# summary(production2_conversion_prices$price_dist)
# summary(production2_conversion_prices$price_reg)
# summary(production2_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production2_conversion_prices$price_ea)
# summary(production2_conversion_prices$price_dist)
# summary(production2_conversion_prices$price_reg)
# summary(production2_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production2_conversion_prices = production2_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production2_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production2_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production2_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production2_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production2_conversion_prices_final = production2_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a129i, s4v_a130ii, s4v_a130i, unit_in_kgr_ghana, price_ghana)

colnames(production2_conversion_prices_final)[colnames(production2_conversion_prices_final)=="s4v_a129i"]="crop2_code"
colnames(production2_conversion_prices_final)[colnames(production2_conversion_prices_final)=="s4v_a130i"]="quantity2_harvested"
colnames(production2_conversion_prices_final)[colnames(production2_conversion_prices_final)=="s4v_a130ii"]="unit2_code"

production2_conversion_prices_final = production2_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 1956 plots out of 2382 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop2_code, quantity2_harvested, unit2_code,
         unit_in_kgr_ghana, price_ghana)

production_w1c2 = production2_conversion_prices_final %>%
  mutate(ea_crop2_unit = paste(id3, crop2_code, unit2_code, sep=".")) %>%
  mutate(quantity2_in_kgr = quantity2_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c2 = quantity2_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop2_unit, quantity2_harvested, quantity2_in_kgr, value_w1c2)

# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ####################################                Same for Crop 3                       ########################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################
# ##################################################################################################################################################



#################################################################################################################
############               Crop3 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop3_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av2_plotno,
         #s4v_a121i, s4v_a122i, s4v_a122ii) %>%     # for crop 1
         #s4v_a129i, s4v_a130i, s4v_a130ii) %>%     # for crop 2
         s4v_a137i, s4v_a138i, s4v_a138ii) %>%      # for crop 3
  #s4v_a145i, s4v_a146i, s4v_a146ii,      # for crop 4
  #s4v_a153i, s4v_a154i, s4v_a154ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a137i,s4v_a138ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a137i, s4v_a138ii,s4v_a138i)


# crop_prod_w1 = crop_prod_w1[,c(1:5,9,6:8)] # note here that I also leave out the plot no since I have the plot id.
#crop_prod = crop_prod[,c(1:4, 21, 6:20)]


#################################################################################################################
#######            Merge production of wave 1 Crop 3 with conversion table final        #########################
#################################################################################################################

crop3_prod_w1_conv_tbl = left_join(crop3_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 987 from a total of 1,223 entries


# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop3_prod_w1_conv_tbl$dist_crop_unit_id)
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a137i, s4v_a138ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a137i, s4v_a138ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a137i, s4v_a138ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop3_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop3_prod_w1_conv_tbl = crop3_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop3 prices   ################################################
########################################################################################################################################


production3_conversion_prices = left_join(crop3_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production3_conversion_prices$price_ea)
# summary(production3_conversion_prices$price_dist)
# summary(production3_conversion_prices$price_reg)
# summary(production3_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production3_conversion_prices$price_ea)
# summary(production3_conversion_prices$price_dist)
# summary(production3_conversion_prices$price_reg)
# summary(production3_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production3_conversion_prices = production3_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production3_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production3_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production3_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production3_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production3_conversion_prices_final = production3_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a137i, s4v_a138ii, s4v_a138i, unit_in_kgr_ghana, price_ghana)

colnames(production3_conversion_prices_final)[colnames(production3_conversion_prices_final)=="s4v_a137i"]="crop3_code"
colnames(production3_conversion_prices_final)[colnames(production3_conversion_prices_final)=="s4v_a138i"]="quantity3_harvested"
colnames(production3_conversion_prices_final)[colnames(production3_conversion_prices_final)=="s4v_a138ii"]="unit3_code"

production3_conversion_prices_final = production3_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 862 plots out of 1323 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop3_code, quantity3_harvested, unit3_code,
         unit_in_kgr_ghana, price_ghana)


production_w1c3 = production3_conversion_prices_final %>%
  mutate(ea_crop3_unit = paste(id3, crop3_code, unit3_code, sep=".")) %>%
  mutate(quantity3_in_kgr = quantity3_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c3 = quantity3_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop3_unit, quantity3_harvested, quantity3_in_kgr, value_w1c3)

##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
####################################                Same for Crop 4                       ########################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################



#################################################################################################################
############               Crop4 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop4_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av2_plotno,
         #s4v_a121i, s4v_a122i, s4v_a122ii) %>%     # for crop 1
         #s4v_a129i, s4v_a130i, s4v_a130ii) %>%     # for crop 2
         #s4v_a137i, s4v_a138i, s4v_a138ii) %>%     # for crop 3
         s4v_a145i, s4v_a146i, s4v_a146ii) %>%   # for crop 4
  #s4v_a153i, s4v_a154i, s4v_a154ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a145i,s4v_a146ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a145i, s4v_a146ii,s4v_a146i)


#################################################################################################################
#######            Merge production of wave 1 Crop 4 with conversion table final        #########################
#################################################################################################################

crop4_prod_w1_conv_tbl = left_join(crop4_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 493 from a total of 581 entries


# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop4_prod_w1_conv_tbl$dist_crop_unit_id)
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a145i, s4v_a146ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a145i, s4v_a146ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a145i, s4v_a146ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop4_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop4_prod_w1_conv_tbl = crop4_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.

########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop4 prices   ################################################
########################################################################################################################################


production4_conversion_prices = left_join(crop4_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production4_conversion_prices$price_ea)
# summary(production4_conversion_prices$price_dist)
# summary(production4_conversion_prices$price_reg)
# summary(production4_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production4_conversion_prices$price_ea)
# summary(production4_conversion_prices$price_dist)
# summary(production4_conversion_prices$price_reg)
# summary(production4_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production4_conversion_prices = production4_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production4_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production4_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production4_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production4_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production4_conversion_prices_final = production4_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a145i, s4v_a146ii, s4v_a146i, unit_in_kgr_ghana, price_ghana)

colnames(production4_conversion_prices_final)[colnames(production4_conversion_prices_final)=="s4v_a145i"]="crop4_code"
colnames(production4_conversion_prices_final)[colnames(production4_conversion_prices_final)=="s4v_a146i"]="quantity4_harvested"
colnames(production4_conversion_prices_final)[colnames(production4_conversion_prices_final)=="s4v_a146ii"]="unit4_code"

production4_conversion_prices_final = production4_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 298 plots out of 581 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop4_code, quantity4_harvested, unit4_code,
         unit_in_kgr_ghana, price_ghana)

production_w1c4 = production4_conversion_prices_final %>%
  mutate(ea_crop4_unit = paste(id3, crop4_code, unit4_code, sep=".")) %>%
  mutate(quantity4_in_kgr = quantity4_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c4 = quantity4_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop4_unit, quantity4_harvested, quantity4_in_kgr, value_w1c4)

##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
####################################                Same for Crop 5                       ########################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################
##################################################################################################################################################



#################################################################################################################
############               Crop5 Production from Wave 1        ##################################################
#################################################################################################################

# Insert the information on agriculture in wave 1.

# crop_prod = read_dta("E:/AAA_R_E_S_E_A_R_C_H/Ghana/Ghana Socioeconomic Panel Survey Data - Waves 1 -2/Ghana Panel Data Public/Data/Clean/Wave 1/cross_file_prep/S4AV1.dta")

# Take the relevant questions on units and quantities. In particular I pick the following:
# ID of crop // Quantity of harvested crop // Unit of quantity
# for all 5 crops reported for each plot.
crop5_prod_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av2_plotno,
         #s4v_a121i, s4v_a122i, s4v_a122ii) %>%     # for crop 1
         #s4v_a129i, s4v_a130i, s4v_a130ii) %>%     # for crop 2
         #s4v_a137i, s4v_a138i, s4v_a138ii) %>%     # for crop 3
         #s4v_a145i, s4v_a146i, s4v_a146ii) %>%   # for crop 4
         s4v_a153i, s4v_a154i, s4v_a154ii) %>%  # for crop 5
  mutate(plot_id = as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>%
  mutate(ea_crop_unit_id = paste(id3, s4v_a153i,s4v_a154ii, sep=".")) %>%
  filter(!is.na(ea_crop_unit_id)) %>%   # filter out those plots that do not have an ea_crop_unit id
  select(id1, id2, id3, hhno, plot_id, ea_crop_unit_id, s4v_a153i, s4v_a154ii,s4v_a154i)

#################################################################################################################
#######            Merge production of wave 1 Crop 5 with conversion table final        #########################
#################################################################################################################

crop5_prod_w1_conv_tbl = left_join(crop5_prod_w1,coversion_table_final[,c("ea_crop_unit_id","dist_crop_unit_id","reg_crop_unit_id","crop_unit_id", "unit_in_kgr_ea",
                                                                          "unit_in_kgr_dist", "unit_in_kgr_reg", "unit_in_kgr_ghana")], by="ea_crop_unit_id")


# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_ea) # Note that the NAs are 493 from a total of 581 entries


# However, note that there are many ea_crop_unit codes that have dist_crop_unit and reg_crop_unit_id which are NAs. How is this possible? - those values
# were not merged - those are the initial ea_crop_unit ids from the production for which we do not have a transformation rate in kgr from the conversion tables
# In those values I will create the corresponding distr_crop_unit id and maybe this would coincide with some already given value (for example take the dist_crop_unit : 254)

# str(crop5_prod_w1_conv_tbl$dist_crop_unit_id)
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  mutate(dist_crop_unit_id = case_when(                                             # Here I check if the dist_crop_unit_id is NA and if it is I replace it with the distr_crop_unit_id
    is.na(dist_crop_unit_id)~paste(id2, s4v_a153i, s4v_a154ii, sep="."),   # made from the data of production.
    TRUE ~ dist_crop_unit_id)) %>%
  mutate(reg_crop_unit_id = case_when(
    is.na(reg_crop_unit_id)~paste(id1, s4v_a153i, s4v_a154ii, sep="."),   # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ reg_crop_unit_id)) %>%                                      # made from the data of production.
  mutate(crop_unit_id = case_when(
    is.na(crop_unit_id)~paste(s4v_a153i, s4v_a154ii, sep="."),            # Here I check if the reg_crop_unit_id is NA and if it is I replace it with the reg_crop_unit_id
    TRUE ~ crop_unit_id))

# Now what I want to do is the following. I fill up the unit_in_kgr_district. If there is a missing value I fill it up with the mean of unit_in_kgr_dist that belong to
# the same district - if it is filled up I leave it as it is.
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(unit_in_kgr_dist = case_when(is.na(unit_in_kgr_dist)~mean(unit_in_kgr_dist, na.rm=T),
                                      TRUE ~ unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_dist = ifelse(!is.finite(unit_in_kgr_dist), as.numeric(NA), unit_in_kgr_dist))

# I do the same for regional level.
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(unit_in_kgr_reg = case_when(is.na(unit_in_kgr_reg)~mean(unit_in_kgr_reg, na.rm=T),
                                     TRUE ~ unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_reg = ifelse(!is.finite(unit_in_kgr_reg), as.numeric(NA), unit_in_kgr_reg))


# I do the same for country level.
crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(unit_in_kgr_ghana = case_when(is.na(unit_in_kgr_ghana)~mean(unit_in_kgr_ghana, na.rm=T),
                                       TRUE ~ unit_in_kgr_ghana)) %>%
  mutate(unit_in_kgr_ghana = ifelse(!is.finite(unit_in_kgr_ghana), as.numeric(NA), unit_in_kgr_ghana))


# Check how many fill ups you achieve.
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_ea)
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_dist)
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_reg)
# summary(crop5_prod_w1_conv_tbl$unit_in_kgr_ghana)

# Note something. In all cases where the unit_in_kgr_ea is missing you have substituted the missing unit_in_kgr_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing unit_in_kgr_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of unit_in_kgr different from the narrower level value? If yes then plug the narrower level's value

crop5_prod_w1_conv_tbl = crop5_prod_w1_conv_tbl %>%
  ungroup() %>%
  mutate(unit_in_kgr_dist = ifelse(unit_in_kgr_dist!=unit_in_kgr_ea & !is.na(unit_in_kgr_ea), unit_in_kgr_ea, unit_in_kgr_dist)) %>%
  mutate(unit_in_kgr_reg = ifelse(unit_in_kgr_reg!=unit_in_kgr_dist & !is.na(unit_in_kgr_dist), unit_in_kgr_dist, unit_in_kgr_reg)) %>%
  mutate(unit_in_kgr_ghana = ifelse(unit_in_kgr_ghana!=unit_in_kgr_reg & !is.na(unit_in_kgr_reg), unit_in_kgr_reg, unit_in_kgr_ghana))

## As a result, in this way you have transferred the information from the narrowest level available to the largest level available.


########################################################################################################################################
########################  Merging Production - Conversion Rates in Kgr - Crop5 prices   ################################################
########################################################################################################################################


production5_conversion_prices = left_join(crop5_prod_w1_conv_tbl, crop_price_final[,c("ea_crop_unit_id","price_ea", "price_dist", "price_reg", "price_ghana")], by="ea_crop_unit_id")
# Note that from the crop price final I only need the ea_crop_unit_id and the price. The ea_crop_unit will carry all the spatial information we need.
# summary(production5_conversion_prices$price_ea)
# summary(production5_conversion_prices$price_dist)
# summary(production5_conversion_prices$price_reg)
# summary(production5_conversion_prices$price_ghana)
# Here I am going to perform the usual generalizations but for the price now.

# Now what I want to do is the following. I fill up the price_dist. If there is a missing value I fill it up with the mean of price_dist that belong to
# the same district - if it is filled up I leave it as it is.
production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  group_by(dist_crop_unit_id) %>%
  mutate(price_dist = case_when(is.na(price_dist)~mean(price_dist, na.rm=T),
                                TRUE ~ price_dist)) %>%
  mutate(price_dist = ifelse(!is.finite(price_dist), as.numeric(NA), price_dist))

# I do the same for regional level.
production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  group_by(reg_crop_unit_id) %>%
  mutate(price_reg = case_when(is.na(price_reg)~mean(price_reg, na.rm=T),
                               TRUE ~ price_reg)) %>%
  mutate(price_reg = ifelse(!is.finite(price_reg), as.numeric(NA), price_reg))

# I do the same for country level.
production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  group_by(crop_unit_id) %>%
  mutate(price_ghana = case_when(is.na(price_ghana)~mean(price_ghana, na.rm=T),
                                 TRUE ~ price_ghana)) %>%
  mutate(price_ghana = ifelse(!is.finite(price_ghana), as.numeric(NA), price_ghana))
# Check what you managed to fill up
# summary(production5_conversion_prices$price_ea)
# summary(production5_conversion_prices$price_dist)
# summary(production5_conversion_prices$price_reg)
# summary(production5_conversion_prices$price_ghana)

# Note something. In all cases where the price_ea is missing you have substituted the missing price_dist/reg/ghana with the mean coming from the available data. However,
# this has resulted in cases (all with missing price_ea) where while you have data on the district level - you have substituted the regional level with its mean - this is due to
# the fact that you have used only the column to decide whether you fill it up or not. However, in those cases you need to keep the most accurate mean which is the value of the narrower
# level. As a result, you need to go through the columns again and ask 1. Is the value of price different from the narrower level value? If yes then plug the narrower level's value

production5_conversion_prices = production5_conversion_prices %>%
  ungroup() %>%
  mutate(price_dist = ifelse(price_dist!=price_ea & !is.na(price_ea), price_ea, price_dist)) %>%
  mutate(price_reg = ifelse(price_reg!=price_dist & !is.na(price_dist), price_dist, price_reg)) %>%
  mutate(price_ghana = ifelse(price_ghana!=price_reg & !is.na(price_reg), price_reg, price_ghana))

# Check what you managed to fill up
# summary(production5_conversion_prices$price_ea)      # Note that for 4729-3978 = 751 plots you have exact ea_crop_unit_id prices per unit.
# summary(production5_conversion_prices$price_dist)    # For 4729-3750 = 979 plots you have exact district_crop_unit_id prices per unit
# summary(production5_conversion_prices$price_reg)     # For 4729-2020 = 2709 plots you have exact reg_crop_unit_id prices per unit
# summary(production5_conversion_prices$price_ghana)   # For 4729-630 = 4099 plots you have exact crop_unit_id prices per unit.


# With this you have transferred all necessary price information at the column price_ghana.
production5_conversion_prices_final = production5_conversion_prices %>%
  select(id1, id2, id3, hhno, plot_id,s4v_a153i, s4v_a154ii, s4v_a154i, unit_in_kgr_ghana, price_ghana)

colnames(production5_conversion_prices_final)[colnames(production5_conversion_prices_final)=="s4v_a153i"]="crop5_code"
colnames(production5_conversion_prices_final)[colnames(production5_conversion_prices_final)=="s4v_a154i"]="quantity5_harvested"
colnames(production5_conversion_prices_final)[colnames(production5_conversion_prices_final)=="s4v_a154ii"]="unit5_code"

production5_conversion_prices_final = production5_conversion_prices_final %>%
  filter(!is.na(unit_in_kgr_ghana)) %>%
  filter(!is.na(price_ghana))  %>%             ### We manage to get 66 plots out of 235 for which we have both conversion rates and prices per unit. Hence we can
  mutate(wave=1)  %>%                            # obtain a monetary value of.
  select(wave, id1, id2, id3, hhno, plot_id, crop5_code, quantity5_harvested, unit5_code,
         unit_in_kgr_ghana, price_ghana)


production_w1c5 = production5_conversion_prices_final %>%
  mutate(ea_crop5_unit = paste(id3, crop5_code, unit5_code, sep=".")) %>%
  mutate(quantity5_in_kgr = quantity5_harvested*unit_in_kgr_ghana) %>%
  mutate(value_w1c5 = quantity5_harvested*price_ghana) %>%
  select(wave, id1, id2, id3, hhno, plot_id, ea_crop5_unit, quantity5_harvested, quantity5_in_kgr, value_w1c5)




#########################################################################################################################################
###################                      Merge all the crops of the plots                           #####################################
#########################################################################################################################################


# There is one problem in the merging. Some plots might NOT have crop 1 but they DO have crop 2... As a result, each crop is not a subset of the previous one.
# The problem arises because in crop 1 at some point I cleared out the plots that did not have any crop. I resolve this by taking the plot_ids from the crop and not
# from the production_w1c1


production_w1 = full_join(crop_prod[,c("id1", "id2", "id3","hhno", "plot_id")],production_w1c1[, c("plot_id","ea_crop1_unit", "quantity_harvested", "quantity1_in_kgr", "value_w1c1")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c2[, c("plot_id","ea_crop2_unit", "quantity2_harvested", "quantity2_in_kgr", "value_w1c2")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c3[, c("plot_id","ea_crop3_unit", "quantity3_harvested", "quantity3_in_kgr", "value_w1c3")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c4[, c("plot_id","ea_crop4_unit", "quantity4_harvested", "quantity4_in_kgr", "value_w1c4")], by='plot_id')
production_w1 = full_join(production_w1,production_w1c5[, c("plot_id","ea_crop5_unit", "quantity5_harvested", "quantity5_in_kgr", "value_w1c5")], by='plot_id')

production_w1_final_minor = production_w1 %>%
  group_by(plot_id) %>%
  mutate(tot_production_in_kgr = sum(quantity1_in_kgr, quantity2_in_kgr,quantity3_in_kgr, quantity4_in_kgr, quantity5_in_kgr, na.rm = T)) %>% # Note that you are summing up quantities in kgr but maybe they are different crops.....
  mutate(tot_production_value  = sum(value_w1c1,value_w1c2,value_w1c3,value_w1c4,value_w1c5, na.rm=T)) %>%
  select(id1, id2, id3, hhno, plot_id, tot_production_in_kgr, tot_production_value) %>%
  filter(!is.na(plot_id))

# Note that for wave 1 you have NOT added the expected harvest - however in wave 1 the expected harvest for the specific plot is referred in questions A.85 which is a y/n question
# and in the followup A.86 which asks about the value of the expected harvest if sold in the market. Therefore, I will just add the corresponding questions for each crop and add the
# market value of the expected harvest to the total_production_value column in the production_w1_final dataframe above.

exp_harvest_w1 = crop_prod %>%
  select(id1, id2, id3, hhno, s4av2_plotno,
         s4v_a126i, s4v_a126ii,                 # Market value of crop 1 in cedis and pesewas respectively.
         s4v_a134i, s4v_a133ii,                 # Market value of crop 2 in cedis and pesewas respectively.
         s4v_a142i, s4v_a142ii,                 # Market value of crop 3 in cedis and pesewas respectively.
         s4v_a150i, s4v_a150ii,               # Market value of crop 4 in cedis and pesewas respectively.
         s4v_a158i, s4v_a158ii) %>%           # Market value of crop 5 in cedis and pesewas respectively.
  mutate(plot_id = as.numeric(paste(hhno, s4av2_plotno, sep=""))) %>%
  group_by(plot_id) %>%
  mutate(pes_in_cedis_crop1 = s4v_a126ii*0.01) %>%
  mutate(pes_in_cedis_crop2 = s4v_a133ii*0.01) %>%
  mutate(pes_in_cedis_crop3 = s4v_a142ii*0.01) %>%
  mutate(pes_in_cedis_crop4 = s4v_a150ii*0.01) %>%
  mutate(pes_in_cedis_crop5 = s4v_a158ii*0.01) %>%
  mutate(exp_crop1 = sum(s4v_a126i,pes_in_cedis_crop1, na.rm = T)) %>%
  mutate(exp_crop2 = sum(s4v_a134i,pes_in_cedis_crop2, na.rm = T)) %>%
  mutate(exp_crop3 = sum(s4v_a142i,pes_in_cedis_crop3, na.rm = T)) %>%
  mutate(exp_crop4 = sum(s4v_a150i,pes_in_cedis_crop4, na.rm = T)) %>%
  mutate(exp_crop5 = sum(s4v_a158i,pes_in_cedis_crop5, na.rm = T)) %>%
  mutate(tot_exp_harvest = sum(exp_crop1, exp_crop2, exp_crop3, exp_crop4, exp_crop5, na.rm = T)) %>%
  filter(tot_exp_harvest>=0) %>%
  filter(!is.na(plot_id)) %>%
  select(plot_id, tot_exp_harvest)



# Now add the exp_harvest_w1 to the production_w1_final and derive the total_value.
production_w1_final_minor = left_join(production_w1_final_minor, exp_harvest_w1, by="plot_id") %>%
  group_by(plot_id) %>%
  mutate(total_production_harv_exp_value = sum(tot_production_value, tot_exp_harvest, na.rm = T)) %>%
  select(-tot_production_value, -tot_exp_harvest)

colnames(production_w1_final_minor)[colnames(production_w1_final_minor)=="total_production_harv_exp_value"]="tot_production_value"

# summary(production_w1_final$tot_production_value)
# summary(production_w1_final_minor$tot_production_value)
```


\par 
From these calculations, we have derived the per plot total production in kgr and its value in cedis for the last harvest season in wave 1 (major + minor): 

<!-- # ```{r summary stats for tot prod in kgr and tot prod value in cedis for wave 1 major minor} -->
<!-- # pander(summary(production_w1_final$tot_production_value), caption = 'Value of production in cedis (wave 1 major)') -->
<!-- # pander(summary(production_w1_final_minor$tot_production_value), caption = 'Value of production in cedis (wave 1 minor)') -->
<!-- #  -->
<!-- # ``` -->


```{r total production minor and major in wave 1}
production_w1_final_major_minor = full_join(production_w1_final, production_w1_final_minor, by = c('id1', 'id2', 'id3', 'hhno', 'plot_id')) %>% 
  ungroup() %>% 
  mutate(tot_production_inkgr_season = rowSums(select(.,6,8), na.rm = T)) %>% 
  mutate(tot_production_value_season = rowSums(select(.,7,9), na.rm = T)) %>% 
  select(-contains('tot_production_in_kgr'), -contains('tot_production_value.')) %>% 
  mutate(wave =1) %>% 
  select(wave, id1, id2, id3, hhno, plot_id, tot_production_inkgr_season, tot_production_value_season)
# Notice that some entries have 0 tot_production in kgr but positive value. This is due to the fact that the value was caclculated by the 
# product of quantity harvested (in reported units) * the price per unit by Andre's data. And there was no matching from the conversion in 
# kgr table to fill the quanity in kgr. 

```



```{r summary stats of tot production value in wave 1}
pander(summary(production_w1_final_major_minor$tot_production_value_season), caption = 'Value of production in cedis (wave 1)') 
```




<!-- # ```{r summary wave 1 production and value,  results='asis'} -->
<!-- # pander(summary(production_w1_final_major_minor$tot_production_inkgr_season), caption = "Total production per plot for the last season (in kgr)") -->
<!-- # pander(summary(production_w1_final_major_minor$tot_production_value_season), caption = "Market value in for the per plot production (in cedis)") -->
<!-- # ``` -->



\par 
In wave 2 things are simpler, as we do not need to use data outside the survey data. In wave 2 under the crop-sales section, the survey asks the per unit price in which respondents sold their crops. However, this varies according to whom the crops was sold to. In fact they have different categories (market price, community price, other community price, pre-harvest contractors, trade organization price, aggregators price, outgrowers price, cooperatives price and other) of buyers and for each of those, the respondent reports the per unit price charged. We use the mean price per unit over all those categories to derive the market value of production.  



```{r Market value of production wave 2}
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#############################                                    ################################################
#############################             WAVE 2                 ################################################
#############################                                    ################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################
#################################################################################################################

################################################################################################################################
#############################  PRODUCTIVITY MEASURE WAVE 2 ONLY VERSION  #######################################################
################################################################################################################################
crop_prod_wave2 = read_dta("./04n_harvestquestions.dta")


crop_prod_w2 = crop_prod_wave2 %>% 
  select(FPrimary, plotid, cropname, cropcode, harvestunit, harvestunitother, harvestquantity,
         harvestexpectunits, harvestexpectunitsother, harvestexpectquantity) %>% 
  mutate(plot_id = as.numeric(paste(FPrimary, plotid, sep=""))) %>% 
  select(FPrimary, plot_id, cropname, cropcode, harvestunit, harvestunitother, harvestquantity,
         harvestexpectunits, harvestexpectunitsother, harvestexpectquantity) %>% 
  mutate(FPrimary = as.numeric(FPrimary))
colnames(crop_prod_w2)[colnames(crop_prod_w2)=="FPrimary"]="hhno"

# Note that there are no info on id1, id2, id3 which we need in order to create the ea_crop_unit id. 
crop_prod_w2 = left_join(crop_prod_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(id1, id2, id3, hhno, plot_id, cropcode,harvestunit,harvestunitother, harvestquantity,
         harvestexpectunits, harvestexpectunitsother, harvestexpectquantity) %>% 
  mutate(cropcode = as.numeric(crop_prod_w2$cropcode)) %>% 
  mutate(harvestunit = as.numeric(crop_prod_w2$harvestunit)) %>% 
  mutate(harvestexpectunits = as.numeric(crop_prod_w2$harvestexpectunits))

# Fix a bit the 95 harvestunits cause there are much that can be matched 
crop_prod_w2 = crop_prod_w2 %>% 
  mutate(harvestunit = case_when(harvestunitother == "TUBERS"~26,
                                 harvestunitother == "tubers"~26,
                                 harvestunitother == "TUBER"~26,
                                 harvestunitother == "tubes"~26,
                                 harvestunitother == "tuber"~26,
                                 harvestunitother == "tonne"~24,
                                 harvestunitother == "tonnes"~24,
                                 harvestunitother == "sets"~36,
                                 harvestunitother == "COCOABAG"~18,
                                 harvestunitother == "cocoa sack"~18,
                                 harvestunitother == "COCOA BAG"~18,
                                 harvestunitother == "Cocoa bag 64kg"~18,
                                 harvestunitother == "cocoa bag 64kg"~18,
                                 harvestunitother == "BASKET"~4,
                                 harvestunitother == "Fertizer bag 50kg"~18,
                                 harvestunitother == "FRUITS"~12,
                                 harvestunitother == "WHOLE FRUIT"~12,
                                 harvestunitother == "Dozen"~31,
                                 harvestunitother == "kg"~14,
                                 harvestunitother == "WOODEN BOXES"~7,
                                 TRUE ~ harvestunit
  )) %>% 
  mutate(harvestexpectunits = case_when(harvestexpectunitsother == "TUBERS"~26,
                                        harvestexpectunitsother == "tubers"~26,
                                        harvestexpectunitsother == "TUBER"~26,
                                        harvestexpectunitsother == "tubes"~26,
                                        harvestexpectunitsother == "tuber"~26,
                                        harvestexpectunitsother == "tonne"~24,
                                        harvestexpectunitsother == "tonnes"~24,
                                        harvestexpectunitsother == "sets"~36,
                                        harvestexpectunitsother == "COCOABAG"~18,
                                        harvestexpectunitsother == "cocoa sack"~18,
                                        harvestexpectunitsother == "COCOA BAG"~18,
                                        harvestexpectunitsother == "Cocoa bag 64kg"~18,
                                        harvestexpectunitsother == "cocoa bag 64kg"~18,
                                        harvestexpectunitsother == "BASKET"~4,
                                        harvestexpectunitsother == "Fertizer bag 50kg"~18,
                                        harvestexpectunitsother == "FRUITS"~12,
                                        harvestexpectunitsother == "WHOLE FRUIT"~12,
                                        harvestexpectunitsother == "Dozen"~31,
                                        harvestexpectunitsother == "kg"~14,
                                        harvestexpectunitsother == "WOODEN BOXES"~7,
                                        TRUE ~ harvestexpectunits
  )) %>% 
  select(-harvestunitother, -harvestexpectunitsother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>%
  mutate(harvestunit = formatC(as.numeric(harvestunit), width = 2, flag = "0")) %>% 
  mutate(harvestexpectunits = formatC(as.numeric(harvestexpectunits), width = 2, flag = "0"))

# Separate the harvested and the expected to harvest because there are instances in which they have different measurement unit 
crop_prod_w2_harv = crop_prod_w2 %>% 
  select(id1, id2, id3, hhno, plot_id, cropcode, harvestunit, harvestquantity) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, harvestunit, sep=".")) %>% 
  mutate(dist_crop_unit_id = paste(id2, cropcode, harvestunit, sep=".")) %>% 
  mutate(reg_crop_unit_id = paste(id1, cropcode, harvestunit, sep=".")) %>% 
  mutate(crop_unit_id = paste(cropcode, harvestunit, sep="."))


crop_prod_w2_exp = crop_prod_w2 %>% 
  select(id1, id2, id3, hhno, plot_id, cropcode, harvestexpectunits, harvestexpectquantity) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, harvestexpectunits, sep=".")) %>% 
  mutate(dist_crop_unit_id =paste(id2, cropcode, harvestexpectunits, sep=".")) %>% 
  mutate(reg_crop_unit_id = paste(id1, cropcode, harvestexpectunits, sep=".")) %>% 
  mutate(crop_unit_id = paste(cropcode, harvestexpectunits, sep="."))







##########################################################################################################################
#####                                   CROP SALES WAVE 2
##########################################################################################################################

# Now I check the section O of wave 2 to take the prices per unit. 
crop_sales_wave2= read_dta("./04o_cropsalesstoresquestions.dta")

## Now what I want to do first is the following. Find the mean market price per crop type, per unit and per region. 
# 1. I merge the crops sales with the key hh info to get the id region, district, ea for each hh. 

crop_sales_wave2$FPrimary = as.numeric(crop_sales_wave2$FPrimary)
crop_sales_wave2 = left_join(crop_sales_wave2, key_hh_info[,c("id1", "id2", "id3", "id4", "hhno")], by=c("FPrimary"="hhno"))

crop_sales_wave2 = crop_sales_wave2[,c(83:86, 1:82)]
colnames(crop_sales_wave2)[colnames(crop_sales_wave2)=="FPrimary"]="hhno"

##########################################################################################################################
############################### MARKET PRICE ########################################################################
##########################################################################################################################

#2. i only take from the sales section the trader market price (first I ll build a measure with only this one)
crop_sales_w2_mkt = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, traderssoldunit, traderssoldunitother, traderssoldprice) %>% 
  mutate(traderssoldunit = case_when(traderssoldunitother == "TUBERS"~26, 
                                     traderssoldunitother == "tubers"~26, 
                                     TRUE~as.numeric(traderssoldunit))) %>% 
  select(-traderssoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(traderssoldunit = formatC(as.numeric(traderssoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, traderssoldunit, sep=".")) %>% 
  filter(!is.na(traderssoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, traderssoldprice) %>% 
  filter(!is.na(ea_crop_unit_id)) %>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(traderssoldprice = case_when(counts>2~mean(traderssoldprice, na.rm = T),
                                      TRUE~as.numeric(traderssoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)

##########################################################################################################################
############################ COMMUNITY PRICE ########################################################################
##########################################################################################################################

#2. i only take from the sales section the community price 
crop_sales_w2_cons_com = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, samecommsoldunit, samecommsoldunitother, samecommsoldprice) %>% 
  mutate(samecommsoldunit = case_when(samecommsoldunitother == "tubers"~26, 
                                      samecommsoldunitother == "tuber"~26,
                                      samecommsoldunitother == "litres"~15,
                                      samecommsoldunitother == "GALLON"~14,
                                      samecommsoldunitother == "gallon"~14,
                                      TRUE~as.numeric(samecommsoldunit))) %>% 
  select(-samecommsoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(samecommsoldunit = formatC(as.numeric(samecommsoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, samecommsoldunit, sep=".")) %>% 
  filter(!is.na(samecommsoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, samecommsoldprice)%>% 
  filter(!is.na(ea_crop_unit_id)) %>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(samecommsoldprice = case_when(counts>2~mean(samecommsoldprice, na.rm = T),
                                       TRUE~as.numeric(samecommsoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)


##########################################################################################################################
########################## OTHER COMMUNITY OTHER PRICE ####################################################################
##########################################################################################################################

crop_sales_w2_cons_othercom = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, othercommsoldunit, othercommsoldunitother, othercommsoldprice) %>% 
  mutate(othercommsoldunit = case_when(othercommsoldunitother == "tubers"~26, 
                                       othercommsoldunitother == "WOODEN BOXES"~07, 
                                       TRUE~as.numeric(othercommsoldunit))) %>% 
  select(-othercommsoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(othercommsoldunit = formatC(as.numeric(othercommsoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, othercommsoldunit, sep=".")) %>% 
  filter(!is.na(othercommsoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, othercommsoldprice) %>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(othercommsoldprice = case_when(counts>2~mean(othercommsoldprice, na.rm = T),
                                        TRUE~as.numeric(othercommsoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)


##########################################################################################################################
########################## PRE-HARVEST CONTRACTORS PRICE ############################################################
##########################################################################################################################


crop_sales_w2_cons_preharvestcontr = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, contractorssoldunit, contractorssoldunitother, contractorssoldprice) %>% 
  mutate(contractorssoldunit = case_when(contractorssoldunitother == "tonne"~24, 
                                         TRUE~as.numeric(contractorssoldunit))) %>% 
  select(-contractorssoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(contractorssoldunit = formatC(as.numeric(contractorssoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, contractorssoldunit, sep=".")) %>% 
  filter(!is.na(contractorssoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, contractorssoldprice) %>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(contractorssoldprice = case_when(counts>2~mean(contractorssoldprice, na.rm = T),
                                          TRUE~as.numeric(contractorssoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)


##########################################################################################################################
##########################     TRADE-ORGANIZATION  PRICE      ############################################################
##########################################################################################################################

crop_sales_w2_cons_tradeorgs = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, orgssoldunit, orgssoldunitother, orgssoldprice) %>% 
  mutate(orgssoldunit = case_when(orgssoldunitother == "COCOABAGS"~18, 
                                  orgssoldunitother == "cocoa sack"~18, 
                                  orgssoldunitother == "cocoa bag"~18, 
                                  orgssoldunitother == "COCOA"~18,
                                  TRUE~as.numeric(orgssoldunit))) %>% 
  select(-orgssoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(orgssoldunit = formatC(as.numeric(orgssoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, orgssoldunit, sep=".")) %>% 
  filter(!is.na(orgssoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, orgssoldprice)%>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(orgssoldprice = case_when(counts>2~mean(orgssoldprice, na.rm = T),
                                   TRUE~as.numeric(orgssoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)

##########################################################################################################################
##########################         AGGREGATORS  PRICE         ############################################################
##########################################################################################################################

crop_sales_w2_cons_aggs = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, aggsoldunit, aggsoldunitother, aggsoldprice) %>% 
  mutate(aggsoldunit=as.numeric(aggsoldunit)) %>% 
  select(-aggsoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(aggsoldunit = formatC(as.numeric(aggsoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, aggsoldunit, sep=".")) %>% 
  filter(!is.na(aggsoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, aggsoldprice) %>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(aggsoldprice = case_when(counts>2~mean(aggsoldprice, na.rm = T),
                                  TRUE~as.numeric(aggsoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)


##########################################################################################################################
##########################             OUTGROWERS   PRICE     ############################################################
##########################################################################################################################


crop_sales_w2_cons_outgrows = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, outgrowsoldunit, outgrowsoldunitother, outgrowsoldprice) %>% 
  mutate(outgrowsoldunit=as.numeric(outgrowsoldunit)) %>% 
  select(-outgrowsoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(outgrowsoldunit = formatC(as.numeric(outgrowsoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, outgrowsoldunit, sep=".")) %>% 
  filter(!is.na(outgrowsoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, outgrowsoldprice)%>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(outgrowsoldprice = case_when(counts>2~mean(outgrowsoldprice, na.rm = T),
                                      TRUE~as.numeric(outgrowsoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)




##########################################################################################################################
##########################        COOPERATIVES   PRICE     ##########################################################
##########################################################################################################################


crop_sales_w2_cons_coops = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, coopsoldunit, coopsoldunitother, coopsoldprice) %>% 
  mutate(coopsoldunit=as.numeric(coopsoldunit)) %>% 
  select(-coopsoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(coopsoldunit = formatC(as.numeric(coopsoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, coopsoldunit, sep=".")) %>% 
  filter(!is.na(coopsoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, coopsoldprice)%>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(coopsoldprice = case_when(counts>2~mean(coopsoldprice, na.rm = T),
                                   TRUE~as.numeric(coopsoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)




##########################################################################################################################
##########################        MEAN OTHERS  PRICE           ##########################################################
##########################################################################################################################

crop_sales_w2_cons_others = crop_sales_wave2 %>%  
  select(id1, id2, id3, hhno, cropcode, othersoldunit, othersoldunitother, othersoldprice) %>% 
  mutate(othersoldunit=case_when(othersoldunitother=="WOODEN BOXES"~07, 
                                 othersoldunitother=="tubers"~26,
                                 TRUE~as.numeric(othersoldunit))) %>% 
  select(-othersoldunitother) %>% 
  mutate(cropcode = formatC(as.numeric(cropcode), width = 2, flag = "0")) %>% 
  mutate(othersoldunit = formatC(as.numeric(othersoldunit), width = 2, flag = "0")) %>% 
  mutate(ea_crop_unit_id = paste(id3, cropcode, othersoldunit, sep=".")) %>% 
  filter(!is.na(othersoldprice)) %>%   # Create an ea_crop_unit_id 
  select(hhno, ea_crop_unit_id, othersoldprice)%>% 
  group_by(hhno, ea_crop_unit_id) %>% 
  add_tally(name = "counts") %>% 
  mutate(othersoldprice = case_when(counts>2~mean(othersoldprice, na.rm = T),
                                    TRUE~as.numeric(othersoldprice))) %>% 
  filter(!duplicated(hhno) & !duplicated(ea_crop_unit_id)) %>% 
  select(-counts)


##########################################################################################################################
#################################### GOING BACK TO PRODUCTION NOW ####################################################
##########################################################################################################################

# Merge crop_prod_w2_harv with the prices created above. 
crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_mkt, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_com, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_othercom, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_preharvestcontr, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_tradeorgs, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_aggs, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_outgrows, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_coops, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv = left_join(crop_prod_w2_harv, crop_sales_w2_cons_others, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_harv_price = crop_prod_w2_harv %>% 
  ungroup() %>% 
  mutate(price = rowMeans(select(.,13:21), na.rm = T)) %>% 
  mutate(price = ifelse(!is.finite(price), as.numeric(NA), as.numeric(price))) %>% 
  select(-traderssoldprice, -samecommsoldprice, -othercommsoldprice,
         -contractorssoldprice, -orgssoldprice, -aggsoldprice, -outgrowsoldprice,
         -coopsoldprice, -othersoldprice) %>%
  group_by(ea_crop_unit_id) %>% 
  mutate(price_ea = case_when(is.na(price) & !is.na(ea_crop_unit_id)~mean(price, na.rm = T),
                              TRUE~as.numeric(price))) %>% 
  mutate(price_ea =case_when(!is.finite(price_ea)~as.numeric(NA), 
                             TRUE~as.numeric(price_ea))) %>% 
  ungroup() %>% 
  group_by(dist_crop_unit_id) %>% 
  mutate(price_dist = case_when(is.na(price_ea) & !is.na(dist_crop_unit_id)~mean(price_ea, na.rm = T),
                                TRUE~as.numeric(price_ea))) %>% 
  mutate(price_dist =case_when(!is.finite(price_dist)~as.numeric(NA), 
                               TRUE~as.numeric(price_dist))) %>%
  ungroup() %>% 
  group_by(reg_crop_unit_id) %>% 
  mutate(price_reg = case_when(is.na(price_dist) & !is.na(reg_crop_unit_id)~mean(price_dist, na.rm=T), 
                               TRUE~as.numeric(price_dist))) %>% 
  mutate(price_reg = case_when(!is.finite(price_reg)~as.numeric(NA), 
                               TRUE~as.numeric(price_reg))) %>% 
  ungroup() %>% 
  group_by(crop_unit_id) %>% 
  mutate(price_ghana = case_when(is.na(price_reg) & !is.na(crop_unit_id)~mean(price_reg, na.rm = T), 
                                 TRUE~as.numeric(price_reg))) %>% 
  mutate(price_ghana = case_when(!is.finite(price_ghana)~as.numeric(NA), 
                                 TRUE~as.numeric(price_ghana))) %>% 
  ungroup()

####
# Note that with this you have trasferred all information in the price_ghana - so just keep this. 
crop_prod_w2_harv_price = crop_prod_w2_harv_price %>% 
  select(id1, id2, id3, hhno, plot_id, cropcode, harvestunit, harvestquantity, ea_crop_unit_id, price_ghana) %>% 
  mutate(total_mkt_value_harv = harvestquantity*price_ghana) %>% 
  group_by(plot_id, cropcode) %>% 
  add_tally() %>% 
  filter(!duplicated(plot_id) & !is.na(harvestunit)) %>% 
  select(-n) %>% 
  ungroup()

colnames(crop_prod_w2_harv_price)[colnames(crop_prod_w2_harv_price)=="ea_crop_unit_id"]="ea_crop_unit_id_harv"


####
# Merge crop_prod_w2_exp with the prices created above. 
crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_mkt, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_com, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_othercom, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_preharvestcontr, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_tradeorgs, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_aggs, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_outgrows, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_coops, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp = left_join(crop_prod_w2_exp, crop_sales_w2_cons_others, by=c("hhno", "ea_crop_unit_id"))

crop_prod_w2_exp_price = crop_prod_w2_exp %>% 
  ungroup() %>% 
  mutate(price = rowMeans(select(.,13:21), na.rm = T)) %>% 
  mutate(price = ifelse(!is.finite(price), as.numeric(NA), as.numeric(price))) %>% 
  select(-traderssoldprice, -samecommsoldprice, -othercommsoldprice,
         -contractorssoldprice, -orgssoldprice, -aggsoldprice, -outgrowsoldprice,
         -coopsoldprice, -othersoldprice) %>%
  group_by(ea_crop_unit_id) %>% 
  mutate(price_ea = case_when(is.na(price) & !is.na(ea_crop_unit_id)~mean(price, na.rm = T),
                              TRUE~as.numeric(price))) %>% 
  mutate(price_ea =case_when(!is.finite(price_ea)~as.numeric(NA), 
                             TRUE~as.numeric(price_ea))) %>% 
  ungroup() %>% 
  group_by(dist_crop_unit_id) %>% 
  mutate(price_dist = case_when(is.na(price_ea) & !is.na(dist_crop_unit_id)~mean(price_ea, na.rm = T),
                                TRUE~as.numeric(price_ea))) %>% 
  mutate(price_dist =case_when(!is.finite(price_dist)~as.numeric(NA), 
                               TRUE~as.numeric(price_dist))) %>%
  ungroup() %>% 
  group_by(reg_crop_unit_id) %>% 
  mutate(price_reg = case_when(is.na(price_dist) & !is.na(reg_crop_unit_id)~mean(price_dist, na.rm=T), 
                               TRUE~as.numeric(price_dist))) %>% 
  mutate(price_reg = case_when(!is.finite(price_reg)~as.numeric(NA), 
                               TRUE~as.numeric(price_reg))) %>% 
  ungroup() %>% 
  group_by(crop_unit_id) %>% 
  mutate(price_ghana = case_when(is.na(price_reg) & !is.na(crop_unit_id)~mean(price_reg, na.rm = T), 
                                 TRUE~as.numeric(price_reg))) %>% 
  mutate(price_ghana = case_when(!is.finite(price_ghana)~as.numeric(NA), 
                                 TRUE~as.numeric(price_ghana))) %>% 
  ungroup()

####
# Note that with this you have trasferred all information in the price_ghana - so just keep this. 
crop_prod_w2_exp_price = crop_prod_w2_exp_price %>% 
  select(id1, id2, id3, hhno, plot_id, cropcode, harvestexpectunits, harvestexpectquantity, ea_crop_unit_id, price_ghana) %>% 
  mutate(total_mkt_value_exp = harvestexpectquantity*price_ghana) %>% 
  group_by(plot_id, cropcode) %>% 
  add_tally() %>%  
  filter(!duplicated(plot_id) & !is.na(harvestexpectunits)) %>% 
  select(-n) %>% 
  ungroup()

colnames(crop_prod_w2_exp_price)[colnames(crop_prod_w2_exp_price)=="ea_crop_unit_id"]="ea_crop_unit_id_exp"

####
# Merge back crop_prod_w2_har_price and crop_prod_w2_exp_price
crop_prod_w2_value = left_join(crop_prod_w2_harv_price[,c("id1", "id2", "id3", "hhno", "plot_id", "cropcode","ea_crop_unit_id_harv", "total_mkt_value_harv")],
                               crop_prod_w2_exp_price[,c("plot_id", "cropcode", "ea_crop_unit_id_exp","total_mkt_value_exp")],
                               by=c("plot_id", "cropcode")) %>%
  group_by(plot_id, cropcode) %>% 
  mutate(total_mkt_value = sum(total_mkt_value_harv, total_mkt_value_exp, na.rm=T)) %>% 
  ungroup() %>% 
  select(-cropcode, -ea_crop_unit_id_harv, -total_mkt_value_harv, -ea_crop_unit_id_exp, -total_mkt_value_exp) %>% 
  group_by(plot_id) %>% 
  mutate(total_mkt_value = sum(total_mkt_value, na.rm = T)) %>% 
  filter(!duplicated(plot_id))

```




```{r Merge the two wave with respect to total mkt value of production}

production_w1_final_major_minor_tomerge = production_w1_final_major_minor %>% mutate(wave = 1) %>% 
  select(wave, id1, id2, id3, hhno, plot_id, tot_production_value_season)

crop_prod_w2_value_tomerge = crop_prod_w2_value %>% mutate(wave= 2) %>% 
  select(wave, id1, id2, id3, hhno, plot_id, total_mkt_value)

colnames(crop_prod_w2_value_tomerge)[colnames(crop_prod_w2_value_tomerge)=="total_mkt_value"]="tot_production_value_season"

production_value= rbind(data.frame(production_w1_final_major_minor_tomerge), data.frame(crop_prod_w2_value_tomerge)) %>% 
                  mutate(across(contains("season"),  #annual
                               list(~ifelse((wave ==2), .*0.6013, .)),
                               .names="{.col}_defl")) 



```


```{r summary statistics of total production value}
# deflated measure - net fin income
pander(summary(subset(production_value, wave==1)$tot_production_value_season_defl), caption = "Production value in w.1 (in cedis plot level)")
pander(summary(subset(production_value, wave==2)$tot_production_value_season_defl), caption = "Production value in w.2 (in 2009 cedis plot level)")
```



















\section{Detour on crop sales net income}
\par 
Now we go back in calculating net-income and we perform the following two alterations:
\begin{enumerate}
\item We add an extra land cost for sharecropping. This is done by accounting for the percentage of crop production that was given to the landlord. 
\end{enumerate}



```{r sharecropping}
# wave
sharecrop_w1 = read_dta("./S4AIV.dta") %>% 
               select(id1, id2, id3, hhno, s4aiv_plotno, s4aiv_a58) %>% 
               filter(!is.na(s4aiv_plotno)) %>% 
               mutate(plot_id = as.numeric(paste(hhno, s4aiv_plotno, sep=""))) %>% 
               select(id1, id2, id3, hhno, plot_id, s4aiv_a58) %>% 
               mutate(perc_crops_to_owner = case_when(s4aiv_a58 == 1 ~ 0, 
                                                      s4aiv_a58 == 2 ~ 0.67, 
                                                      s4aiv_a58 == 3 ~ 0.50, 
                                                      s4aiv_a58 == 4 ~ 0.33, 
                                                      s4aiv_a58 == 5 ~ 0.25, 
                                                      s4aiv_a58 == 6 ~ 0.20, 
                                                      TRUE ~ as.numeric(0))) %>% 
               mutate(wave=1) %>% 
               select(wave, id1, id2, id3, hhno, plot_id, perc_crops_to_owner)


# wave 2
sharecrop_w2 = read_dta("./04i_landtenure.dta") %>% 
               select(FPrimary, plotid, scroppedproportion) %>% 
               mutate(plot_id = as.numeric(paste(FPrimary, plotid, sep=""))) %>%
               mutate(hhno = as.numeric(FPrimary)) %>% 
               mutate(perc_crops_to_owner = case_when(scroppedproportion == 1 ~ 0.67, 
                                                      scroppedproportion == 2 ~ 0.50, 
                                                      scroppedproportion == 3 ~ 0.33, 
                                                      scroppedproportion == 4 ~ 0.25, 
                                                      scroppedproportion == 5 ~ 0.20, 
                                                      TRUE ~ as.numeric(0))) %>% 
               mutate(wave=2) %>% 
               select(wave, hhno, plot_id, perc_crops_to_owner)

# Merge it with the key hh info to get the id1, id2, id3, 
sharecrop_w2 = left_join(sharecrop_w2, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, plot_id, perc_crops_to_owner)

sharecrop =rbind(data.frame(sharecrop_w1), data.frame(sharecrop_w2))

# Next merge the sharecrop with the production value 
production_value_acc_sharecrop = left_join(production_value, sharecrop, by = c('wave', 'id1', 'id2', 'id3', 'hhno', 'plot_id')) %>% 
                                 ungroup() %>% 
                                 mutate(tot_production_value_season_acc_sharecrop = tot_production_value_season*(1-perc_crops_to_owner)) %>%                                  group_by(wave, hhno) %>% 
                                 mutate(tot_production_value_season_acc_sharecrop = sum(tot_production_value_season_acc_sharecrop, na.rm=T)) %>%                              filter(!duplicated(hhno)) %>% 
                                 select(wave, id1, id2, id3, hhno, tot_production_value_season_acc_sharecrop) %>% 
                                 mutate(tot_production_value_season_acc_sharecrop_defl = case_when(wave==2 ~tot_production_value_season_acc_sharecrop*0.67, TRUE~ tot_production_value_season_acc_sharecrop ))
                                 
```


```{r summary statistics of production value with sharecropping accounted for}
pander(summary(subset(production_value_acc_sharecrop, wave ==1)$tot_production_value_season_acc_sharecrop_defl), caption = 'Value of production - accounting for sharecropping costs (wave 1 in cedis hhlevel)')
pander(summary(subset(production_value_acc_sharecrop, wave ==2)$tot_production_value_season_acc_sharecrop_defl), caption = 'Value of production - accounting for sharecropping costs (wave 2 in 2009 cedis hhlevel)')
```


\begin{enumerate}
\item[2] We replace crop-sale income w/ total production value (accounting for sharecropping costs) in df: crop-sales-net-income. We end up with the following summary statistics 
\end{enumerate}

```{r replace cropsales income with market value of crops}
# Merge it with crop_sales_net_income
crop_sales_income_mkt_value = left_join(crop_sales_net_income, production_value_acc_sharecrop, by = c('wave', 'id1', 'id2', 
                                                                                                                'id3', 'hhno')) %>% 
                               select(-cropsales_income_defl, -tot_production_value_season_acc_sharecrop, -crop_sales_net_income_defl) %>%
                               ungroup() %>% 
                               mutate(crop_prod_net_income_defl = tot_production_value_season_acc_sharecrop_defl + tot_crop_costs_defl) %>% 
                               filter(!is.na(crop_prod_net_income_defl))
  
```

\par 
Notice that the two tables below show crop production net income where in the revenues side we have replaced crop sales income (from the crop sales section) with the market value of production derived above. Moreover, here we have accounted for the cost of land sharing for those plots that practise so. 

```{r summary statistics of the alternative crops production income}
pander(summary(subset(crop_sales_income_mkt_value, wave ==1)$crop_prod_net_income_defl), caption = 'Crop production net income (wave 1 in cedis hhlevel)')
pander(summary(subset(crop_sales_income_mkt_value, wave ==2)$crop_prod_net_income_defl), caption = 'Crop production net income (wave 2 in 2009 cedis hhlevel)')
```


```{r Gather all net incomes together for the alternative income measure}

all_net_incomes.ii = full_join(crop_sales_income_mkt_value, mainoccupation_income , by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes.ii = full_join(all_net_incomes.ii, secoccupation_income, by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes.ii = full_join(all_net_incomes.ii, nonfarm_enterprise, by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes.ii = full_join(all_net_incomes.ii, animal_income, by = c('wave', 'id1', 'id2', 'id3', 'hhno'))
all_net_incomes.ii = full_join(all_net_incomes.ii, financial_income, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) %>% 
  group_by(wave, hhno) %>% 
  mutate(across(contains('income'), ~sum(.,na.rm=T))) %>% 
  filter(!duplicated(hhno)) %>% 
  ungroup() %>% 
  select(wave, id1, id2, id3, hhno, contains('defl')) %>% 
    mutate(across(contains('defl'), ~replace_na(.,0))) %>% 
  rowwise() %>% 
    mutate(total_net_income = sum(crop_prod_net_income_defl,mainocc_income_annual_defl,secocc_income_annual_defl,profits_annual_defl,anim_income_defl,gross_finincome_defl, na.rm = T))




```

\par 
Finally, using we can derive the total net income where we have used the market value of production derived in this section on the revenues side - accounting for sharecropping costs and adding all other sources of income as in the previous analysis (net finincome, main occupation, sec occupation animal income etc). We can compare this measure with tables 50 and 51. 

```{r display distribution of total net income deflated for the alternative measure}
# deflated measure - net fin income
pander(summary(subset(all_net_incomes.ii, wave==1)$total_net_income), caption = "net income in w.1 (in cedis)")
pander(summary(subset(all_net_incomes.ii, wave==2)$total_net_income), caption = "net income in w.2 (in 2009 cedis)")
```



\newpage 
\section{Productivity Measure}
\par 
In order to derive a productivity measure, we are using the market value of production per plot and we divide it by the size of plot in order to have a cedis/hectare productivity measure. 
\par 
To derive it at the household level, we take the weighted sum of the per plot prodcutivities belonging to the same hh where the weights are the relative size of the plot to the household land holdings. We also use the deflated measure of total value of production for wave 2. 

```{r Land information}
land_info = read_dta("./s4h_agsection_panel.dta") # it has both waves
# Select the relevant information
land_size = land_info %>%  
  select(wave, FPrimary, plotid, plotsizeunit, totalsize, area_ha) %>% 
  mutate(FPrimary = as.numeric(FPrimary)) %>% 
  mutate(plot_no = as.numeric(substr(plotid,3,3))) %>% 
  mutate(plot_id = as.numeric(paste(FPrimary, plot_no, sep=""))) %>% 
  select(wave, FPrimary, plot_id, plotsizeunit, totalsize, area_ha) %>% 
  mutate(plotsizeunit =as.numeric(plotsizeunit)) %>% 
  filter(plotsizeunit !=95) %>%  
  mutate(plotsize_ha = case_when(plotsizeunit == 1~totalsize*0.4046945,
                                 plotsizeunit == 2~totalsize*0.4095508,
                                 plotsizeunit == 3~totalsize*0.2363416,
                                 plotsizeunit == 4~totalsize*0.1023877,
                                 TRUE~as.numeric(NA)))

land_size_w1 = land_size %>% 
  filter(wave==1) %>% 
  group_by(plot_id) %>% 
  add_tally(name="counts") %>%  # Note that there are 6  plots with plot_id that appears twice. For those I use the mean size and 
  mutate(plotsize_ha = case_when(counts==2~mean(plotsize_ha, na.rm = T),
                                 TRUE~as.numeric(plotsize_ha))) %>% 
  filter(!duplicated(plot_id)) %>% 
  select(-counts, -area_ha)


land_size_w2 = land_size %>% 
  filter(wave==2) %>% 
  group_by(plot_id) %>% 
  add_tally(name="counts") %>%  # Note that there are 6  plots with plot_id that appears twice. For those I use the mean size and 
  mutate(plotsize_ha = case_when(counts==2~mean(plotsize_ha, na.rm = T),
                                 TRUE~as.numeric(plotsize_ha))) %>% 
  filter(!duplicated(plot_id)) %>% 
  select(-counts, -area_ha)

# Bind them back together. 
land_size = rbind(land_size_w1, land_size_w2) %>% 
  select(wave, FPrimary, plot_id, plotsize_ha)

colnames(land_size)[colnames(land_size)=="FPrimary"]="hhno"

land_size = left_join(land_size, key_hh_info[,c("id1", "id2", "id3", "hhno")], by="hhno") %>% 
  select(wave, id1, id2, id3, hhno, plot_id, plotsize_ha) %>% 
  mutate(id2 = as.numeric(id2)) %>% 
  mutate(id3 = as.numeric(id3))

```



```{r Productivity measure}
productivity_plot = left_join(production_value, land_size, by =c('wave', 'id1', 'id2', 'id3', 'hhno', 'plot_id')) %>% 
                    filter(!is.na(plotsize_ha)) %>% 
                    ungroup() %>% 
                    mutate(productivity_plot_cedha = tot_production_value_season_defl/plotsize_ha) %>% 
                    filter(is.finite(productivity_plot_cedha))

```



```{r display distribution plot productivity}
# deflated measure - net fin income
pander(summary(subset(productivity_plot, wave==1)$productivity_plot_cedha), caption = "plot productivity in w.1 (cedis per hectare)")
pander(summary(subset(productivity_plot, wave==2)$productivity_plot_cedha), caption = "plot productivity in w.2 (2009 cedis per hectare)")
```


\par 
We also present at the hh level

```{r}
productivity_hh = productivity_plot %>% 
                  group_by(wave, hhno) %>% 
                  mutate(hh_land = sum(plotsize_ha, na.rm = T)) %>% 
                  ungroup() %>% 
                  mutate(weights = plotsize_ha/hh_land) %>% 
                  group_by(wave, hhno) %>% 
                  mutate(productivity_hh = weighted.mean(productivity_plot_cedha, weights)) %>% 
                  filter(!duplicated(hhno)) %>% 
                  select(-tot_production_value_season, -productivity_plot_cedha, -weights, -tot_production_value_season_defl, -plot_id)

```


```{r display distribution hh productivity}
# deflated measure - net fin income
pander(summary(subset(productivity_hh, wave==1)$productivity_hh), caption = "hh productivity in w.1 (cedis per hectare)")
pander(summary(subset(productivity_hh, wave==2)$productivity_hh), caption = "hh productivity in w.2 (2009 cedis per hectare)")
```



\newpage
\section{Regression Analysis}
```{r Key hh info and hh size to derive vil-population and number of hhs}

village.demographics = left_join(hh_size, key_hh_info, by = c( 'hhno')) %>% 
                       select(wave, id1, id2, id3, urbrur, hhno, hhsize, hh_weightsize) %>% 
                       group_by(wave, id3) %>% 
                       add_tally(name = 'num_hhs_invil') %>% filter(!is.na(id3)) %>%
                       mutate(vil_pop = sum(hhsize, na.rm = T)) %>%
                       mutate(vil_pop_weighted = sum(hh_weightsize, na.rm = T)) %>% 
                       ungroup()

```




\par 
For the regression analysis, we use the following data: 
\begin{itemize}
\item \textbf{Consumption}: 
\begin{enumerate}
\item $consumption-levels.csv$: total consumption/total consumption nd/ deflated /winsorized. (hh level)
\item $consumption-pc$: total consumption pc/total consumption nd pc (pc2, and win-pc and win-pc2) (hh level)
\item $consumption-log.ihs$ log/ihs(consumption levels (+nd)), log/ihs(consumption(pc)) and win(log/ihs(consumption)). (hhleve)
\item $consumption-ea$ village consumption everything (at the village level), rest.ea consumptiion everything (hh level)
\end{enumerate}
\item \textbf{Income}: 
\begin{enumerate}
\item $all-net-incomes$: it contains all net incomes in the calculation and the the total net income. Here we have used crops sales income from the crop sales section of the survey. (hh level)
\item $all-net-incomes.ii$: it contains all net incomes as above but the crop income has been calculated using the market value of production and we have accounted for sharecropping costs in it. (hhlevel)
\end{enumerate}
\item \textbf{Selling rights}: 
\begin{enumerate}
\item $sell.rights_ea$: selling rights ignoring NAs (at the village level)
\item $sell.rights-ea.na0$: selling rights treating NAs as 0s (at the village level)
\end{enumerate}
\item \textbf{Land characteristics}: 
\begin{enumerate}
\item $land-controls$:  with years of use, can fallow, chemicals number, boundaries conflict, lose title, given to someone else, taken, had dispute, claims, contract, purchased, inherit, can put as security, rent, allocated free, can sell, deep land, wet land, otherthanrain water source, irrigation investments plant trees (at the village level). Those measures have been calculated both as a share of plots that have those characteristics, wieghted share of plots at the village level based on the relaitve size of the plot and as average at the village level. 
\end{enumerate}
\item \textbf{Village demographics}
\begin{enumerate}
\item $village.demographics$: with the hhsize/ hhweightedsize/village population/number of hhs in each village
\end{enumerate}
\end{itemize}

```{r Land Controls}
file = "./land_controls_ealevel.csv"
land_controls = read.csv(file)
```



<!-- ################################################################################################################################################################################################################ -->
<!-- #################################################               TOWNSEND                                                          ############################################################################## -->
<!-- ################################################################################################################################################################################################################ -->



\newpage 
\section{Townsend regression}
\begin{equation}
    ihs(c_{h,v,t}) = \alpha +\beta_1\cdot ihs(y_{h,v,t}) + \beta_2\cdot ihs(y_{h,v,t})\cdot sell\text{-}rights_{v,t} + \beta_3\cdot sell\text{-}rights_{v,t} + \beta_4\cdot X_{h,v,t} + \epsilon_{h,v,t}
\label{eq:town}
\end{equation}


\subsection{Per capita}

```{r Income for regression analysis}
# First we need to put total incomes measures 1 and 2 in one df. 
income.townsend.0 = all_net_incomes %>% 
                  select(wave, id1, id2, id3, hhno, total_net_income) %>% 
                  mutate(total_net_income_cropsales = total_net_income) %>% 
                  select(-total_net_income)

income.townsend.ii = all_net_incomes.ii %>% 
                     select(wave, id1, id2, id3, hhno, total_net_income) %>% 
                     mutate(total_net_income_mktvalue = total_net_income) %>% 
                     select(-total_net_income)


income.townsend = full_join(income.townsend.0, income.townsend.ii, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) 

```

```{r Consumption for regression analysis}

consumption.townsend = consumption_levels %>% 
                       select(wave, id1, id2, id3, hhno, total_consumption_defl, total_consumption_nd_defl)

consumption.townsend = left_join(consumption.townsend, consumption_ea, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) %>% 
                       select(wave, id1, id2, id3, hhno, total_consumption_defl, total_consumption_nd_defl, 
                              village_consumption, village_consumption_nd, rest_ea_consumption, rest_ea_consumption_nd)

```


```{r Selling rights for regression analysis}
sell.rights_ea = sell.rights_ea %>% select(wave, id1,id2,id3, tot_ea_land, sell.rights_ea.weighted) %>% 
                                    mutate(tot_ea_land_ignna =tot_ea_land) %>% 
                                    mutate(sell.rights_ea.weighted.ignna = sell.rights_ea.weighted) %>% 
                                    select(-tot_ea_land, -sell.rights_ea.weighted)

sell.rights_ea.na0 = sell.rights_ea.na0 %>% select(wave, id1, id2, id3, tot_ea_land, sell.rights_ea.weighted_na0) %>% 
                                            mutate(tot_ea_land_na0 = tot_ea_land) %>% 
                                            select(wave, id1,id2, id3, tot_ea_land_na0, sell.rights_ea.weighted_na0)
```


```{r Merging for townsend}
townsend.1 = left_join(village.demographics, consumption.townsend, by = c('wave', 'id1',"id2", "id3", "hhno"))
townsend.1 = left_join(townsend.1, income.townsend, by = c('wave', 'id1',"id2", "id3", "hhno")) 
townsend.1 = left_join(townsend.1, sell.rights_ea,  by = c('wave', 'id1','id2','id3'))
townsend.1 = left_join(townsend.1, sell.rights_ea.na0,  by = c('wave', 'id1','id2','id3'))
townsend.1 = left_join(townsend.1, land_controls,  by = c('wave', 'id1','id2','id3')) %>% filter(urbrur == 'Rural')
```





```{r From pc variables in townsend.1, results = 'asis'}
# Initialize the ihs() 
ihs = function(x) log(x+(x^2+1)^0.5)
townsend.1.pc = townsend.1 %>% 
                ungroup() %>% 
                # mutate(across(c(total_consumption_defl, total_consumption_nd_defl, total_net_income_cropsales, total_net_income_mktvalue),                                        list(~ DescTools::Winsorize(., probs = c(.025, .975), na.rm = TRUE)),
                #                  .names="win_{.col}")) %>%
                mutate(across(c(total_consumption_defl, total_consumption_nd_defl, total_net_income_cropsales, total_net_income_mktvalue),
                              ~.x/hhsize,
                              .names="{.col}_pc")) %>% 
                mutate(across(contains("pc"),                         # create the winsorized levels.
                                 list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)),
                                 .names="win_{.col}")) %>%
                  mutate(across(contains('pc'), 
                              ~ihs(.x), 
                              .names="ihs_{.col}"))  %>% 
                mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                               ~.x/(vil_pop-hhsize), 
                               .names = '{.col}_pc')) %>% 
                  mutate(across(c(rest_ea_consumption_pc, rest_ea_consumption_nd_pc), 
                               list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)), 
                               .names = 'win{.col}')) %>% 
                mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                               ~.x/(num_hhs_invil - 1), 
                               .names = '{.col}_ph')) %>% 
                 mutate(across(c(rest_ea_consumption_pc, rest_ea_consumption_nd_pc, rest_ea_consumption_ph, rest_ea_consumption_nd_ph), 
                               ~ihs(.), 
                              .names="ihs_{.col}"))%>% ungroup() %>% filter(total_net_income_cropsales>=0)     
# %>% 
#                  filter(total_net_income_cropsales>=0 & total_net_income_mktvalue>=0) # Comment out to take the positive values of the crop sales income. 
#                  filter(total_net_income_mktvalue>0) Comment out to take the positive values of mkt value. 

# Comment out to take the quadratic interaction term. 
# %>% mutate(inc.cs.land.sq =total_net_income_cropsales_pc^2*sell.rights_ea.weighted_na0^2) %>% 
#     mutate(inc.mkt.land.sq =total_net_income_mktvalue_pc^2*sell.rights_ea.weighted_na0^2) %>% mutate(inc.cs.land.ign.sq =win_total_net_income_cropsales_pc^2*sell.rights_ea.weighted.ignna^2) %>%
#     mutate(inc.mkt.land.ign.sq =total_net_income_mktvalue_pc^2*sell.rights_ea.weighted.ignna^2)




```


\par
First I try with the the winsorized data at 1 pc:

```{r townsend lpm with pc variables, results = 'asis'}

town.1.pc = plm(win_total_consumption_defl_pc ~
                  win_total_net_income_cropsales_pc*sell.rights_ea.weighted.ignna
                  # + win_total_net_income_mktvalue_pc^2
                  # + sell.rights_ea.weighted_na0^2
                  # + inc.mkt.land.ign.sq
                  + winrest_ea_consumption_pc
                  + share_ea_inherit_weighted
                  + avg_ea_yrs_use_weighted
                  + avg_ea_chem_num_weighted
                  + share_ea_canfallow_weighted
                  + share_ea_months6_weighted
                  + share_ea_months12_weighted
                  + share_ea_months24_weighted
                  + share_ea_months48_weighted
                  + share_ea_monthsinf_weighted
                  + share_ea_losetitle_weighted
                  + share_ea_givenelse_weighted
                  + share_ea_taken_weighted
                  + share_ea_haddispute_weighted
                  + share_ea_boundaries_weighted
                  + share_ea_claims_weighted
                  + share_ea_contract_weighted
                  + share_ea_purchased_weighted
                  + share_ea_inherit_weighted
                  + share_ea_rent_weighted
                  + share_ea_allocfree_weighted
                  + share_ea_sell_weighted
                  + share_ea_sec_weighted
                  + share_ea_both_weighted
                  + share_ea_none_weighted
                  + share_ea_deep_weighted
                  + share_ea_wet_weighted
                  + share_ea_otherthanrain_weighted
                  + share_ea_irriginv_weighted
                  + share_ea_plantrees_weighted
                  + share_ea_chemicaluse_weighted
                  + hhsize
                  + vil_pop
                  + num_hhs_invil
                  + tot_ea_land_ignna
                  ,model = "within", data = townsend.1.pc, index = c("hhno", "wave"), effect = 'twoways')



fe1 = coeftest(town.1.pc)
# stargazer(fe1,omit = c('wave.id3'), type="text")
fe1_clustered = coeftest(town.1.pc, vcovCR(town.1.pc, townsend.1.pc$id3, type='CR0'))
# stargazer(fe1_clustered, type="text")


# stargazer(town.1.pc, town.1.pc,
#           title="Townsend Panel Regression Results selling rights ignoring NA",align=TRUE,type="latex",
#           header = FALSE,
#           dep.var.labels=c("ihs(consumption.per.capita)"),
#           # covariate.labels = c("win(net.income.pc)", "sell.rights", "win(rest.consumption_nd.pc)",
#           #                      "win(net.income.pc)*sell.rights"),
#           # column.separate = c(1,1),
#           column.sep.width = "3pt",
#           table.placement = "H", font.size = 'tiny',
#           omit=c('avg_ea_yrs_use_weighted','avg_ea_chem_num_weighted','share_ea_canfallow_weighted',"share_ea_months24_weighted",'share_ea_months48_weighted','share_ea_givenelse_weighted',                     'share_ea_taken_weighted','share_ea_haddispute_weighted','share_ea_boundaries_weighted','share_ea_claims_weighted','share_ea_contract_weighted','share_ea_purchased_weighted',                   'share_ea_inherit_weighted','share_ea_rent_weighted','share_ea_allocfree_weighted','share_ea_sec_weighted','share_ea_both_weighted','share_ea_none_weighted','share_ea_wet_weighted',                     'share_ea_otherthanrain_weighted','share_ea_irriginv_weighted','share_ea_plantrees_weighted','share_ea_chemicaluse_weighted','vil_pop_weighted_weighted', 'share_ea_months6_weighted',
#                  "share_ea_months12_weighted", 'share_ea_monthsinf_weighted',  'share_ea_losetitle_weighted','share_ea_sell_weighted',  'share_ea_deep_weighted', 'hhsize', 'vil_pop', 'num_hhs_invil', 'tot_ea_land_ignna'),
#           se = list(fe1[,"Std. Error"], fe1_clustered[,"Std. Error"]),
#           add.lines = list(c("Village + Land controls", "Yes", "Yes"),
#                            c("HH Fixed effects", "Yes", "Yes"),
#                            c("Village Clustered se", "No", "Yes")),
#           notes = "\\parbox[t]{\\textwidth}{Per capita measures with equal weights on household.  Consumption and income have been winsorized at the 1\\% level and have been transformed using the inverse hyperbolic sine transformation. Selling land rights are calculated as the weighted mean of land at the village level that can be sold and sold/act as security - weights are based on plot size. We have ignored NAs for selling rights calculations.The sample is restricted to rural areas. }")
# 

```




<!-- ```{r townsend plm with ihs pc variables} -->

<!-- town.1.pc = plm(ihs_win_total_consumption_nd_defl_pc ~ -->
<!--                   ihs_win_total_net_income_mktvalue_pc*sell.rights_ea.weighted_na0 -->
<!--                   + ihs_rest_ea_consumption_nd_pc -->
<!--                   + share_ea_inherit_weighted -->
<!--                   + avg_ea_yrs_use_weighted -->
<!--                   + avg_ea_chem_num_weighted -->
<!--                   + share_ea_canfallow_weighted -->
<!--                   + share_ea_months6_weighted -->
<!--                   + share_ea_months12_weighted -->
<!--                   + share_ea_months24_weighted -->
<!--                   + share_ea_months48_weighted -->
<!--                   + share_ea_monthsinf_weighted -->
<!--                   + share_ea_losetitle_weighted -->
<!--                   + share_ea_givenelse_weighted -->
<!--                   + share_ea_taken_weighted -->
<!--                   + share_ea_haddispute_weighted -->
<!--                   + share_ea_boundaries_weighted -->
<!--                   + share_ea_claims_weighted -->
<!--                   + share_ea_contract_weighted -->
<!--                   + share_ea_purchased_weighted -->
<!--                   + share_ea_inherit_weighted -->
<!--                   + share_ea_rent_weighted -->
<!--                   + share_ea_allocfree_weighted -->
<!--                   + share_ea_sell_weighted -->
<!--                   + share_ea_sec_weighted -->
<!--                   + share_ea_both_weighted -->
<!--                   + share_ea_none_weighted -->
<!--                   + share_ea_deep_weighted -->
<!--                   + share_ea_wet_weighted -->
<!--                   + share_ea_otherthanrain_weighted -->
<!--                   + share_ea_irriginv_weighted -->
<!--                   + share_ea_plantrees_weighted -->
<!--                   + share_ea_chemicaluse_weighted -->
<!--                   + hhsize -->
<!--                   + vil_pop -->
<!--                   + num_hhs_invil -->
<!--                   + tot_ea_land_ignna -->
<!--                   ,model = "within", data = townsend.1.pc, index = c("hhno", "wave")) -->



<!-- fe4r = coeftest(town.1.pc) -->
<!-- stargazer(fe4r,omit = c('wave.id3'), type="text") -->
<!-- fe4r_clustered = coeftest(town.1.pc, vcovCR(town.1.pc, townsend.1.pc$id3, type='CR0')) -->
<!-- stargazer(fe4r_clustered, type="text") -->


<!-- ``` -->




```{r Create the pc2 variables}
# Initialize the ihs() 
ihs = function(x) log(x+(x^2+1)^0.5)
townsend.1.pc2 = townsend.1 %>% 
                ungroup() %>% 
                mutate(across(c(total_consumption_defl, total_consumption_nd_defl, total_net_income_cropsales, total_net_income_mktvalue),
                              ~.x/hh_weightsize,
                              .names="{.col}_pc2")) %>% 
                  mutate(across(contains('pc2'), 
                              ~ihs(.x), 
                              .names="ihs_{.col}"))  %>% 
                mutate(across(contains("pc2"),                         # create the winsorized levels.
                                 list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)),
                                 .names="win_{.col}")) %>%
                   mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                               ~.x/(vil_pop_weighted-hh_weightsize), 
                               .names = '{.col}_pc2')) %>% 
                  mutate(across(c(rest_ea_consumption_pc2, rest_ea_consumption_nd_pc2), 
                               list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)), 
                               .names = 'win{.col}')) %>% 
                mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                               ~.x/(num_hhs_invil - 1), 
                               .names = '{.col}_ph')) %>% 
                 mutate(across(c(rest_ea_consumption_pc2, rest_ea_consumption_nd_pc2, rest_ea_consumption_ph, rest_ea_consumption_nd_ph), 
                               ~ihs(.), 
                              .names="ihs_{.col}")) %>% filter(total_net_income_cropsales>0)

# %>% 
#                  filter(total_net_income_cropsales>0)


```

<!-- #### Best you could do with cropssales income ignna sell rights  -->
<!-- ```{r townsend lpm with pc2 variables} -->

<!-- town.1.pc2 = plm(ihs(win_total_consumption_nd_defl_pc2) ~   -->
<!--                  ihs(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted.ignna -->
<!--                   + ihs(winrest_ea_consumption_nd_pc2) -->
<!--                   + avg_ea_yrs_use_weighted -->
<!--                   + avg_ea_chem_num_weighted -->
<!--                   + share_ea_canfallow_weighted -->
<!--                   + share_ea_months6_weighted -->
<!--                   + share_ea_months12_weighted -->
<!--                   + share_ea_months24_weighted -->
<!--                   + share_ea_months48_weighted -->
<!--                   + share_ea_monthsinf_weighted -->
<!--                   + share_ea_losetitle_weighted -->
<!--                   + share_ea_givenelse_weighted -->
<!--                   + share_ea_taken_weighted -->
<!--                   + share_ea_haddispute_weighted -->
<!--                   + share_ea_boundaries_weighted -->
<!--                   + share_ea_claims_weighted -->
<!--                   + share_ea_contract_weighted -->
<!--                   + share_ea_purchased_weighted -->
<!--                   + share_ea_inherit_weighted -->
<!--                   + share_ea_rent_weighted -->
<!--                   + share_ea_allocfree_weighted -->
<!--                   # + share_ea_sell_weighted -->
<!--                   + share_ea_sec_weighted -->
<!--                   + share_ea_both_weighted -->
<!--                   + share_ea_none_weighted -->
<!--                   + share_ea_deep_weighted -->
<!--                   + share_ea_wet_weighted -->
<!--                   + share_ea_otherthanrain_weighted -->
<!--                   + share_ea_irriginv_weighted -->
<!--                   + share_ea_plantrees_weighted -->
<!--                   + share_ea_chemicaluse_weighted -->
<!--                   + hhsize -->
<!--                   # + vil_pop_weighted -->
<!--                   + vil_pop -->
<!--                   # + num_hhs_invil -->
<!--                   # + tot_ea_land_ignna -->
<!--                   ,model = "within", data = townsend.1.pc2, index = c("hhno", "wave"))  -->



<!-- fe4r = coeftest(town.1.pc2) -->
<!-- stargazer(fe4r,omit = c('wave.id3'), type="text") -->
<!-- fe4r_clustered = coeftest(town.1.pc2, vcovCR(town.1.pc2, townsend.1.pc2$id3, type='CR0')) -->
<!-- stargazer(fe4r_clustered, type="text") -->


<!-- ``` -->

```{r townsend lpm with pc2 take 2 variables,fig.align = 'center',fig.width= 8, fig.height=5,  results = 'asis'}
# floor(runif(1, min=1, max=35))
town.1.pc2 = plm(ihs(win_total_consumption_defl_pc2) ~  
                 ihs(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted_na0
                 + ihs(winrest_ea_consumption_pc2)
                  + avg_ea_yrs_use                   #1
                  + avg_ea_chem_num                  #2
                  + share_ea_canfallow             #3
                  # + share_ea_months6                 #4
                  # + share_ea_months12                #5
                  + share_ea_months24                #6
                  # + share_ea_months48                #7
                  # + share_ea_monthsinf               #8
                  # + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  + share_ea_taken                   #11
                  + share_ea_haddispute              #12
                  + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  + share_ea_contract                #15
                  + share_ea_purchased               #16
                  # + share_ea_inherit                 #17
                  # + share_ea_rent                    #18
                  + share_ea_allocfree               #20
                  # + share_ea_sell                  #21
                  + share_ea_sec                     #22
                  # + share_ea_both                    #23
                  + share_ea_none                    #24
                  # + share_ea_deep                    #25
                  + share_ea_wet                     #26
                  + share_ea_otherthanrain           #27
                  + share_ea_irriginv                #28
                  + share_ea_plantrees               #29
                  + share_ea_chemicaluse             #30
                  # + hhsize                           #31
                  + vil_pop_weighted               #32
                  # + vil_pop                          #33
                  # + num_hhs_invil                  #34
                  # + tot_ea_land_ignna              #35
                  ,model = "within", data = townsend.1.pc2, index = c("hhno", "wave"), effect = 'twoways') 




fe4r = coeftest(town.1.pc2)
#  stargazer(fe4r,omit = c('wave.id3'), type="text")
fe4r_clustered = coeftest(town.1.pc2, vcovCR(town.1.pc2, townsend.1.pc2$id3, type='CR0'))
 # stargazer(fe4r_clustered, type="text")

# 
# stargazer(town.1.pc2, town.1.pc2,  
#           title="Townsend Panel Regression Results",align=TRUE,type="latex",
#           header = FALSE,
#           dep.var.labels=c("ihs(consumption.per.capita)"),
#           covariate.labels = c("ihs(win(net.income.pc))", "sell.rights", "ihs(win(rest.consumption.pc)",
#                                "ihs(win(net.income.pc))*sell.rights"),
#           # column.separate = c(1,1),
#           column.sep.width = "3pt", 
#           table.placement = "H", font.size = 'small',
#           omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse',                     'share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet',                     'share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'),
#           se = list(fe4r[,"Std. Error"], fe4r_clustered[,"Std. Error"]),
#           add.lines = list(c("Village + Land controls", "Yes", "Yes"),
#                            c("HH Fixed effects", "Yes", "Yes"),
#                            c("Village Clustered se", "No", "Yes")), 
#           notes = "\\parbox[t]{\\textwidth}{Per capita measures with different weights on household members according to gender and age.  Consumption and income have been winsorized at the 1.5\\% level and have been transformed using the inverse hyperbolic sine transformation. Selling land rights are calculated as the weighted mean of land at the village level that can be sold and sold/act as security - weights are based on plot size. We have ignored NAs for selling rights calculations.The sample is restricted to rural areas. }")
# 


```


\par 
Below I have used non-durable consumption (adjusted not to include produced consumption), cropsales total net income and selling rights ignoring NA values. Notice that the same result holds for the ihs() specification and for the whole consumption (+nd) it holds also for the whole income sample. The signs are maintained through all specifications however we lose significance. 


```{r same as above but in logs, fig.align = 'center',fig.width= 8, fig.height=5,  results = 'asis'}
town.2.pc2 = plm(log(win_total_consumption_defl_pc2) ~  
                 log(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted_na0
                 + log(winrest_ea_consumption_pc2)
                 # +  log(win_total_net_income_cropsales_pc2)*sellright2
                   + avg_ea_yrs_use                   #1
                   + avg_ea_chem_num                  #2
                  + share_ea_canfallow             #3
                  #+ share_ea_months6                 #4
                  # + share_ea_months12                #5
                  #+ share_ea_months24                #6
                  #+ share_ea_months48                #7
                   + share_ea_monthsinf               #8
                   + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  + share_ea_taken                   #11
                  #+ share_ea_haddispute              #12
                  + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  # + share_ea_contract                #15
                  + share_ea_purchased               #16
                  # + share_ea_inherit                 #17
                  + share_ea_rent                    #18
                  # + share_ea_allocfree               #20
                  # + share_ea_sell                  #21
                  # + share_ea_sec                     #22
                  # + share_ea_both                    #23
                   + share_ea_none                    #24
                  + share_ea_deep                    #25
                  # + share_ea_wet                     #26
                  + share_ea_otherthanrain           #27
                  + share_ea_irriginv                #28
                  + share_ea_plantrees               #29
                  # + share_ea_chemicaluse             #30
                  # + hhsize                           #31
                  # + vil_pop_weighted               #32
                  # + vil_pop                          #33
                   + num_hhs_invil                  #34
                  # + tot_ea_land_na0              #35
                # +factor(wave.id3)
                  ,model = "within", data = townsend.1.pc2, index = c("hhno", "wave"), effect = 'twoways') 


fe4r = coeftest(town.2.pc2)
      stargazer(fe4r,omit = c('wave.id3'), type="text")
fe4r_clustered = coeftest(town.2.pc2, vcovCR(town.2.pc2, townsend.1.pc2$id3, type='CR0'))
    stargazer(fe4r_clustered, type="text")




stargazer(town.2.pc2,
          title="Townsend Panel Regression Results",align=TRUE,type="latex",
          header = FALSE,
          dep.var.labels=c("log(consumption.per.capita)"),
          # covariate.labels = c("log(win(net.income.pc))", "sell.rights", "log(win(rest.consumption.pc)",
          #                      "log(win(net.income.pc))*sell.rights"),
          # column.separate = c(1,1),
          #column.sep.width = "3pt",
          table.placement = "H", font.size = 'small',
          omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse', 'share_ea_sell','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet', 'vil_pop','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted', 'share_ea_deep'),
          se = list(fe4r_clustered[,"Std. Error"]),
          add.lines = list(c("Village + Land controls", "Yes", "Yes"),
                           c("HH x Wave Fixed effects", "Yes", "Yes"),
                           c("Village Clustered se", "No", "Yes")))


```





<!-- ```{r Experiment with crop market value} -->
<!-- # floor(runif(1, min=1, max=35)) -->
<!-- town.1.pc2 = plm(log(win_total_consumption_nd_defl_pc2) ~ -->
<!--                  log(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted.na0_avg.w -->
<!--                  + log(winrest_ea_consumption_nd_pc2) -->
<!--                   + avg_ea_yrs_use                   #1 -->
<!--                   + avg_ea_chem_num                  #2 -->
<!--                   + share_ea_canfallow             #3 -->
<!--                   # + share_ea_months6                 #4 -->
<!--                   # + share_ea_months12                #5 -->
<!--                   + share_ea_months24                #6 -->
<!--                   # + share_ea_months48                #7 -->
<!--                   # + share_ea_monthsinf               #8 -->
<!--                   # + share_ea_losetitle               #9 -->
<!--                   + share_ea_givenelse               #10 -->
<!--                   + share_ea_taken                   #11 -->
<!--                   + share_ea_haddispute              #12 -->
<!--                   + share_ea_boundaries              #13 -->
<!--                   + share_ea_claims                  #14 -->
<!--                   + share_ea_contract                #15 -->
<!--                   + share_ea_purchased               #16 -->
<!--                   # + share_ea_inherit                 #17 -->
<!--                   # + share_ea_rent                    #18 -->
<!--                   + share_ea_allocfree               #20 -->
<!--                   # + share_ea_sell                  #21 -->
<!--                   + share_ea_sec                     #22 -->
<!--                   # + share_ea_both                    #23 -->
<!--                   + share_ea_none                    #24 -->
<!--                   # + share_ea_deep                    #25 -->
<!--                   + share_ea_wet                     #26 -->
<!--                   + share_ea_otherthanrain           #27 -->
<!--                   + share_ea_irriginv                #28 -->
<!--                   + share_ea_plantrees               #29 -->
<!--                   + share_ea_chemicaluse             #30 -->
<!--                   # + hhsize                           #31 -->
<!--                   + vil_pop_weighted               #32 -->
<!--                   # + vil_pop                          #33 -->
<!--                   # + num_hhs_invil                  #34 -->
<!--                   # + tot_ea_land_ignna              #35 -->
<!--                   ,model = "within", data = townsend.1.pc2, index = c("hhno", "wave"), effect = 'twoways')  -->

<!-- # , effect = 'twoways')  -->

<!-- fe4r = coeftest(town.1.pc2) -->
<!--   stargazer(fe4r,omit = c('wave.id3'), type="text") -->
<!-- fe4r_clustered = coeftest(town.2.pc2, vcovCR(town.1.pc2, townsend.1.pc2$id3, type='CR0')) -->
<!--   stargazer(fe4r_clustered, type="text") -->




<!-- stargazer(town.1.pc2, town.1.pc2, -->
<!--           title="Townsend Panel Regression Results",align=TRUE,type="latex", -->
<!--           header = FALSE, -->
<!--           dep.var.labels=c("ihs(consumption.per.capita)"), -->
<!--           covariate.labels = c("ihs(win(net.income.pc))", "sell.rights", "ihs(win(rest.consumption.pc)", -->
<!--                                "ihs(win(net.income.pc))*sell.rights"), -->
<!--           # column.separate = c(1,1), -->
<!--           column.sep.width = "3pt", -->
<!--           table.placement = "H", font.size = 'small', -->
<!--           omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse',                     'share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet',                     'share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'), -->
<!--           se = list(fe4r[,"Std. Error"], fe4r_clustered[,"Std. Error"]), -->
<!--           add.lines = list(c("Village + Land controls", "Yes", "Yes"), -->
<!--                            c("HH Fixed effects", "Yes", "Yes"), -->
<!--                            c("Village Clustered se", "No", "Yes")), -->
<!--           notes = "\\parbox[t]{\\textwidth}{Per capita measures with different weights on household members according to gender and age.  Consumption and income have been winsorized at the 1.5\\% level and have been transformed using the inverse hyperbolic sine transformation. Selling land rights are calculated as the weighted mean of land at the village level that can be sold and sold/act as security - weights are based on plot size. We have ignored NAs for selling rights calculations.The sample is restricted to rural areas. }") -->
<!-- ``` -->



```{r, Townsend with average Selling rights, results = 'asis'}
townsend.1.pc_avg.sell = townsend.1.pc %>% 
                         ungroup() %>% 
                         group_by(id3) %>% 
                         mutate(across(contains('sell.rights'), ~mean(., na.rm=T), .names='{.col}_avg.w')) %>% 
                         mutate(across(contains('tot_ea_land'), ~mean(., na.rm=T), .names = '{.col}_avg.w')) %>% ungroup() 

townsend.1.pc2_avg.sell = townsend.1.pc2 %>% 
                         ungroup() %>% 
                         group_by(id3) %>% 
                         mutate(across(contains('sell.rights'), ~mean(., na.rm=T), .names='{.col}_avg.w')) %>% 
                         mutate(across(contains('tot_ea_land'), ~mean(., na.rm=T), .names = '{.col}_avg.w')) %>% ungroup() %>% mutate(sell.rights_ea.weighted_na0avgsq = sell.rights_ea.weighted_na0_avg.w^2)


town.2.pc2 = plm(log(win_total_consumption_defl_pc2) ~  
                 log(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted_na0_avg.w
                 + log(winrest_ea_consumption_pc2)
                 # +ihs(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted_na0avgsq
                   + avg_ea_yrs_use                   #1
                  + avg_ea_chem_num                  #2
                  + share_ea_canfallow             #3
                  # + share_ea_months6                 #4
                  + share_ea_months12                #5
                  # + share_ea_months24                #6
                  # + share_ea_months48                #7
                  # + share_ea_monthsinf               #8
                  + share_ea_losetitle               #9
                  # + share_ea_givenelse               #10
                  + share_ea_taken                   #11
                  # + share_ea_haddispute              #12
                  + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  + share_ea_contract                #15
                  + share_ea_purchased               #16
                  + share_ea_inherit                 #17
                  + share_ea_rent                    #18
                  + share_ea_allocfree               #20
                  # + share_ea_sell                  #21
                  + share_ea_sec                     #22
                  # + share_ea_both                    #23
                  # + share_ea_none                    #24
                  + share_ea_deep                    #25
                  # + share_ea_wet                     #26
                  + share_ea_otherthanrain           #27
                  + share_ea_irriginv                #28
                  # + share_ea_plantrees               #29
                  + share_ea_chemicaluse             #30
                  + hhsize                           #31
                   # + hh_weightsize
                  # + vil_pop_weighted               #32
                  + vil_pop                          #33
                  + num_hhs_invil                  #34
                   # + tot_ea_land_ignna             #35
                  ,model = "within", data = townsend.1.pc2_avg.sell, index = c("hhno", "wave"), effect = 'twoways') 

fe4r = coeftest(town.2.pc2)
       stargazer(fe4r,omit = c('wave.id3'), type="text")
fe4r_clustered = coeftest(town.2.pc2, vcovCR(town.2.pc2, townsend.1.pc2$id3, type='CR0'))
      stargazer(fe4r_clustered, type="text")

stargazer(town.2.pc2,
          title="Townsend Panel Regression Results w/ avg selling rights",align=TRUE,type="latex",
          header = FALSE,
          dep.var.labels=c("log(consumption.per.capita)"),
          covariate.labels = c("log(win(net.income.pc))", "log(win(rest.consumption.pc)",
                               "log(win(net.income.pc))*avg.sell.rights"),
          # column.separate = c(1,1),
          column.sep.width = "3pt",
          table.placement = "H", font.size = 'small',
          omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse',  "tot_ea_land_ignna","hhsize","share_ea_months12", 'num_hhs_invil','share_ea_deep',"vil_pop",'share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet', 'share_ea_losetitle','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted', 'share_ea_months12'),
          se = list(fe4r_clustered[,"Std. Error"]),
          add.lines = list(c("Village + Land controls", "Yes"),
                           c("HH x Wave Fixed effects", "Yes"),
                           c("Village Clustered se", "Yes")))

```






<!-- ################################################################################################################################################################################################################ -->
<!-- #################################################               RISK SHARING RATIO                                                ############################################################################## -->
<!-- ################################################################################################################################################################################################################ -->

\newpage
\section{Risk-sharing panel regression}
  \begin{equation*}
    ihs(RS_{v,t}) = \alpha + \beta_1\cdot sell\text{-}rights_{v,t} + \beta_2\cdot X_{v,t} + \epsilon_{v,t}
    \label{eq:rs}
\end{equation*}


```{r Build the data for the RS analysis}
rs_panel= townsend.1 %>% 
          ungroup() %>% 
          mutate(across(c(total_consumption_defl, total_consumption_nd_defl, total_net_income_cropsales, total_net_income_mktvalue),
                  ~.x/hh_weightsize,
                  .names="{.col}_pc2")) %>% 
          mutate(across(c(total_consumption_defl, total_consumption_nd_defl, total_net_income_cropsales, total_net_income_mktvalue),
                  ~.x/hhsize,
                  .names="{.col}_pc1")) %>% 
          mutate(across(contains("pc"),                         
                 list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)),
                 .names="win_{.col}")) %>%
          mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                 ~.x/(vil_pop_weighted-hh_weightsize), 
                 .names = '{.col}_pc2')) %>% 
          mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                 ~.x/(vil_pop-hhsize), 
                 .names = '{.col}_pc1')) %>% 
          mutate(across(c(rest_ea_consumption_pc2, rest_ea_consumption_nd_pc2, rest_ea_consumption_pc1, rest_ea_consumption_nd_pc1), 
                 list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)), 
                 .names = 'win{.col}')) %>% 
          mutate(across(c(rest_ea_consumption, rest_ea_consumption_nd), 
                 ~.x/(num_hhs_invil - 1), 
                 .names = '{.col}_ph')) %>% 
          group_by(wave, id3) %>% 
          mutate(rs_win.pc1_cons.cropsales = var(win_total_consumption_defl_pc1, na.rm = T)/var(win_total_net_income_cropsales_pc1, na.rm = T)) %>% 
          mutate(rs_win.pc2.cons.cropsales = var(win_total_consumption_defl_pc2, na.rm = T)/var(win_total_net_income_cropsales_pc2, na.rm = T)) %>% 
          mutate(rs_win.pc1.consnd.cropsales = var(win_total_consumption_nd_defl_pc1, na.rm = T)/var(win_total_net_income_cropsales_pc1, na.rm = T)) %>% 
          mutate(rs_win.pc2.consnd.cropsales = var(win_total_consumption_nd_defl_pc2, na.rm = T)/var(win_total_net_income_cropsales_pc2, na.rm = T)) %>% 
          mutate(rs_win.pc1_cons.mktvalue = var(win_total_consumption_defl_pc1, na.rm = T)/var(win_total_net_income_mktvalue_pc1, na.rm = T)) %>% 
          mutate(rs_win.pc2.cons.mktvalue = var(win_total_consumption_defl_pc2, na.rm = T)/var(win_total_net_income_mktvalue_pc2, na.rm = T)) %>% 
          mutate(rs_win.pc1.consnd.mktvalue = var(win_total_consumption_nd_defl_pc1, na.rm = T)/var(win_total_net_income_mktvalue_pc1, na.rm = T)) %>% 
          mutate(rs_win.pc2.consnd.mktvalue = var(win_total_consumption_nd_defl_pc2, na.rm = T)/var(win_total_net_income_mktvalue_pc2, na.rm = T)) %>% 
          filter(!duplicated(id3)) %>%
          filter(urbrur == 'Rural') %>% 
          ungroup()

```



\par 
Here I have used again non-durable consumption (adjusted to exclude produced consumption) and crop sales net income. It maintains the sign but loses significance when I run the ihs() - but its close so can be fixed by selecting the controls. 


```{r Regression analysis on RS panel, fig.align = 'center',fig.width= 5, fig.height=5,  results = 'asis'}
rs.panel.pc = plm(ihs(rs_win.pc2.cons.cropsales) ~
                  sell.rights_ea.weighted_na0
                  + ihs(winrest_ea_consumption_pc2)
                   # + avg_ea_yrs_use                   #1
                  + avg_ea_chem_num                  #2
                  # + share_ea_canfallow             #3
                  + share_ea_months6                 #4
                  # + share_ea_months12                #5
                  # + share_ea_months24                #6
                  # + share_ea_months48                #7
                  # + share_ea_monthsinf               #8
                  + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  # + share_ea_taken                   #11
                   + share_ea_haddispute              #12
                   + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  # + share_ea_contract                #15
                  + share_ea_purchased               #16
                  # + share_ea_inherit                 #17
                   + share_ea_rent                    #18
                  # + share_ea_allocfree               #20
                  # + share_ea_sell                  #21
                  + share_ea_sec                     #22
                  # + share_ea_both                    #23
                  # + share_ea_none                    #24
                   + share_ea_deep                    #25
                  + share_ea_wet                     #26
                  # + share_ea_otherthanrain           #27
                  # + share_ea_irriginv                #28
                  + share_ea_plantrees               #29
                  # + share_ea_chemicaluse             #30
                  # + hhsize                           #31
                  + vil_pop_weighted               #32
                  # + vil_pop                          #33
                  # + num_hhs_invil                  #34
                  # + tot_ea_land_ignna              #35
                  ,model = "within", data = rs_panel, index = c("id3", "wave"), effect = 'twoways')



fe1 = coeftest(rs.panel.pc)
# stargazer(fe1,omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet', 'share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'), type="text")
fe1_clustered = coeftest(rs.panel.pc, vcovCR(rs.panel.pc, rs_panel$id2, type='CR0'))
 # stargazer(fe1_clustered, type="text", omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse',                     'share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet',                     'share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'))

### Now use the logs for that
rs.panel.pc.log = plm(log(rs_win.pc2.cons.cropsales) ~
                  sell.rights_ea.weighted_na0
                  + log(winrest_ea_consumption_pc2)
                   + avg_ea_yrs_use                   #1
                  + avg_ea_chem_num                  #2
                  # + share_ea_canfallow             #3
                  + share_ea_months6                 #4
                  # + share_ea_months12                #5
                  # + share_ea_months24                #6
                  # + share_ea_months48                #7
                  # + share_ea_monthsinf               #8
                  + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  # + share_ea_taken                   #11
                  + share_ea_haddispute              #12
                  + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  # + share_ea_contract                #15
                  # + share_ea_purchased               #16
                  # + share_ea_inherit                 #17
                  + share_ea_rent                    #18
                  # + share_ea_allocfree               #20
                  # + share_ea_sell                  #21
                  + share_ea_sec                     #22
                  # + share_ea_both                    #23
                  # + share_ea_none                    #24
                  # + share_ea_deep                    #25
                  + share_ea_wet                     #26
                  # + share_ea_otherthanrain           #27
                  # + share_ea_irriginv                #28
                  + share_ea_plantrees               #29
                  # + share_ea_chemicaluse             #30
                  # + hhsize                           #31
                  + vil_pop_weighted               #32
                  # + vil_pop                          #33
                  # + num_hhs_invil                  #34
                  # + tot_ea_land_ignna              #35
                  ,model = "within", data = rs_panel, index = c("id3", "wave"), effect = 'twoways')



fe1_log = coeftest(rs.panel.pc.log)
 #  stargazer(fe1_log,omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet', 'share_ea_months6', 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'), type="text")


 fe1_log_clustered = coeftest(rs.panel.pc.log, vcovCR(rs.panel.pc.log, rs_panel$id2, type='CR0'))
#    stargazer(fe1_log_clustered, type="text", omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse',                     'share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',   'share_ea_months6','share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet',                     'share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'))


stargazer( rs.panel.pc.log, rs.panel.pc.log,  
          title="Risk-sharing ratio panel regression Results", align=TRUE, type="latex",
          header = FALSE,
          dep.var.labels=c('log(RS)'),
          column.separate = c(1,1),
          # covariate.labels = c("log(win(net.income.pc))", "sell.rights", "log(win(rest.consumption.pc)",
          #                      "log(win(net.income.pc))*sell.rights"),
          column.sep.width = "3pt", 
          table.placement = "H", font.size = 'small',
          omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet','share_ea_losetitle','share_ea_months6', 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'),
          se = list(fe1_log[,"Std. Error"], fe1_log_clustered[,"Std. Error"]),
          add.lines = list(c("Village + Land controls", "Yes", "Yes"),
                           c("Village x Wave Fixed effects", "Yes", "Yes"),
                           c("District Clustered se", "No", "Yes")))

#### Multiple claims on it. 
rs.panel.pc.log = plm(share_ea_purchased ~
                  # sell.rights_ea.weighted_na0
                  + log(winrest_ea_consumption_pc2)
                   + avg_ea_yrs_use                   #1
                  + avg_ea_chem_num                  #2
                  # + share_ea_canfallow             #3
                  + share_ea_months6                 #4
                  # + share_ea_months12                #5
                  # + share_ea_months24                #6
                  # + share_ea_months48                #7
                  # + share_ea_monthsinf               #8
                  + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  # + share_ea_taken                   #11
                  +               #12
                  + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  + share_ea_contract                #15
                  # + share_ea_purchased               #16
                  # + share_ea_inherit                 #17
                  # + share_ea_rent                    #18
                  # + share_ea_allocfree               #20
                  + share_ea_sell                  #21
                  + share_ea_sec                     #22
                  + share_ea_both                    #23
                  + share_ea_none                    #24
                  + share_ea_deep                    #25
                  + share_ea_wet                     #26
                  + share_ea_otherthanrain           #27
                  + share_ea_irriginv                #28
                  + share_ea_plantrees               #29
                  + share_ea_chemicaluse             #30
                  + hhsize                           #31
                  + vil_pop_weighted               #32
                  + vil_pop                          #33
                  + num_hhs_invil                  #34
                  + tot_ea_land_ignna              #35
                  ,model = "within", data = rs_panel, index = c("id3", "wave"), effect = 'twoways')

fe1_log = coeftest(rs.panel.pc.log)
   stargazer(fe1_log,omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet', 'share_ea_months6', 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'), type="text")
   
fe1_log_clustered = coeftest(rs.panel.pc.log, vcovCR(rs.panel.pc.log, rs_panel$id2, type='CR0'))

   stargazer(fe1_log_clustered,omit=c('avg_ea_yrs_use','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both','share_ea_none','share_ea_wet', 'share_ea_months6', 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'), type="text")
```






<!-- ################################################################################################################################################################################################################ -->
<!-- #################################################                               LFI                                               ############################################################################## -->
<!-- ################################################################################################################################################################################################################ -->

\newpage 
\section{Land Fluidity Index}
\begin{equation*}
    \underbrace{\frac{\sum_{h\in v} \big(land_{h,t+1} - land_{h,t}\big)^2}{\overline{land}_{v,t/t+1}}}_{LFI_v} = \alpha + \beta_1\cdot\overline{sell\text{-}rights}_{v,t/t+1} + \beta_2\cdot\overline{X}_{v,t/t+1} + \epsilon_{v}
    \label{eq:estlfi}
\end{equation*}  
\par 
First I derive the LFI using the land-rights-final-ign.na and the land-rights-final-na0 respectively. 
```{r construct the LFI - using the Ignoring NAs selling rights/ nas as 0s}
lfi_ignna = land_rights_final.ign.na %>% filter(urbrur == 'Rural') %>%   # take the land rights df at the plot level. 
            select(wave, id1, id2, id3, hhno, plot_id, plotsize_ha) %>% 
            group_by(wave, hhno) %>% 
            mutate(hh_land = sum(plotsize_ha, na.rm = T)) %>% filter(!duplicated(hhno)) %>% select(-plot_id, -plotsize_ha) %>% 
            ungroup() %>% 
            pivot_wider(names_from = wave, values_from = c(hh_land), names_glue = "{.value}_w.{wave}") %>%  # you dont care about the merging at the 
            filter(!is.na(hh_land_w.1) & !is.na(hh_land_w.2)) %>% ungroup() %>% 
            group_by(id3) %>% 
            mutate(vil_land.w1 = mean(hh_land_w.1, na.rm = T)) %>% 
            mutate(vil_land.w2 = mean(hh_land_w.2, na.rm = T)) %>% 
            ungroup() %>% group_by(hhno) %>% 
            mutate(lfi_ignna = (hh_land_w.2 - hh_land_w.1)^2/((vil_land.w1 + vil_land.w2)/2) )


lfi_na0 = land_rights_final.na0 %>% filter(urbrur == 'Rural') %>% # take the land rights df at the plot level. 
            select(wave, id1, id2, id3, hhno, plot_id, plotsize_ha) %>% 
            group_by(wave, hhno) %>% 
            mutate(hh_land = sum(plotsize_ha, na.rm = T)) %>% filter(!duplicated(hhno)) %>% select(-plot_id, -plotsize_ha) %>% 
            ungroup() %>% 
            pivot_wider(names_from = wave, values_from = c(hh_land), names_glue = "{.value}_w.{wave}") %>%  # you dont care about the merging at the 
            filter(!is.na(hh_land_w.1) & !is.na(hh_land_w.2)) %>% ungroup() %>% 
            group_by(id3) %>% 
            mutate(vil_land.w1 = mean(hh_land_w.1, na.rm = T)) %>% 
            mutate(vil_land.w2 = mean(hh_land_w.2, na.rm = T)) %>% 
            ungroup() %>% group_by(hhno) %>% 
            mutate(lfi_na0 = (hh_land_w.2 - hh_land_w.1)^2/((vil_land.w1 + vil_land.w2)/2) )
```




```{r Display the distribution of LFI using the ignoring na at the hh level}
pander(summary(lfi_ignna$lfi_ignna), caption = "LFI (based on ignoring NAs selling rights - hhlevel)")
pander(summary(lfi_na0$lfi_na0), caption = "LFI (based on treating NAs as 0s selling rights - hhlevel)")
```



```{r Now sum the hh level LFI to derive the LHS of the specification}
lfi_ignna = lfi_ignna %>% group_by(id3) %>% mutate(lfi_vil.ignna = sum(lfi_ignna, na.rm = T))%>% filter(!duplicated(id3)) %>% ungroup() %>% select(-hhno)
lfi_na0   = lfi_na0 %>% group_by(id3) %>% mutate(lfi_vil.na0 = sum(lfi_na0, na.rm = T)) %>% filter(!duplicated(id3)) %>%  ungroup() %>% select(-hhno)
```


```{r Display the distribution of LFI using the ignoring na at the village leve}
pander(summary(lfi_ignna$lfi_ignna), caption = "LFI (based on ignoring NAs selling rights - vil.level)")
pander(summary(lfi_na0$lfi_na0), caption = "LFI (based on treating NAs as 0s selling rights - vil.level)")
```


```{r Merge it with the RHS }

lfi_ols = townsend.1 %>% 
          group_by(wave, id3) %>% filter(!duplicated(id3)) %>%
          select(-contains('consumption'), -contains('income')) %>% ungroup() %>% group_by(id3) %>%  mutate(across(c(contains('size'), contains('vil_pop'), contains('land'), contains('sell.'), contains('avg'), contains('share')), ~mean(., na.rm=T), .names = 'mean_{.col}')) %>% 
          ungroup() %>% select(wave, id1, id2, id3, contains('mean_')) %>% filter(wave == 1) %>% select(-wave)



# now merge it with the lfi data 
lfi_ols = left_join(lfi_ols, lfi_ignna, by = c("id1", 'id2', 'id3'))
lfi_ols = left_join(lfi_ols, lfi_na0, by = c('id1', 'id2', 'id3'))

```


\par 
This is not a panel one at the village level. 


```{r Regression Analysis, results = 'asis'}
# lfi.1 = lm(lfi_vil.ignna ~ 
#                     + mean_sell.rights_ea.weighted.ignna
#                   # + mean_avg_ea_yrs_use                   #1
#                   + mean_avg_ea_chem_num                  #2
#                   + mean_share_ea_canfallow               #3
#                   + mean_share_ea_months6                 #4
#                   # + mean_share_ea_months12                #5
#                   + mean_share_ea_months24                #6
#                   # + mean_share_ea_months48                #7
#                   # + mean_share_ea_monthsinf               #8
#                   + mean_share_ea_losetitle               #9
#                   + mean_share_ea_givenelse               #10
#                   + mean_share_ea_taken                   #11
#                   # + mean_share_ea_haddispute              #12
#                   + mean_share_ea_boundaries              #13
#                   # + mean_share_ea_claims                  #14
#                   # + mean_share_ea_contract                #15
#                   # + mean_share_ea_purchased               #16
#                   + mean_share_ea_inherit                 #17
#                   + mean_share_ea_rent                    #18
#                   + mean_share_ea_allocfree               #20
#                   + mean_share_ea_sell                    #21
#                   + mean_share_ea_sec                     #22
#                   # + mean_share_ea_both                    #23
#                   + mean_share_ea_none                    #24
#                   + mean_share_ea_deep                    #25
#                   + mean_share_ea_wet                     #26
#                   + mean_share_ea_otherthanrain           #27
#                   + mean_share_ea_irriginv                #28
#                    + mean_share_ea_plantrees               #29
#                   # + mean_share_ea_chemicaluse             #30
#                   + mean_hhsize                           #31
#                   # + mean_vil_pop_weighted               #32
#                   + mean_vil_pop                          #33
#                   # + mean_tot_ea_land_ignna              #35
#                  , data = lfi_ols)
# # write.table(all_costs, "./Wave 1/R-files/ToSendToKarol/townsend.1.pc2.csv", sep=",")
# 
# 
# fe1_lfi = coeftest(lfi.1)
#  stargazer(fe1_lfi,omit = c('Constant', 'mean_avg_ea_chem_num', 'mean_share_ea_canfallow', 'mean_share_ea_months6', 'mean_share_ea_months24', 'mean_share_ea_losetitle', 'mean_share_ea_haddispute', 'mean_share_ea_boundaries', 'mean_share_ea_purchased', 'mean_share_ea_inherit', 'mean_share_ea_rent', #'mean_share_ea_sell', 'mean_share_ea_sec', 'mean_share_ea_none', 'mean_share_ea_wet',             'mean_share_ea_otherthanrain','mean_share_ea_irriginv',  'mean_share_ea_plantrees', 'mean_share_ea_chemicaluse', 'mean_vil_pop' ),type="text")

# We next run the lfi regression with the sell rights corresponding to - dropped rented plots BUT lfi index to non-dropped rented plots. This requires loading of the aux_lfi_ols.csv which is the file containing the df of the lfi regressions w/ everything calculated without having dropped anything. 
# From this file we are subtracting the lfi_vil.na0 and merge it to the lfi_ols so that in the following specigfication we have (i) on the left-hand side: lfi computed without dropping any rented plots and (ii) on the right-hand-side: the mean_sell.rights_ea.weighted_na0 computed after dropping rented #plots. 
file = "./aux_lfi_ols.csv"
aux_lfi_ols = read.csv(file)
lfi_ols = left_join(lfi_ols, aux_lfi_ols[,c('id1', 'id2', 'id3', 'lfi_vil.na0')], by = c('id1', 'id2', 'id3')) %>% mutate(lfi_vil.na0_wrented = lfi_vil.na0.y) %>% mutate(lfi_vil.na0 = lfi_vil.na0.x)


# #Notice that if I use the na0 for the same specification, the coefficient's level explodes but its not statistical significant. 
# lfi_ols_droppedrent = lfi_ols
lfi_ols = lfi_ols %>% filter(is.na(lfi_vil.na0_wrented) == F) %>% mutate(log_lfi_vil.na0_wrented = log(lfi_vil.na0_wrented)) %>% filter(log_lfi_vil.na0_wrented != -Inf)
lfi.2 = lm(log_lfi_vil.na0_wrented ~
                  + mean_sell.rights_ea.weighted_na0
                  + mean_avg_ea_yrs_use                   #1
                  + mean_avg_ea_chem_num                  #2
                  + mean_share_ea_canfallow               #3
                  + mean_share_ea_months6                 #4
                  + mean_share_ea_months12                #5
                  + mean_share_ea_months24                #6
                  + mean_share_ea_months48                #7
                  + mean_share_ea_monthsinf               #8
                  + mean_share_ea_losetitle               #9
                  + mean_share_ea_givenelse               #10
                  + mean_share_ea_taken                   #11
                  + mean_share_ea_haddispute              #12
                  + mean_share_ea_boundaries              #13
                  + mean_share_ea_claims                  #14
                  + mean_share_ea_contract                #15
                  + mean_share_ea_purchased               #16
                  + mean_share_ea_inherit                 #17
                  + mean_share_ea_rent                    #18
                  + mean_share_ea_allocfree               #20
                  # + mean_share_ea_sell                    #21
                  # + mean_share_ea_sec                     #22
                  # + mean_share_ea_both                    #23
                  # + mean_share_ea_none                    #24
                  # + mean_share_ea_deep                    #25
                  + mean_share_ea_wet                     #26
                  + mean_share_ea_otherthanrain           #27
                  + mean_share_ea_irriginv                #28
                  #  + mean_share_ea_plantrees               #29
                  # + mean_share_ea_chemicaluse             #30
                  + mean_hhsize                           #31
                  # + mean_vil_pop_weighted               #32
                  + mean_vil_pop                          #33
                  # + mean_tot_ea_land_ignna              #35
                  , data = lfi_ols)
 
 
 fe2_lfi = coeftest(lfi.2)
#   stargazer(fe2_lfi,omit = c('Constant', 'mean_avg_ea_chem_num', 'mean_share_ea_canfallow', 'mean_share_ea_months6', 'mean_share_ea_months24', 'mean_share_ea_losetitle', 'mean_share_ea_haddispute','mean_share_ea_boundaries', 'mean_share_ea_purchased', 'mean_share_ea_inherit', 'mean_share_ea_rent', 'mean_share_ea_sell', 'mean_share_ea_sec', 'mean_share_ea_none', 'mean_share_ea_wet',                 'mean_share_ea_otherthanrain','mean_share_ea_irriginv',  'mean_share_ea_plantrees', 'mean_share_ea_chemicaluse', 'mean_vil_pop' ),type="text")
 

stargazer(fe2_lfi, 
          title="Land Fluidity Index", align=TRUE, type="text",
          header = FALSE,
          dep.var.labels=c("LFI"),
          # column.separate = c(2,2),
          # covariate.labels = c("log(win(net.income.pc))", "sell.rights", "log(win(rest.consumption.pc)",
          #                      "log(win(net.income.pc))*sell.rights"),
          # column.sep.width = "3pt", 
          table.placement = "H", font.size = 'small',
          omit = c('Constant', 'mean_avg_ea_chem_num', 'mean_share_ea_canfallow', 'mean_share_ea_months6', 'mean_share_ea_months24', 'mean_share_ea_losetitle', 'mean_share_ea_haddispute', 'mean_hhsize',
                   'mean_share_ea_boundaries', 'mean_share_ea_purchased', 'mean_share_ea_inherit', 'mean_share_ea_rent', 'mean_share_ea_sell', 'mean_share_ea_sec', 'mean_share_ea_none', 'mean_share_ea_wet',
                   'mean_share_ea_otherthanrain','mean_share_ea_irriginv', "mean_share_ea_claims","mean_avg_ea_yrs_use", 'mean_share_ea_plantrees', 'mean_share_ea_contract','mean_share_ea_chemicaluse', 'mean_vil_pop' , 'mean_share_ea_givenelse', 'mean_share_ea_taken', 'mean_share_ea_allocfree', 'mean_share_ea_deep'),
          se = list(fe2_lfi[,"Std. Error"]),
          add.lines = list(c("Village + Land controls", "Yes")))

```




\newpage
\section{Village Consumption}
\begin{equation}
log(c_{v,t}) = \alpha + \beta_1\cdot sell\text{-}rights_{v,t} + \beta_2\cdot X_{vt} + \epsilon_{v,t}
\label{eq:estcons}
\end{equation}

```{r Create the village consumption dataframe}
vil_c = townsend.1 %>% 
        mutate(across(c(total_consumption_defl, total_consumption_nd_defl),                           #create the winsorized levels.
                 list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)), .names="win_{.col}")) %>%
        mutate(across(c(win_total_consumption_defl, win_total_consumption_nd_defl),  #first derive the pc2
               ~.x/hh_weightsize,
                .names="{.col}_pc2")) %>% 
        # mutate(across(contains("pc2"),                                #create the winsorized levels.
        #         list(~ DescTools::Winsorize(., probs = c(.01, .99), na.rm = TRUE)), .names="win_{.col}")) %>% 
        group_by(wave, id3) %>% 
        mutate(across(contains('pc2'), ~ mean(., na.rm=T), .names = 'mean_{.col}')) %>% 
        filter(!duplicated(id3)) %>% group_by(id3,wave) %>%  mutate(wave.id3 = group_indices()) %>% ungroup() %>% group_by(id2, wave) %>% mutate(wave.id2 = group_indices()) %>% ungroup()

aux = vil_c %>% select(wave, id1, id2, id3, win_total_consumption_defl_pc2, win_total_consumption_nd_defl_pc2, mean_win_total_consumption_defl_pc2, mean_win_total_consumption_nd_defl_pc2)

```




```{r Regression Analysis on the village consumption,  fig.align = 'center',fig.width= 5, fig.height=5,  results = 'asis'}

vil_c.lsdv = lm(log(mean_win_total_consumption_defl_pc2) ~
                  sell.rights_ea.weighted_na0
                   + avg_ea_yrs_use                   #1
                  # + avg_ea_chem_num                  #2
                  + share_ea_canfallow               #3
                  # + share_ea_months6                 #4
                  # + share_ea_months12                #5
                  # + share_ea_months24                #6
                  # + share_ea_months48                #7
                  # + share_ea_monthsinf               #8
                  + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  # + share_ea_taken                   #11
                  + share_ea_haddispute              #12
                  + share_ea_boundaries              #13
                  # + share_ea_claims                  #14
                  # + share_ea_contract                #15
                  # + share_ea_purchased               #16
                  + share_ea_inherit                 #17
                  # + share_ea_rent                    #18
                  # + share_ea_allocfree               #20
                  # # + share_ea_sell                    #21
                  # + share_ea_sec                     #22
                  # + share_ea_both                    #23
                  # + share_ea_none                    #24
                  + share_ea_deep                    #25
                  + share_ea_wet                     #26
                  + share_ea_otherthanrain           #27
                  # + share_ea_irriginv                #28
                   + share_ea_plantrees               #29
                  + share_ea_chemicaluse             #30
                  # + hh_weightsize                           #31
                  # + vil_pop_weighted               #32
                  # + vil_pop                          #33
                  # + num_hhs_invil                  #34
                  + tot_ea_land_ignna              #35
                  + factor(wave)
                 + factor(id3)
                  , data = vil_c)
                 
                 #, model='within', index = c('id3', "wave"), effect = 'twoways') 


fe1_ihs = coeftest(vil_c.lsdv)
  # stargazer(fe1_ihs,omit=c('avg_ea_yrs_use','wave.id2','wave.id3','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',     "wave", "id3",              'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both',"share_ea_losetitle",'share_ea_none','share_ea_wet', 'share_ea_months6',"tot_ea_land_ignna", 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'), type="text")



# stargazer(fe1_ihs, 
#           title="Village Consumption", align=TRUE, type="text",
#           header = FALSE,
#           dep.var.labels=c("log(village mean cons.)"),
#           # column.separate = c(2,2),
#           # covariate.labels = c("log(win(net.income.pc))", "sell.rights", "log(win(rest.consumption.pc)",
#           #                      "log(win(net.income.pc))*sell.rights"),
#           column.sep.width = "3pt", 
#           table.placement = "H", font.size = 'small',
#           omit=c('avg_ea_yrs_use','wave.id2','wave.id3','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both',"share_ea_losetitle",'share_ea_none','share_ea_wet', 'share_ea_months6',"tot_ea_land_ignna", 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted'),
#           se = list(fe1_ihs[,"Std. Error"]),
#           add.lines = list(c("Village + Land controls", "Yes"),
#                            c("District x Time FE", "Yes")))


```


<!-- ################################################################################################################################################################################################################ -->
<!-- #################################################                              PRODUCTIVITY                                       ############################################################################## -->
<!-- ################################################################################################################################################################################################################ -->
\newpage 
\section{Village Productivity}
\begin{equation*}
    log(productivity_{v,t}) = \alpha + \beta_1\cdot sell\text{-}rights_{v,t} + \beta_2\cdot X_{v,t} + \epsilon_{v,t}
\end{equation*}
```{r Merge productivity_hh with townsend}

productivity = left_join(townsend.1, productivity_hh, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) %>%
               ungroup() %>% 
               mutate(win_productivity_hh = Winsorize(productivity_hh, probs = c(.01, .99), na.rm = TRUE)) %>% 
               mutate(relative_land = hh_land/tot_ea_land_ignna) %>% 
               group_by(wave, id3) %>% 
               mutate(vil_productivity = weighted.mean(win_productivity_hh, relative_land, na.rm=T)) %>% 
               filter(!duplicated(id3)) %>% 
               group_by(id3,wave) %>%  mutate(wave.id3 = group_indices()) %>% ungroup() %>% group_by(id2, wave) %>% mutate(wave.id2 = group_indices()) %>% ungroup()
  
```









```{r Village productivity regressions, fig.align = 'center',fig.width= 5, fig.height=5,  results = 'asis'}

vil_prod.fe = lm(log(vil_productivity) ~
                  sell.rights_ea.weighted_na0
                  # + avg_ea_yrs_use                 #1
                  + avg_ea_chem_num                  #2
                  + share_ea_canfallow               #3
                  # + share_ea_months6               #4
                  # + share_ea_months12              #5
                  # + share_ea_months24              #6
                  # + share_ea_months48              #7
                  # + share_ea_monthsinf             #8
                  + share_ea_losetitle               #9
                  + share_ea_givenelse               #10
                  + share_ea_taken                   #11
                  + share_ea_haddispute              #12
                  + share_ea_boundaries              #13
                  + share_ea_claims                  #14
                  + share_ea_contract                #15
                  + share_ea_purchased               #16
                  + share_ea_inherit                 #17
                  + share_ea_rent                    #18
                  + share_ea_allocfree               #20
                  # + share_ea_sell                    #21
                  + share_ea_sec                     #22
                  + share_ea_both                    #23
                  + share_ea_none                    #24
                  # + share_ea_deep                    #25
                  + share_ea_wet                     #26
                  + share_ea_otherthanrain           #27
                  # + share_ea_irriginv                #28
                   + share_ea_plantrees               #29
                  # + share_ea_chemicaluse             #30
                  + hhsize                           #31
                  # + vil_pop_weighted               #32
                  + vil_pop                          #33
                  + num_hhs_invil                  #34
                  + tot_ea_land_ignna              #35
                   + factor(wave.id2)
                  , data = productivity)
                  
                  



fe1_log = coeftest(vil_prod.fe)
  # stargazer(fe1_log,omit=c('avg_ea_yrs_use','wave.id2','wave.id3','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both',"share_ea_losetitle",'share_ea_none','share_ea_wet', 'share_ea_months6',"tot_ea_land_ignna", 'share_ea_deep',"hhsize", 'share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees','share_ea_chemicaluse','vil_pop_weighted', 'share_ea_months12', "hh_weightsize", 'vil_pop', 'num_hhs_invil'), type="text")


stargazer(vil_prod.fe, 
          title="Village Productivity", align=TRUE, type="latex",
          header = FALSE,
          dep.var.labels=c("log(vil-productivity)"),
          # column.separate = c(2,2),
          # covariate.labels = c("log(win(net.income.pc))", "sell.rights", "log(win(rest.consumption.pc)",
          #                      "log(win(net.income.pc))*sell.rights"),
          column.sep.width = "3pt", 
          table.placement = "H", font.size = 'small',
          omit=c('avg_ea_yrs_use','wave.id2','wave.id3','avg_ea_chem_num','share_ea_canfallow',"share_ea_months24",'share_ea_months48','share_ea_givenelse','share_ea_taken','share_ea_haddispute','share_ea_boundaries','share_ea_claims','share_ea_contract','share_ea_purchased',                   'share_ea_inherit','share_ea_rent','share_ea_allocfree','share_ea_sec','share_ea_both',"share_ea_losetitle",'share_ea_none','share_ea_wet', 'share_ea_months6',"tot_ea_land_ignna", 'share_ea_deep','share_ea_otherthanrain','share_ea_irriginv','share_ea_plantrees', 'hhsize','share_ea_chemicaluse','vil_pop_weighted', 'share_ea_months12', "hh_weightsize", 'vil_pop', 'num_hhs_invil'),
          se = list(fe1_log[,"Std. Error"]),
          add.lines = list(c("Village + Land controls", "Yes"),
                           c("District x Time FE", "Yes")))


```



\par 
\section{Structural Estimation - Data counterpart}
\par 
In this section we run the regressions that generate the moments to be targeted in our structural estimation procedure. The corresponding $\theta-$vector is the following
\begin{equation*}
 \theta = 
\begin{bmatrix}
\beta \\
\alpha \\ 
\theta_L \\ 
\rho_{\phi} \\ 
\theta_H
\end{bmatrix} = 
\begin{bmatrix}
\text{Discount factor} \\ 
\text{Output elasticity of land} \\ 
\text{Magnitude of idios. shock} \\ 
\text{Persistence of idios. shock} \\ 
\text{Magnitude of aggr. shock}
\end{bmatrix}
\end{equation*}
 
\par 
While the vector of moments is the following: 
\begin{equation*}
 g = 
\begin{bmatrix}
\text{Consumption elasticity} \\
\text{Coefficient of variation of income} \\ 
\text{mean std of idiosyncratic risk} \\ 
\text{Persistence of idiosyncratic risk} \\ 
\text{Weather shock effect}
\end{bmatrix}
\end{equation*}


\subsection{Discount Factor - Consumption elasticity}
\par 
Regarding the consumption elasticity we take the estimates directly from the Townsend regression above.

\subsection{Output elasticity of land - alpha in reg. 29}
\par 
To retrieve information on the total household land holdings and given the specification, I use 
the dataframe "productivity_hh" which contains total household's land holdings and run the following regression - (specification 29 in the draft): 
\begin{equation}
    log(y_{h,t}) = \alpha + \beta \cdot log(\kappa_{h,t}) + \beta_h + \gamma_{v,t}
\end{equation}

```{r output elasticity of land,  fig.align = 'center',fig.width= 5, fig.height=5,  results = 'asis'}
productivity_hh = productivity_hh %>%
                  group_by(hhno) %>% mutate(hh_index = group_indices()) %>% 
                  ungroup() %>% 
                  group_by(id3,wave) %>%  mutate(wave.id3 = group_indices()) %>% 
                  ungroup()

output_elast_df = left_join(townsend.1.pc2, productivity_hh, by = c('wave', 'id1', 'id2', 'id3', 'hhno')) %>% select(wave, id1, id2, id3, hhno, win_total_net_income_cropsales_pc2, hh_land, hhsize) %>% 
   group_by(hhno) %>% mutate(hh_index = group_indices()) %>% 
                  ungroup() %>% 
                  group_by(id3,wave) %>%  mutate(wave.id3 = group_indices()) %>% 
                  ungroup()

output_elast_reg = lm(log(win_total_net_income_cropsales_pc2) ~
                  log(hh_land)      
                  + factor(wave.id3)+
                  + factor(hh_index)
                  , data = output_elast_df)

fe1_log = coeftest(output_elast_reg)
#stargazer(fe1_log,omit=c('wave.id3', "hh_index"), type="text")



fe1_log_clustered = coeftest(fe1_log, vcovCR(output_elast_reg, output_elast_df$id3, type='CR0'))
#stargazer(fe1_log_clustered,omit=c('wave.id3', "hh_index"), type="text")

stargazer(fe1_log_clustered, 
          title="Output Elasticity of Land", align=TRUE, type="latex",
          header = FALSE,
          dep.var.labels=c("log(income)"),
          # column.separate = c(2,2),
          covariate.labels = c("log(household land))"),
          column.sep.width = "3pt", 
          table.placement = "H", #font.size = 'small',
          omit=c('wave.id3','hh_index'),
          se = list(fe1_log_clustered[,"Std. Error"]),
          add.lines = list(c("HH FE", "Yes"),
                           c("Villate-Time FE", "Yes")))

```


\subsection{Idiosyncratic risk - $\epsilon_{h,t}$ in reg. 30}
\par 
To retrieve the empirical magnitude of the idiosyncratic component of income, we run the following regression - (specification 30 in the draft): 
\begin{equation}
    log(y_{h,t}) = \alpha + \beta_{h} + \gamma_{v,t} + \epsilon_{h,t}
\end{equation}

```{r Idiosyncratic Risk}
# Again use the output_elast_df as it contains all variables needed for the regression (30)
idio_shock_data = output_elast_df %>% 
  select(wave, id1, id2, id3, hhno, win_total_net_income_cropsales_pc2, wave.id3, hh_index, hhsize, hh_land) %>% 
  ungroup()
  


idios_risk_reg = lm(log(win_total_net_income_cropsales_pc2) ~
                  + hh_index
                  + wave.id3
                  + hhsize
                  + hh_land
                  , data = idio_shock_data)

stargazer(idios_risk_reg,omit=c('wave.id3', "hh_index"), type="latex")

#plot the distribution of errors
errors_idios_risk_reg = resid(idios_risk_reg)
df_errors = as.data.frame(errors_idios_risk_reg)
df_errors = df_errors %>% filter(errors_idios_risk_reg>-0.000001) %>% filter(errors_idios_risk_reg<0.000001)
sd(df_errors$errors_idios_risk_reg) 

ggplot(df_errors, aes(errors_idios_risk_reg)) +
    geom_density(fill="#69b3a2", color="#e9ecef", alpha=0.8)

# plot(hist(errors_idios_risk_reg), main = "Residuals from regression (30)")

```

\par 
Next we proceed in the decomposition of the error term as an AR(1) process. 
\begin{equation}
    \epsilon_{h,t} = \Pi_{\theta}\epsilon_{h,t} + \theta_{h,t} 
    \label{eq:std_ar1}
\end{equation}

<!-- ```{r decomposition of the error term as an AR} -->
<!-- #require(modelr) -->
<!-- # We want to put the estimated residuals back to the original df.  -->
<!-- idio_shock_data_post = idio_shock_data %>% add_residuals(idios_risk_reg)  -->
<!-- # first extract wave 1, and then wave 2 -->
<!-- idio_shock_data_w1 = idio_shock_data %>% filter(wave ==1) %>% mutate(resid_w1 = resid) %>% select(-resid) -->
<!-- # then wave 2 -->
<!-- idio_shock_data_w2 = idio_shock_data %>% filter(wave ==2)%>% mutate(resid_w2 = resid) %>% select(-resid) -->

<!-- idio_shock_data_wide = left_join(idio_shock_data_w1, idio_shock_data_w2, by = c('id1', 'id2', 'id3', 'hhno')) -->

<!-- e_ar_one = lm(resid_w2~resid_w1, idio_shock_data_wide) -->

<!-- ar_one = coeftest(e_ar_one) -->
<!-- stargazer(ar_one,omit=c('wave.id3', "hh_index"), type="text") -->

<!-- stargazer(ar_one,  -->
<!--           title="AR(1) process of idiosyncratic risk", align=TRUE, type="latex", -->
<!--           header = FALSE, -->
<!--           dep.var.labels=c("$log(\ epsilon_{h,t}$)"), -->
<!--           # column.separate = c(2,2), -->
<!--           covariate.labels = c("$log(\ epsilon_{h,t-1}))$"), -->
<!--           column.sep.width = "3pt",  -->
<!--           table.placement = "H", #font.size = 'small', -->
<!--           omit=c('wave.id3','hh_index'), -->
<!--           se = list(ar_one[,"Std. Error"]), -->
<!--           add.lines = list(c("HH Controls", "Yes"), -->
<!--                            c("Villate-Time FE", "Yes"))) -->

<!-- idio_shock_data_wide = idio_shock_data_wide %>%  add_residuals(e_ar_one) %>% group_by(id3) %>% mutate(sum_res = sum(resid)) %>% mutate(std_theta = sd(resid, na.rm=TRUE)) %>% ungroup() %>% mutate(mean_sd_theta = mean(std_theta, na.rm=T)) -->


<!-- idio_shock_data_wide$mean_sd_theta -->
<!-- ``` -->

\subsection{Coefficient of Variation of Income}
\par 
Here I use the dataframe of townsend.1.pc2 to derive this statistic. 

```{r coef of variation of income}
cvi_data = townsend.1.pc2 %>% select(wave, id3,hhno, win_total_net_income_cropsales_pc2) %>% 
  group_by(hhno) %>% mutate(sd_income = sd(win_total_net_income_cropsales_pc2, na.rm=T)) %>% 
  mutate(mean_inc = mean(win_total_net_income_cropsales_pc2, na.rm=T)) %>%  ungroup() %>% group_by(id3) %>% mutate(mean_vil_sd = mean(sd_income, na.rm=T)) %>% mutate(mean_vil_minc = mean(mean_inc, na.rm=T)) %>% 
  mutate(cvi = mean_vil_sd/mean_vil_minc) %>% ungroup() %>% mutate(mean_cvi = mean(cvi, na.rm=T))

correlation = townsend.1.pc2 %>% select(wave, id3, hhno, win_total_net_income_cropsales_pc2, win_total_consumption_defl_pc2) %>% filter(!is.na(win_total_net_income_cropsales_pc2)) %>% filter(!is.na(win_total_consumption_defl_pc2)) 

cor(correlation$win_total_net_income_cropsales_pc2,correlation$win_total_consumption_defl_pc2)


### townsend as in the model
model_town = townsend.1.pc2 %>% select(wave, id3, hhno, wave, id3, hhno, win_total_net_income_cropsales_pc2, win_total_consumption_defl_pc2, sell.rights_ea.weighted_na0) %>% group_by(hhno) %>%  mutate(hh_index = group_indices()) %>% ungroup() %>% group_by(id3,wave) %>%  mutate(wave.id3 = group_indices())

town_mod1 = lm(log(win_total_consumption_defl_pc2) ~
                  log(win_total_net_income_cropsales_pc2)*sell.rights_ea.weighted_na0
                  + factor(hh_index)                  
                  + factor(wave.id3)
                  , data = model_town)

town_mod = coeftest(town_mod1)
stargazer(town_mod, omit=c('wave.id3', "hh_index"), type="latex")

 
```


\par 
Also last thing is to find the Q1 and Q2 village level of land security. To do so I take the variable in the main Townsend regression $sell-rights_{v,t}$ and take the values from there. 
```{r distribution of sell rights}

land_security_village_level = townsend.1.pc2 %>% 
                              select(wave, id1, id2, id3, hhno, sell.rights_ea.weighted_na0) %>% 
                              group_by(id3) %>% 
                              mutate(mean_vil_sellright_over_waves = mean(sell.rights_ea.weighted_na0, na.rm = T)) %>% 
  ungroup() %>% filter(!duplicated(id3)) 
summary(land_security_village_level$mean_vil_sellright_over_waves)
quantile(land_security_village_level$mean_vil_sellright_over_waves, probs = seq(0,1,0.2), na.rm=T)
```
















